
//-----------------------------------------------------------------------------
/** @file RichNonZeroSuppData_V2.icpp
 *
 *  Implementation file for RICH DAQ helper class : RichNonZeroSuppData
 *
 *  $Id: RichNonZeroSuppData_V2.icpp,v 1.2 2006-09-21 08:30:59 jonrob Exp $
 *
 *  @author Chris Jones  Christopher.Rob.Jones@cern.ch
 *  @date   2004-12-17
 */
//-----------------------------------------------------------------------------

// Gaudi
#include "GaudiKernel/MsgStream.h"

// local
#include "RichNonZeroSuppData_V2.h"

// RichKernel
#include "RichKernel/RichMap.h"

// namespaces
using namespace LHCb; ///< LHCb general namespace

// =================================================================================================

namespace RichNonZeroSuppDataV2
{

  template< class Version, class Header, class Footer >
  void
  RichNonZeroSuppData<Version,Header,Footer>::buildData( const RichSmartID::Vector & digits )
  {
    // Set data words
    for ( LHCb::RichSmartID::Vector::const_iterator iDig = digits.begin();
          iDig != digits.end(); ++ iDig )
    {
      setPixelActive( (*iDig).pixelRow(), (*iDig).pixelCol() );
    }
    // set footer parity
    if ( this->footer().hasParityWord() )
    {
      Footer foot = this->footer();
      foot.setParityWord( this->createParityWord(digits) );
      this->setFooter(foot);
    }
    // Fill the number of 8 bit words + 1 field in header
    Header head ( this->header() );
    head.setNEightBitBlocksPlusOne ( calcEightBitword(digits) + 1 );
    this->setHeader( head );
  }

  template< class Version, class Header, class Footer >
  RichDAQ::ShortType
  RichNonZeroSuppData<Version,Header,Footer>::calcEightBitword( const LHCb::RichSmartID::Vector & digits ) const
  {
    // temporary data map
    typedef Rich::Map< RichDAQ::ShortType, RichDAQ::ShortType > DataMap;
    DataMap dataM;

    // Loop over digits
    for ( RichSmartID::Vector::const_iterator iID = digits.begin();
          iID != digits.end(); ++iID )
    {

      // Get bit and address
      const RichDAQ::ShortType bit     = RichZSPacked::bitFromCol( (*iID).pixelCol() );
      const RichDAQ::ShortType address = RichZSPacked::addressFromRowCol( (*iID).pixelRow(), (*iID).pixelCol() );

      // Set the correct bit on for this address
      this->setBit( dataM[address], bit );

    }

    // How many words ?
    const RichDAQ::ShortType nWords = dataM.size()/2 + dataM.size()%2;
    return nWords;
  }

  template< class Version, class Header, class Footer >
  RichDAQ::ShortType
  RichNonZeroSuppData<Version,Header,Footer>::fillRichSmartIDs( RichSmartID::Vector & ids,
                                                                const LHCb::RichSmartID hpdID ) const
  {
    m_nHits = 0; // reset number of hits to zero

    // Fill with active channels
    for ( RichDAQ::ShortType iRow = 0; iRow < RichDAQ::MaxDataSize; ++iRow )
    {
      for ( RichDAQ::ShortType iCol = 0; iCol < RichDAQ::MaxDataSize; ++iCol )
      {
        if ( isPixelActive(iRow,iCol) )
        {
          ids.push_back( RichSmartID( hpdID.rich(),
                                      hpdID.panel(),
                                      hpdID.hpdNumInCol(),
                                      hpdID.hpdCol(),
                                      iRow, iCol ) );
          ++m_nHits; // count hits
        }
      }
    }

    return m_nHits;
  }

  template< class Version, class Header, class Footer >
  RichDAQ::ShortType RichNonZeroSuppData<Version,Header,Footer>::hitCount() const
  {
    if ( m_nHits < 0 )
    {
      // not yet calculated, so need to do it here
      m_nHits = 0;
      for ( RichDAQ::ShortType iRow = 0; iRow < RichDAQ::MaxDataSize; ++iRow )
      {
        for ( RichDAQ::ShortType iCol = 0; iCol < RichDAQ::MaxDataSize; ++iCol )
        {
          if ( isPixelActive(iRow,iCol) )
          {
            ++m_nHits; // count hits
          }
        }
      }
    }
    return static_cast<RichDAQ::ShortType>(m_nHits);
  }

} // end V2 namespace
