
//-----------------------------------------------------------------------------
/** @file RichZeroSuppData_V3.cpp
 *
 *  Implementation file for RICH DAQ helper class : RichZeroSuppData
 *
 *  $Id: RichZeroSuppData_V3.icpp,v 1.8 2006-09-26 15:40:05 jonrob Exp $
 *
 *  @author Chris Jones  Christopher.Rob.Jones@cern.ch
 *  @date   2004-12-17
 */
//-----------------------------------------------------------------------------

// local
#include "RichZeroSuppData_V3.h"

// RichKernel
#include "RichKernel/RichMap.h"

// namespaces
using namespace LHCb; ///< LHCb general namespace

//-----------------------------------------------------------------------------

namespace RichZeroSuppDataV3
{

  template< class Version, class Header, class Footer >
  void RichZeroSuppData<Version,Header,Footer>::buildData( const RichSmartID::Vector & pdHits )
  {

    // temporary data map
    typedef Rich::Map< RichDAQ::ShortType, RichDAQ::ShortType > DataMap;
    DataMap dataM;

    // Loop over digits
    for ( RichSmartID::Vector::const_iterator iID = pdHits.begin();
          iID != pdHits.end(); ++iID )
    {

      // Get bit and address
      const RichDAQ::ShortType bit     = 
        RichZSPacked_V2::RichZSPacked::bitFromCol( (*iID).pixelCol() );
      const RichDAQ::ShortType address = 
        RichZSPacked_V2::RichZSPacked::addressFromRowCol( (*iID).pixelRow(), (*iID).pixelCol() );

      // Set the correct bit on for this address
      this->setBit( dataM[address], bit );

    }

    // How many words ?
    const RichDAQ::ShortType nWords = dataM.size()/2 + dataM.size()%2;
    if ( nWords > RichDAQ::MaxDataSize ) { m_tooBig = true; return; }

    // Store "nEightBitBlocksPlusOne" value in header word
    Header head ( this->header() );
    head.setNEightBitBlocksPlusOne ( dataM.size() + 1 );
    this->setHeader( head );

    // Loop over address / bitfield pairs and fill to data bank
    DataMap::const_iterator iD = dataM.begin();
    while ( iD != dataM.end() )
    {
      const RichDAQ::ShortType address0( (*iD).first ), field0( (*iD).second );
      RichDAQ::ShortType address1(0), field1(0);
      ++iD;
      if ( iD != dataM.end() )
      {
        address1 = (*iD).first;
        field1   = (*iD).second;
        ++iD;
      }

      // Add these to the data block
      this->addData( RichZSPacked_V2::RichZSPacked( address0, field0, address1, field1 ) );
    }

    // set footer parity
    if ( this->footer().hasParityWord() )
    {
      Footer foot = this->footer();
      foot.setParityWord( this->createParityWord(pdHits) );
      this->setFooter(foot);
    }

  }

  template< class Version, class Header, class Footer >
  RichDAQ::ShortType RichZeroSuppData<Version,Header,Footer>::fillRichSmartIDs ( RichSmartID::Vector & ids,
                                                                                 const LHCb::RichSmartID hpdID ) const
  {
    m_nHits = 0; // reset number of hits to zero

    // Number of data words
    const RichDAQ::ShortType nDataWords = this->dataSize();

    // Is the last word padded or not ?
    const bool lastWordIsPadded = ( 0 == this->header().nEightBitBlocksPlusOne()%2 );

    // Loop over data fields
    for ( RichDAQ::ShortType iData = 0; iData < nDataWords; ++iData )
    {

      // Get packed data data
      const RichZSPacked_V2::RichZSPacked zsData( this->data()[iData] );

      // Get first address and bit field
      const RichDAQ::ShortType address0 = zsData.address0();
      const RichDAQ::ShortType bits0    = zsData.bitField0();
      if ( bits0 != 0 )
      {
        for ( RichDAQ::ShortType iB = 0; iB < RichZSPacked_V2::RichZSPackedCode::BitsField; ++iB )
        {
          if ( this->isBitOn(bits0,iB) )
          {
            const RichSmartID id( hpdID.rich(), hpdID.panel(),
                                  hpdID.hpdNumInCol(), hpdID.hpdCol(),
                                  RichZSPacked_V2::RichZSPacked::rowFromAddress(address0),
                                  RichZSPacked_V2::RichZSPacked::colFromAddressAndBit(address0,iB) );
            ids.push_back( id );
            ++m_nHits; // count hits
          }
        }
      }

      if ( (iData < this->dataSize()-1) || !lastWordIsPadded )  
      {
        // Get second address and bit field
        const RichDAQ::ShortType address1 = zsData.address1();
        const RichDAQ::ShortType bits1    = zsData.bitField1();
        if ( address0 != address1 && bits1 != 0 )
        {
          for ( RichDAQ::ShortType iB = 0; iB < RichZSPacked_V2::RichZSPackedCode::BitsField; ++iB )
          {
            if ( this->isBitOn(bits1,iB) )
            {
              const RichSmartID id( hpdID.rich(), hpdID.panel(),
                                    hpdID.hpdNumInCol(), hpdID.hpdCol(),
                                    RichZSPacked_V2::RichZSPacked::rowFromAddress(address1),
                                    RichZSPacked_V2::RichZSPacked::colFromAddressAndBit(address1,iB) );
              ids.push_back( id );
              ++m_nHits; // count hits
            }
          }
        }
      }

    }

    return m_nHits;
  }

  template< class Version, class Header, class Footer >
  RichDAQ::ShortType RichZeroSuppData<Version,Header,Footer>::hitCount() const
  {
    if ( m_nHits < 0 )
    {
      RichSmartID::Vector ids;
      const LHCb::RichSmartID hpdID(Rich::Rich1,Rich::top,0,0);
      this->fillRichSmartIDs(ids,hpdID); // fills m_nHits
    }
    return m_nHits;
  }

} // V3 namespace
