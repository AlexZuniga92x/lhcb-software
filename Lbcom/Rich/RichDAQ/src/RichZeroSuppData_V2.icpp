
//-----------------------------------------------------------------------------
/** @file RichZeroSuppData_V2.cpp
 *
 *  Implementation file for RICH DAQ helper class : RichZeroSuppData
 *
 *  $Id: RichZeroSuppData_V2.icpp,v 1.3 2006-09-24 10:09:50 jonrob Exp $
 *
 *  @author Chris Jones  Christopher.Rob.Jones@cern.ch
 *  @date   2004-12-17
 */
//-----------------------------------------------------------------------------

// local
#include "RichZeroSuppData_V2.h"

// RichKernel
#include "RichKernel/RichMap.h"

// namespaces
using namespace LHCb; ///< LHCb general namespace

//-----------------------------------------------------------------------------

namespace RichZeroSuppDataV2
{

  template< class Version, class Header, class Footer >
  void RichZeroSuppData<Version,Header,Footer>::buildData( const RichSmartID::Vector & pdHits )
  {

    // temporary data map
    typedef Rich::Map< RichDAQ::ShortType, RichDAQ::ShortType > DataMap;
    DataMap dataM;

    // Loop over digits
    for ( RichSmartID::Vector::const_iterator iID = pdHits.begin();
          iID != pdHits.end(); ++iID )
    {

      // Get bit and address
      const RichDAQ::ShortType bit     = bitFromCol( (*iID).pixelCol() );
      const RichDAQ::ShortType address = addressFromRowCol( (*iID).pixelRow(), (*iID).pixelCol() );

      // Set the correct bit on for this address
      this->setBit( dataM[address], bit );

    }

    // How many words ?
    const RichDAQ::ShortType nWords = dataM.size()/2 + dataM.size()%2;
    if ( nWords > RichDAQ::MaxDataSize ) { m_tooBig = true; return; }

    // Loop over address / bitfield pairs and fill to data bank
    DataMap::const_iterator iD = dataM.begin();
    while ( iD != dataM.end() )
    {
      const RichDAQ::ShortType address0( (*iD).first ), field0( (*iD).second );
      RichDAQ::ShortType address1(0), field1(0);
      ++iD;
      if ( iD != dataM.end() )
      {
        address1 = (*iD).first;
        field1   = (*iD).second;
        ++iD;
      }

      // Add these to the data block
      this->addData( RichZSPacked( address0, field0, address1, field1 ) );

    }

  }

  template< class Version, class Header, class Footer >
  RichDAQ::ShortType RichZeroSuppData<Version,Header,Footer>::fillRichSmartIDs ( RichSmartID::Vector & ids,
                                                                                 const LHCb::RichSmartID hpdID ) const
  {

    // For this implementation the header nEightBitBlocksPlusOne word contains the number of hits
    const RichDAQ::ShortType digitCount = this->header().nEightBitBlocksPlusOne();

    // Loop over data fields
    RichDAQ::ShortType nDigitsMade = 0;
    for ( RichDAQ::ShortType iData = 0; iData < this->dataSize(); ++iData )
    {

      // Get packed data data
      const RichZSPacked zsData( this->data()[iData] );

      // Get first address and bit field
      {
        const RichDAQ::ShortType address = zsData.address0();
        const RichDAQ::ShortType bits    = zsData.bitField0();
        for ( RichDAQ::ShortType iB = 0; iB < RichZSPackedCode::BitsField; ++iB )
        {
          if ( this->isBitOn(bits,iB) )
          {
            ids.push_back( RichSmartID( hpdID.rich(), hpdID.panel(),
                                        hpdID.hpdNumInCol(), hpdID.hpdCol(),
                                        rowFromAddress(address),
                                        colFromAddressAndBit(address,iB) ) );
            ++nDigitsMade;
            if ( nDigitsMade == digitCount ) break;
          }
        }
      }

      // Get second address and bit field
      {
        const RichDAQ::ShortType address = zsData.address1();
        const RichDAQ::ShortType bits    = zsData.bitField1();
        for ( RichDAQ::ShortType iB = 0; iB < RichZSPackedCode::BitsField; ++iB )
        {
          if ( this->isBitOn(bits,iB) )
          {
            ids.push_back( RichSmartID( hpdID.rich(), hpdID.panel(),
                                        hpdID.hpdNumInCol(), hpdID.hpdCol(),
                                        rowFromAddress(address),
                                        colFromAddressAndBit(address,iB) ) );
            ++nDigitsMade;
            if ( nDigitsMade == digitCount ) break;
          }
        }
      }

    }

    return nDigitsMade;
  }

  template< class Version, class Header, class Footer >
  RichDAQ::ShortType RichZeroSuppData<Version,Header,Footer>::hitCount() const
  {
    // For this implementation the header nEightBitBlocksPlusOne word contains the number of hits
    return this->header().nEightBitBlocksPlusOne();
  }

} // V2 namespace
