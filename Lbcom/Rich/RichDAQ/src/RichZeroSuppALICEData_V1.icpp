
//-----------------------------------------------------------------------------
/** @file RichZeroSuppALICEData_V1.icpp
 *
 *  Implementation file for RICH DAQ helper class : RichZeroSuppALICEData
 *
 *  $Id: RichZeroSuppALICEData_V1.icpp,v 1.1 2007-03-08 18:14:28 jonrob Exp $
 *
 *  @author Chris Jones  Christopher.Rob.Jones@cern.ch
 *  @date   2004-12-17
 */
//-----------------------------------------------------------------------------

// local
#include "RichZeroSuppALICEData_V1.h"

// RichKernel
#include "RichKernel/RichMap.h"

//-----------------------------------------------------------------------------

namespace Rich
{
  namespace DAQ
  {

    namespace RichZeroSuppALICEDataV1
    {

      // ------------------------------------------------------------------------------------------------
      template< class Version, class Header, class Footer >
      void RichZeroSuppALICEData<Version,Header,Footer>::buildData( const LHCb::RichSmartID::Vector & /* pdHits */ )
      {
        // Encoding not yet supported for ALICE mode ZS data
      }
      // ------------------------------------------------------------------------------------------------

      // ------------------------------------------------------------------------------------------------
      template< class Version, class Header, class Footer >
      ShortType RichZeroSuppALICEData<Version,Header,Footer>::fillRichSmartIDs ( LHCb::RichSmartID::Vector & ids,
                                                                                 const LHCb::RichSmartID hpdID ) const
      {
        using namespace RichZSPacked_V2;

        m_nHits = 0; // reset number of hits to zero

        // Number of data words
        const ShortType nDataWords = this->dataSize();

        // Is the last word padded or not ?
        const bool lastWordIsPadded = ( 1 == this->header().nEightBitBlocks()%2 );

        // rough guess at number of hits
        ids.reserve( nDataWords * 5 );

        int last_address(0), addressOffset(0);

        // Loop over data fields
        bool firstWord(true);
        for ( ShortType iData = 0; iData < nDataWords; ++iData )
        {

          // Get packed data data (in ALICE mode)
          const RichZSPacked zsData( this->data()[iData], true );

          // Get first address and bit field
          const ShortType address0 = zsData.address0();
          const ShortType bits0    = zsData.bitField0();
          // Logic to deal with repeated address
          updateOffset(address0,firstWord,last_address,addressOffset);
          if ( bits0 != 0 )
          {
            for ( ShortType iB = 0; iB < RichZSPacked::BitsField; ++iB )
            {
              if ( this->isBitOn(bits0,iB) )
              {
                ids.push_back( LHCb::RichSmartID( hpdID.rich(), hpdID.panel(),
                                                  hpdID.hpdNumInCol(), hpdID.hpdCol(),
                                                  zsData.rowFromAddress(address0,addressOffset),
                                                  zsData.colFromAddressAndBit(address0,iB),
                                                  zsData.subPixelFromAddress(address0) ) );
                ++m_nHits; // count hits
              }
            }
          }
          firstWord = false;

          if ( (iData < this->dataSize()-1) || !lastWordIsPadded )
          {
            // Get second address and bit field
            const ShortType address1 = zsData.address1();
            const ShortType bits1    = zsData.bitField1();
            // Logic to deal with repeated address
            updateOffset(address1,firstWord,last_address,addressOffset);
            if ( address0 != address1 && bits1 != 0 )
            {
              for ( ShortType iB = 0; iB < RichZSPacked::BitsField; ++iB )
              {
                if ( this->isBitOn(bits1,iB) )
                {
                  ids.push_back( LHCb::RichSmartID( hpdID.rich(), hpdID.panel(),
                                                    hpdID.hpdNumInCol(), hpdID.hpdCol(),
                                                    zsData.rowFromAddress(address1,addressOffset),
                                                    zsData.colFromAddressAndBit(address1,iB),
                                                    zsData.subPixelFromAddress(address1) ) );
                  ++m_nHits; // count hits
                }
              }
            }
          }

        }

        return m_nHits;
      }
      // ------------------------------------------------------------------------------------------------

      // ------------------------------------------------------------------------------------------------
      template< class Version, class Header, class Footer >
      ShortType RichZeroSuppALICEData<Version,Header,Footer>::hitCount() const
      {
        if ( m_nHits < 0 )
        {
          LHCb::RichSmartID::Vector ids;
          this->fillRichSmartIDs( ids, LHCb::RichSmartID(Rich::Rich1,Rich::top,0,0) ); // fills m_nHits
        }
        return m_nHits;
      }
      // ------------------------------------------------------------------------------------------------

    } // V1 namespace

  }
}
