
//-----------------------------------------------------------------------------
/** @file RichZeroSuppData_V4.icpp
 *
 *  Implementation file for RICH DAQ helper class : RichZeroSuppData
 *
 *  $Id: RichZeroSuppData_V4.icpp,v 1.1 2007-02-01 17:42:30 jonrob Exp $
 *
 *  @author Chris Jones  Christopher.Rob.Jones@cern.ch
 *  @date   2004-12-17
 */
//-----------------------------------------------------------------------------

// local
#include "RichZeroSuppData_V4.h"

// RichKernel
#include "RichKernel/RichMap.h"

//-----------------------------------------------------------------------------

namespace Rich
{
  namespace DAQ
  {

    namespace RichZeroSuppDataV4
    {

      // ------------------------------------------------------------------------------------------------
      template< class Version, class Header, class Footer >
      void RichZeroSuppData<Version,Header,Footer>::buildData( const LHCb::RichSmartID::Vector & pdHits )
      {

        // temporary data map
        typedef Rich::Map< ShortType, ShortType > DataMap;
        DataMap dataM;

        // Loop over digits
        for ( LHCb::RichSmartID::Vector::const_iterator iID = pdHits.begin();
              iID != pdHits.end(); ++iID )
        {

          // Get bit and address
          const ShortType bit     =
            RichZSPacked_V2::RichZSPacked::bitFromCol( (*iID).pixelCol() );
          const ShortType address =
            RichZSPacked_V2::RichZSPacked::addressFromRowCol( (*iID).pixelRow(), (*iID).pixelCol() );

          // Set the correct bit on for this address
          this->setBit( dataM[address], bit );

        }

        // How many words ?
        const ShortType nWords = dataM.size()/2 + dataM.size()%2;
        if ( nWords > MaxDataSize ) { m_tooBig = true; return; }

        // Store "nEightBitBlocks" value in header word
        Header head ( this->header() );
        head.setNEightBitBlocks ( dataM.size() );
        this->setHeader( head );

        // Loop over address / bitfield pairs and fill to data bank
        DataMap::const_iterator iD = dataM.begin();
        while ( iD != dataM.end() )
        {
          const ShortType address0( (*iD).first ), field0( (*iD).second );
          ShortType address1(0), field1(0);
          ++iD;
          if ( iD != dataM.end() )
          {
            address1 = (*iD).first;
            field1   = (*iD).second;
            ++iD;
          }

          // Add these to the data block
          this->addData( RichZSPacked_V2::RichZSPacked( address0, field0, address1, field1 ) );
        }

        // set footer parity, if in extended data format mode
        // basically, we don't simulate bit errors, so parity word here is just zero
        if ( this->header().extendedFormat() )
        {
          this->setFooter ( Footer(1,0) );
        }

      }
      // ------------------------------------------------------------------------------------------------

      // ------------------------------------------------------------------------------------------------
      template< class Version, class Header, class Footer >
      ShortType RichZeroSuppData<Version,Header,Footer>::fillRichSmartIDs ( LHCb::RichSmartID::Vector & ids,
                                                                            const LHCb::RichSmartID hpdID ) const
      {
        m_nHits = 0; // reset number of hits to zero

        // Number of data words
        const ShortType nDataWords = this->dataSize();

        // Is the last word padded or not ?
        const bool lastWordIsPadded = ( 1 == this->header().nEightBitBlocks()%2 );

        // rough guess at number of hits
        ids.reserve( nDataWords * 5 );

        // Loop over data fields
        for ( ShortType iData = 0; iData < nDataWords; ++iData )
        {

          // Get packed data data
          const RichZSPacked_V2::RichZSPacked zsData( this->data()[iData] );

          // Get first address and bit field
          const ShortType address0 = zsData.address0();
          const ShortType bits0    = zsData.bitField0();
          if ( bits0 != 0 )
          {
            for ( ShortType iB = 0; iB < RichZSPacked_V2::RichZSPackedCode::BitsField; ++iB )
            {
              if ( this->isBitOn(bits0,iB) )
              {
                ids.push_back( LHCb::RichSmartID( hpdID.rich(), hpdID.panel(),
                                                  hpdID.hpdNumInCol(), hpdID.hpdCol(),
                                                  RichZSPacked_V2::RichZSPacked::rowFromAddress(address0),
                                                  RichZSPacked_V2::RichZSPacked::colFromAddressAndBit(address0,iB) ) );
                ++m_nHits; // count hits
              }
            }
          }

          if ( (iData < this->dataSize()-1) || !lastWordIsPadded )
          {
            // Get second address and bit field
            const ShortType address1 = zsData.address1();
            const ShortType bits1    = zsData.bitField1();
            if ( address0 != address1 && bits1 != 0 )
            {
              for ( ShortType iB = 0; iB < RichZSPacked_V2::RichZSPackedCode::BitsField; ++iB )
              {
                if ( this->isBitOn(bits1,iB) )
                {
                  ids.push_back( LHCb::RichSmartID( hpdID.rich(), hpdID.panel(),
                                                    hpdID.hpdNumInCol(), hpdID.hpdCol(),
                                                    RichZSPacked_V2::RichZSPacked::rowFromAddress(address1),
                                                    RichZSPacked_V2::RichZSPacked::colFromAddressAndBit(address1,iB) ) );
                  ++m_nHits; // count hits
                }
              }
            }
          }

        }

        return m_nHits;
      }
      // ------------------------------------------------------------------------------------------------

      // ------------------------------------------------------------------------------------------------
      template< class Version, class Header, class Footer >
      ShortType RichZeroSuppData<Version,Header,Footer>::hitCount() const
      {
        if ( m_nHits < 0 )
        {
          LHCb::RichSmartID::Vector ids;
          this->fillRichSmartIDs( ids, LHCb::RichSmartID(Rich::Rich1,Rich::top,0,0) ); // fills m_nHits
        }
        return m_nHits;
      }
      // ------------------------------------------------------------------------------------------------

    } // V4 namespace

  }
}
