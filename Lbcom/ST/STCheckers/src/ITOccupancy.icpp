// $Id: ITOccupancy.icpp,v 1.1 2008-10-16 13:12:03 mneedham Exp $

// Gaudi
#include "GaudiKernel/AlgFactory.h"

// Histogramming
#include "AIDA/IHistogram1D.h"

// xml geometry
#include "STDet/DeSTDetector.h"
#include "STDet/DeITLadder.h"

// GaudiKernel
#include "Kernel/ISTSignalToNoiseTool.h"

// Event

// local
#include "ITOccupancy.h"

using namespace LHCb;

//--------------------------------------------------------------------
//
//  ITOccupancy : Check occupancies in inner tracker
//
//--------------------------------------------------------------------



template <class PBASE>
inline ITOccupancy<PBASE>::ITOccupancy( const std::string& name, 
                          ISvcLocator* pSvcLocator ) :
  ST::HistoAlgBase(name, pSvcLocator),
  m_sigNoiseTool(0)
{
  // constructer
  declareProperty("Threshold",m_threshold);
  declareProperty("SigNoiseTool",m_sigNoiseToolName = "STSignalToNoiseTool");
  declareProperty("BinSize", m_binSize = 32);
  declareProperty("DataLocation",m_dataLocation = dataLocation());

  setDetType("IT");
  setForcedInit();

  m_threshold.reserve(3);
  for (int iThres=0;iThres<3;++iThres){
    m_threshold.push_back(defaultThreshold());
  } //i
}

template <class PBASE>
inline ITOccupancy<PBASE>::~ITOccupancy()
{
  // destructer
}


template <class PBASE>
inline StatusCode ITOccupancy<PBASE>::initialize()
{
  // Set the top directory to IT or TT.
  setHistoDir(histoDirName());
  if( "" == histoTopDir() ) setHistoTopDir(detType()+"/");
 
  // Initialize GaudiHistoAlg
  StatusCode sc = ST::HistoAlgBase::initialize();
  if (sc.isFailure()) return Error("Failed to initialize", sc);


  // signal to noise tool
  m_sigNoiseTool = tool<ISTSignalToNoiseTool>(m_sigNoiseToolName, 
                                              m_sigNoiseToolName + detType());

  // intialize histos
  this->initHistograms();

  return StatusCode::SUCCESS;
}

template <class PBASE>
inline void ITOccupancy<PBASE>::initHistograms()
{
  int numInVector = 0;
  unsigned int nstrip = tracker()->sectors().front()->nStrip();
  
  std::vector<DeSTLayer*>::const_iterator iterLayer = tracker()->layers().begin();
  for ( ; iterLayer != tracker()->layers().end(); ++iterLayer){

    // Get teh number of strips in this layer
    const DeITLayer* tLayer = dynamic_cast<const DeITLayer*>(*iterLayer);
    unsigned int nStripInLayer = nstrip*tLayer->ladders().size();
    unsigned int bins = nStripInLayer/m_binSize;

    // unique id using station, layer and detRegion
    STChannelID aChan = (*iterLayer)->elementID();
    int id = this->uniqueInt( aChan );

    // construct the histogram title
    std::string histo = uniqueLayer(aChan);

    IHistogram1D* stripOccHisto =
      book("N_"+histo,0., bins*m_binSize, bins);
    m_stripOccVector.push_back(stripOccHisto);

    m_layerOccVector.push_back(0.);
    m_nStripsVector.push_back((double)nStripInLayer);

    IHistogram1D* layerOccHisto = book("Occupancy_"+histo,0.0,0.2,100);
    m_layerOccHistos.push_back(layerOccHisto);
    
    // add to map
    m_mapping[id] = numInVector;
    ++numInVector;
  } // iterLayer

  return;
}

template <class PBASE>
inline StatusCode ITOccupancy<PBASE>::execute()
{

  typedef typename PBASE::Container Container; 
  typedef typename Container::const_iterator iterator;

  std::vector<double>::iterator iter = m_layerOccVector.begin();
  for( ; iter!=m_layerOccVector.end();++iter) *iter=0.;

  // retrieve Digitizations
  const Container* objCont = get<Container>(m_dataLocation);
  
  // histos per digit
  iterator iterObj = objCont->begin();
  for( ; iterObj != objCont->end(); ++iterObj){
    this->fillHistograms(*iterObj);
  } // loop iterDigit

  // average occupancy in each layer
  int iCount = 0;
  for (iter=m_layerOccVector.begin();iter!=m_layerOccVector.end();++iter){
    if ( m_nStripsVector[iCount] != 0 ) { 
      double occ = (double)(*iter)/m_nStripsVector[iCount];
      m_layerOccHistos[iCount]->fill(occ);
    }
    ++iCount;
  }
 
  return StatusCode::SUCCESS;
}

template <class PBASE>
void ITOccupancy<PBASE>::fillHistograms(const PBASE* obj)
{
  // retrieve geom info
  if (m_sigNoiseTool->signalToNoise(obj) >
      m_threshold[obj->station()-tracker()->firstStation()]){
  
    // get the channel and map to number in local vector
    const STChannelID aChan = obj->channelID();  
    int id = uniqueInt(aChan);
    int numInVector = m_mapping[id];

    // get the number of strips
    const unsigned int nstrips = findSector(aChan)->nStrip();

    m_stripOccVector[numInVector]->fill( (double) aChan.strip() - 1. +
                                        (nstrips*(aChan.sector()-1)));
    ++m_layerOccVector[numInVector];

  } // if above threshold

  return;
}

template <class PBASE>
inline int ITOccupancy<PBASE>::uniqueInt(const STChannelID aChan) const 
{
  return ((aChan.station()*100)+(10*aChan.detRegion())+aChan.layer());
}
