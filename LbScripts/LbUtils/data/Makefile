# $Id: Makefile,v 1.7 2009-09-03 13:39:07 marcocle Exp $
################################################################################
#
# Generic Makefile for CMT projects.
#
# copied to the top-level directory of a project (even user project), it can be
# used to start a build of the whole project with just a call to "make".
# It is equivalent to a "cmt broadcast make", or, if invoked with "-j" to a
# "tbroadcast make -j", but better. 
#
# Author: Marco Clemencic
#
################################################################################

# --- List of Packages in the current directory
packages := $(strip $(subst /cmt/requirements,,$(wildcard */cmt/requirements) $(wildcard */*/cmt/requirements)))

# --- Utility functions 
escape_slash = $(subst /,_slash_,$(1))
unescape_slash = $(subst _slash_,/,$(1))

#  Note: The command "cmt show groups" does not work in old versions of CMT
cmt_version := $(shell cmt version)
ifeq ($(cmt_version),v1r20p20090520)
groups = all `(cmt show groups)`
else
groups = all all_groups
endif

# --- Common configuration variables
# The special environment variable PIPESTATUS is a bash feature, so we have to force
# the usage of that shell.
SHELL=/bin/bash --norc
# Banners to be printed for the targets.
define build_banner
echo "#==============================================================================="
echo "# Building package $(1)"
echo "#==============================================================================="
endef
define clean_banner
echo "#==== Cleaning package $(1)"
endef

# -- Special macro to change the behavior on a failure of a package
#    (complementary to the option '-k')
#  Allowed values for Package_failure_policy:
#    stop:   do not continue (default)
#    skip:   if a group fails, continue with the next package
#    ignore: try all the groups even if one fails before going to the next package
#            (may result in duplicated errors within a package) 
Package_failure_handler = test $$BUILD_RESULT -eq 0 || exit $$BUILD_RESULT ;
ifdef Package_failure_policy
ifeq ($(Package_failure_policy),stop)
Package_failure_handler = test $$BUILD_RESULT -eq 0 || exit $$BUILD_RESULT ;
else
ifeq ($(Package_failure_policy),skip)
Package_failure_handler = test $$BUILD_RESULT -eq 0 || break ;
else
ifeq ($(Package_failure_policy),ignore)
Package_failure_handler = 
else
$(error Unknown Package_failure_policy "$(Package_failure_policy)". Allowed values: "stop" (default), "skip", "ignore")
endif
endif
endif
endif

# Fix the separator for environment variables
# (needed if the variables are specified as lists in Eclipse)
COMMA := ,
override CMTEXTRATAGS := $(subst ;,$(COMMA),$(CMTEXTRATAGS))
override CMTPROJECTPATH := $(subst ;,:,$(CMTPROJECTPATH))

# --- Declare the variables that have to be exported
export PATH LD_LIBRARY_PATH PYTHONPATH CMTEXTRATAGS CMTPROJECTPATH CMTUSERCONTEXT
export CCACHE_PREFIX

# --- Main targets
all: $(packages:=_build)

clean: $(packages:=_clean)
	rm -rf InstallArea

purge: clean
	rm -rf .*.pack.d $(packages:=/cmt/Makefile)


# --- Add rules to build packages (e.g. "make MyHat/MyPackage")
$(foreach pack,$(packages),$(eval $(pack): $(pack)_build))
$(foreach pack,$(packages),$(eval .PHONY: $(pack)))
# --- Prevents removal of the Makefiles generated by "cmt config" 
$(foreach pack,$(packages),$(eval .PRECIOUS: $(pack)/cmt/Makefile))
ifeq ($(cmt_version),v1r20p20090520)
$(foreach pack,$(packages),$(eval .PRECIOUS: $(pack)/cmt/version.cmt))
endif

# --- Actual rules
%/cmt/Makefile:
	@echo Configuring package $*
	@cd $*/cmt && cmt config

ifeq ($(cmt_version),v1r20p20090520)
%/cmt/version.cmt: %/cmt/requirements
	@echo Generate $@
	@awk 'BEGIN{version="v*"}/^ *version/{version = $$2}END{print version}' $< > $@
%_build: %/cmt/Makefile %/cmt/version.cmt
else
%_build: %/cmt/Makefile
endif
	@$(call build_banner,$*)
	@date > $*/cmt/build.$(CMTCONFIG).log
	@+cd $*/cmt ; \
	for group in $(groups) ; do \
		echo "# Building group $$group" | tee -a build.$(CMTCONFIG).log ; \
		cmt make $$group 2>&1 | tee -a build.$(CMTCONFIG).log ; export BUILD_RESULT=$$PIPESTATUS \
		date >> build.$(CMTCONFIG).log ; \
		$(Package_failure_handler) \
	done

ifeq ($(cmt_version),v1r20p20090520)
%_clean: %/cmt/Makefile %/cmt/version.cmt
else
%_clean: %/cmt/Makefile
endif
	@$(call clean_banner,$*)
	-$(MAKE) -j1 -C $*/cmt clean binclean


## --- Dependencies between packages
# The PKG_ONLY macro can be used to build a single package disregarding the
# dependencies between packages.
ifndef PKG_ONLY
MKDEPCMD := cmt show uses | tr " " "\t" | awk -F"\t" '/^\#\t*use/{if($$5){print $$5"/"$$3}else{print $$3}}'
.%.pack.d: pack=$(call unescape_slash,$*)
.%.pack.d:
	@echo Computing dependencies for package $(pack)
	@echo $(pack)_build: $(patsubst %,%_build,$(filter $(packages),$(shell cd $(pack)/cmt; $(MKDEPCMD)))) > $@
	@echo $@: $(pack)/cmt/requirements >> $@

ifneq ($(MAKECMDGOALS),purge)
-include $(patsubst %,.%.pack.d,$(call escape_slash, $(packages)))
endif
endif

# --- List of phony targets
.PHONY: all clean purge
# This makes the package targets PHONY (.PHONY does not work with implicit rules)
$(foreach pack,$(packages),$(eval $(pack)_config $(pack)_build $(pack)_clean: FORCE))
FORCE:
