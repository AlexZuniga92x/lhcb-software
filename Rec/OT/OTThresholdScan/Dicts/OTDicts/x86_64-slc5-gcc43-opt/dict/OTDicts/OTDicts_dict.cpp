// Generated at Tue Oct 26 14:03:53 2010. Do not modify it

/*
GCC-XML version 0.9.0_20100114
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/sw/lcg/external/gccxml/0.9.0_20100114/x86_64-slc5-gcc43-opt/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/sw/lcg/external/gccxml/0.9.0_20100114/x86_64-slc5-gcc43-opt/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/sw/lcg/external/gccxml/0.9.0_20100114/x86_64-slc5-gcc43-opt/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__FLT_MIN__='1.17549435e-38F' -D__DEC64_DEN__='0.000000000000001E-383DD' -D__CHAR_BIT__='8' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='4.9406564584124654e-324' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__LP64__='1' -D__GNUC_PATCHLEVEL__='2' -D__DEC64_MAX_EXP__='384' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__LDBL_MAX_EXP__='16384' -D__linux__='1' -D__SCHAR_MAX__='127' -D__DBL_DIG__='15' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209290e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__SIZEOF_LONG__='8' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__DBL_MAX__='1.7976931348623157e+308' -D__DBL_HAS_INFINITY__='1' -D__DEC32_MIN_EXP__='(-95)' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__DBL_MIN__='2.2250738585072014e-308' -D__FLT_MIN_10_EXP__='(-37)' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__DBL_HAS_DENORM__='1' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.3.2"' -D__DEC64_EPSILON__='1E-15DD' -D__DEC128_MIN_EXP__='(-6143)' -Dunix='1' -D__SIZE_TYPE__='long unsigned int' -D__DEC32_DEN__='0.000001E-95DF' -D__ELF__='1' -D__FLT_RADIX__='2' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__k8='1' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__FLT_HAS_INFINITY__='1' -D__DEC64_MAX__='9.999999999999999E384DD' -D__DEC64_MANT_DIG__='16' -D__DEC32_MAX_EXP__='96' -Dlinux='1' -D__DEC128_DEN__='0.000000000000000000000000000000001E-6143DL' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__k8__='1' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__DEC64_MIN_EXP__='(-383)' -D__FLT_DIG__='6' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__FLT_MAX_EXP__='128' -D__DBL_MANT_DIG__='53' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='2.2204460492503131e-16' -D_LP64='1' -D__SIZEOF_WCHAR_T__='4' -D__DEC_EVAL_METHOD__='2' -D__INTMAX_MAX__='9223372036854775807L' -D__FLT_DENORM_MIN__='1.40129846e-45F' -D__FLT_MAX__='3.40282347e+38F' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6144' -D__GNUC_MINOR__='3' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__GNUC_GNU_INLINE__='1' -D_GNU_SOURCE='1' -iwrapper"/afs/cern.ch/sw/lcg/external/gccxml/0.9.0_20100114/x86_64-slc5-gcc43-opt/share/gccxml-0.9/GCC/4.3" -isystem"/afs/cern.ch/sw/lcg/contrib/gcc/4.3.2/x86_64-slc5-gcc34-opt/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.3.2/../../../../include/c++/4.3.2" -isystem"/afs/cern.ch/sw/lcg/contrib/gcc/4.3.2/x86_64-slc5-gcc34-opt/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.3.2/../../../../include/c++/4.3.2/x86_64-unknown-linux-gnu" -isystem"/afs/cern.ch/sw/lcg/contrib/gcc/4.3.2/x86_64-slc5-gcc34-opt/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.3.2/../../../../include/c++/4.3.2/backward" -isystem"/afs/cern.ch/sw/lcg/contrib/gcc/4.3.2/x86_64-slc5-gcc34-opt/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.3.2/include" -isystem"/afs/cern.ch/sw/lcg/contrib/gcc/4.3.2/x86_64-slc5-gcc34-opt/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.3.2/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/sw/lcg/contrib/gcc/4.3.2/x86_64-slc5-gcc34-opt/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/sw/lcg/external/gccxml/0.9.0_20100114/x86_64-slc5-gcc43-opt/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.3.2
Copyright (C) 2008 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/afs/cern.ch/user/d/dvaneijk/cmtuser/Bender_v15r1p1/Dicts/OTDicts/dict/OTDicts.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( "std" );
  ::Reflex::NamespaceBuilder nsb1( "Gaudi" );
  ::Reflex::NamespaceBuilder nsb2( "LHCb" );
  ::Reflex::Type type_void = ::Reflex::TypeBuilder("void");
  ::Reflex::Type type_2051 = ::Reflex::TypeBuilder("std::vector<LHCb::OTLiteTime>");
  ::Reflex::Type type_9427 = ::Reflex::TypedefTypeBuilder("LHCb::OTLiteTime::Vector", type_2051);
  ::Reflex::Type type_2006 = ::Reflex::TypeBuilder("std::_Vector_base<const LHCb::Node*,std::allocator<const LHCb::Node*> >");
  ::Reflex::Type type_3728 = ::Reflex::TypeBuilder("LHCb::Node");
  ::Reflex::Type type_3728c = ::Reflex::ConstBuilder(type_3728);
  ::Reflex::Type type_4530 = ::Reflex::PointerBuilder(type_3728c);
  ::Reflex::Type type_2387 = ::Reflex::TypeBuilder("std::allocator<const LHCb::Node*>");
  ::Reflex::Type type_4685 = ::Reflex::PointerBuilder(type_4530);
  ::Reflex::Type type_4530c = ::Reflex::ConstBuilder(type_4530);
  ::Reflex::Type type_4533 = ::Reflex::PointerBuilder(type_4530c);
  ::Reflex::Type type_4688 = ::Reflex::ReferenceBuilder(type_4530);
  ::Reflex::Type type_4535 = ::Reflex::ReferenceBuilder(type_4530c);
  ::Reflex::Type type_3448 = ::Reflex::TypeBuilder("__gnu_cxx::__normal_iterator<const LHCb::Node**,std::vector<const LHCb::Node*> >");
  ::Reflex::Type type_3447 = ::Reflex::TypeBuilder("__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >");
  ::Reflex::Type type_2460 = ::Reflex::TypeBuilder("std::reverse_iterator<__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> > >");
  ::Reflex::Type type_2461 = ::Reflex::TypeBuilder("std::reverse_iterator<__gnu_cxx::__normal_iterator<const LHCb::Node**,std::vector<const LHCb::Node*> > >");
  ::Reflex::Type type_22 = ::Reflex::TypeBuilder("unsigned long");
  ::Reflex::Type type_891 = ::Reflex::TypedefTypeBuilder("size_t", type_22);
  ::Reflex::Type type_139 = ::Reflex::TypeBuilder("long");
  ::Reflex::Type type_536 = ::Reflex::TypedefTypeBuilder("ptrdiff_t", type_139);
  ::Reflex::Type type_2387c = ::Reflex::ConstBuilder(type_2387);
  ::Reflex::Type type_10983 = ::Reflex::ReferenceBuilder(type_2387c);
  ::Reflex::Type type_2052 = ::Reflex::TypeBuilder("std::vector<const LHCb::Node*>");
  ::Reflex::Type type_2052c = ::Reflex::ConstBuilder(type_2052);
  ::Reflex::Type type_11117 = ::Reflex::ReferenceBuilder(type_2052c);
  ::Reflex::Type type_11118 = ::Reflex::ReferenceBuilder(type_2052);
  ::Reflex::Type type_595 = ::Reflex::TypeBuilder("void");
  ::Reflex::Type type_2662 = ::Reflex::TypeBuilder("bool");
  ::Reflex::Type type_3532 = ::Reflex::TypeBuilder("Gaudi::RangeBase_");
  ::Reflex::Type type_2331 = ::Reflex::TypeBuilder("std::pair<__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >,__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> > >");
  ::Reflex::Type type_3649 = ::Reflex::TypeBuilder("Gaudi::Range_<std::vector<const LHCb::Node*> >");
  ::Reflex::Type type_11974 = ::Reflex::ReferenceBuilder(type_3649);
  ::Reflex::Type type_3649c = ::Reflex::ConstBuilder(type_3649);
  ::Reflex::Type type_11975 = ::Reflex::ReferenceBuilder(type_3649c);
  ::Reflex::Type type_2331c = ::Reflex::ConstBuilder(type_2331);
  ::Reflex::Type type_11461 = ::Reflex::ReferenceBuilder(type_2331c);
  ::Reflex::Type type_891c = ::Reflex::ConstBuilder(type_891);
  ::Reflex::Type type_139c = ::Reflex::ConstBuilder(type_139);
  ::Reflex::Type type_3730 = ::Reflex::TypeBuilder("LHCb::OTChannelID");
  ::Reflex::Type type_1717 = ::Reflex::TypeBuilder("double");
  ::Reflex::Type type_3650 = ::Reflex::TypeBuilder("Gaudi::Range_<std::vector<LHCb::OTLiteTime> >");
  ::Reflex::Type type_3723 = ::Reflex::TypeBuilder("LHCb::OTLiteTime");
  ::Reflex::Type type_4624 = ::Reflex::ReferenceBuilder(type_3723);
  ::Reflex::Type type_3723c = ::Reflex::ConstBuilder(type_3723);
  ::Reflex::Type type_4626 = ::Reflex::ReferenceBuilder(type_3723c);
  ::Reflex::Type type_3730c = ::Reflex::ConstBuilder(type_3730);
  ::Reflex::Type type_9920 = ::Reflex::ReferenceBuilder(type_3730c);
  ::Reflex::Type type_2498 = ::Reflex::TypeBuilder("std::basic_ostream<char,std::char_traits<char> >");
  ::Reflex::Type type_2597 = ::Reflex::TypedefTypeBuilder("std::ostream", type_2498);
  ::Reflex::Type type_3919 = ::Reflex::ReferenceBuilder(type_2597);
  ::Reflex::Type type_2005 = ::Reflex::TypeBuilder("std::_Vector_base<LHCb::OTLiteTime,std::allocator<LHCb::OTLiteTime> >");
  ::Reflex::Type type_2386 = ::Reflex::TypeBuilder("std::allocator<LHCb::OTLiteTime>");
  ::Reflex::Type type_4620 = ::Reflex::PointerBuilder(type_3723);
  ::Reflex::Type type_4622 = ::Reflex::PointerBuilder(type_3723c);
  ::Reflex::Type type_3445 = ::Reflex::TypeBuilder("__gnu_cxx::__normal_iterator<LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >");
  ::Reflex::Type type_3446 = ::Reflex::TypeBuilder("__gnu_cxx::__normal_iterator<const LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >");
  ::Reflex::Type type_2458 = ::Reflex::TypeBuilder("std::reverse_iterator<__gnu_cxx::__normal_iterator<const LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> > >");
  ::Reflex::Type type_2459 = ::Reflex::TypeBuilder("std::reverse_iterator<__gnu_cxx::__normal_iterator<LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> > >");
  ::Reflex::Type type_2386c = ::Reflex::ConstBuilder(type_2386);
  ::Reflex::Type type_10971 = ::Reflex::ReferenceBuilder(type_2386c);
  ::Reflex::Type type_2051c = ::Reflex::ConstBuilder(type_2051);
  ::Reflex::Type type_11115 = ::Reflex::ReferenceBuilder(type_2051c);
  ::Reflex::Type type_11116 = ::Reflex::ReferenceBuilder(type_2051);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __std__vector_constsLHCb__Nodep_
#undef __std__vector_constsLHCb__Nodep_
#endif
class __std__vector_constsLHCb__Nodep_ : protected ::std::_Vector_base<const LHCb::Node*,std::allocator<const LHCb::Node*> > {
  public:
  __std__vector_constsLHCb__Nodep_();
};
#ifdef __Gaudi__Range__std__vector_constsLHCb__Nodep_s_
#undef __Gaudi__Range__std__vector_constsLHCb__Nodep_s_
#endif
class __Gaudi__Range__std__vector_constsLHCb__Nodep_s_ : public ::Gaudi::RangeBase_ {
  public:
  __Gaudi__Range__std__vector_constsLHCb__Nodep_s_();
  ::std::pair<__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >,__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> > > m_base;
};
#ifdef __LHCb__OTLiteTime
#undef __LHCb__OTLiteTime
#endif
class __LHCb__OTLiteTime {
  public:
  __LHCb__OTLiteTime();
  ::LHCb::OTChannelID m_channelid;
  double m_calibratedTime;
};
#ifdef __std__vector_LHCb__OTLiteTime_
#undef __std__vector_LHCb__OTLiteTime_
#endif
class __std__vector_LHCb__OTLiteTime_ : protected ::std::_Vector_base<LHCb::OTLiteTime,std::allocator<LHCb::OTLiteTime> > {
  public:
  __std__vector_LHCb__OTLiteTime_();
};
}


#endif // __CINT__
namespace {
//------Stub functions for class vector<const LHCb::Node*,std::allocator<const LHCb::Node*> > -------------------------------
static void constructor_4698( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const LHCb::Node*>();
  else ::new(mem) ::std::vector<const LHCb::Node*>();
}

static void constructor_4699( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const LHCb::Node*>(*(const ::std::allocator<const LHCb::Node*>*)arg[0]);
  else ::new(mem) ::std::vector<const LHCb::Node*>(*(const ::std::allocator<const LHCb::Node*>*)arg[0]);
}

static void constructor_4700( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const LHCb::Node*>(*(::size_t*)arg[0]);
  else ::new(mem) ::std::vector<const LHCb::Node*>(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const LHCb::Node*>(*(::size_t*)arg[0],
      *(const ::LHCb::Node* const*)arg[1]);
  else ::new(mem) ::std::vector<const LHCb::Node*>(*(::size_t*)arg[0],
      *(const ::LHCb::Node* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const LHCb::Node*>(*(::size_t*)arg[0],
      *(const ::LHCb::Node* const*)arg[1],
      *(const ::std::allocator<const LHCb::Node*>*)arg[2]);
  else ::new(mem) ::std::vector<const LHCb::Node*>(*(::size_t*)arg[0],
      *(const ::LHCb::Node* const*)arg[1],
      *(const ::std::allocator<const LHCb::Node*>*)arg[2]);
  }
}

static void constructor_4701( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const LHCb::Node*>(*(const ::std::vector<const LHCb::Node*>*)arg[0]);
  else ::new(mem) ::std::vector<const LHCb::Node*>(*(const ::std::vector<const LHCb::Node*>*)arg[0]);
}

static void destructor_4702(void*, void * o, const std::vector<void*>&, void *) {
  (((::std::vector<const LHCb::Node*>*)o)->::std::vector<const LHCb::Node*>::~vector)();
}
static  void operator_4703( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const LHCb::Node*>*)o)->operator=)(*(const ::std::vector<const LHCb::Node*>*)arg[0]);
  else   (((::std::vector<const LHCb::Node*>*)o)->operator=)(*(const ::std::vector<const LHCb::Node*>*)arg[0]);
}

static  void method_4704( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const LHCb::Node*>*)o)->assign)(*(::size_t*)arg[0],
    *(const ::LHCb::Node* const*)arg[1]);
}

static  void method_4705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const LHCb::Node**,std::vector<const LHCb::Node*> >)((((::std::vector<const LHCb::Node*>*)o)->begin)());
  else   (((::std::vector<const LHCb::Node*>*)o)->begin)();
}

static  void method_4706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >)((((const ::std::vector<const LHCb::Node*>*)o)->begin)());
  else   (((const ::std::vector<const LHCb::Node*>*)o)->begin)();
}

static  void method_4707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const LHCb::Node**,std::vector<const LHCb::Node*> >)((((::std::vector<const LHCb::Node*>*)o)->end)());
  else   (((::std::vector<const LHCb::Node*>*)o)->end)();
}

static  void method_4708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >)((((const ::std::vector<const LHCb::Node*>*)o)->end)());
  else   (((const ::std::vector<const LHCb::Node*>*)o)->end)();
}

static  void method_4713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<const LHCb::Node*>*)o)->size)());
  else   (((const ::std::vector<const LHCb::Node*>*)o)->size)();
}

static  void method_4714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<const LHCb::Node*>*)o)->max_size)());
  else   (((const ::std::vector<const LHCb::Node*>*)o)->max_size)();
}

static  void method_4715( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<const LHCb::Node*>*)o)->resize)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<const LHCb::Node*>*)o)->resize)(*(::size_t*)arg[0],
      (const ::LHCb::Node*)arg[1]);
  }
}

static  void method_4716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<const LHCb::Node*>*)o)->capacity)());
  else   (((const ::std::vector<const LHCb::Node*>*)o)->capacity)();
}

static  void method_4717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<const LHCb::Node*>*)o)->empty)());
  else   (((const ::std::vector<const LHCb::Node*>*)o)->empty)();
}

static  void method_4718( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const LHCb::Node*>*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void operator_4719( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const LHCb::Node*>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((::std::vector<const LHCb::Node*>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void operator_4720( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const LHCb::Node*>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((const ::std::vector<const LHCb::Node*>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_4722( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const LHCb::Node*>*)o)->at)(*(::size_t*)arg[0]);
  else   (((::std::vector<const LHCb::Node*>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_4723( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const LHCb::Node*>*)o)->at)(*(::size_t*)arg[0]);
  else   (((const ::std::vector<const LHCb::Node*>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_4724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const LHCb::Node*>*)o)->front)();
  else   (((::std::vector<const LHCb::Node*>*)o)->front)();
}

static  void method_4725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const LHCb::Node*>*)o)->front)();
  else   (((const ::std::vector<const LHCb::Node*>*)o)->front)();
}

static  void method_4726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const LHCb::Node*>*)o)->back)();
  else   (((::std::vector<const LHCb::Node*>*)o)->back)();
}

static  void method_4727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const LHCb::Node*>*)o)->back)();
  else   (((const ::std::vector<const LHCb::Node*>*)o)->back)();
}

static  void method_4728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<const LHCb::Node*>*)o)->data)());
  else   (((::std::vector<const LHCb::Node*>*)o)->data)();
}

static  void method_4729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<const LHCb::Node*>*)o)->data)());
  else   (((const ::std::vector<const LHCb::Node*>*)o)->data)();
}

static  void method_4730( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const LHCb::Node*>*)o)->push_back)(*(const ::LHCb::Node* const*)arg[0]);
}

static  void method_4731( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<const LHCb::Node*>*)o)->pop_back)();
}

static  void method_4732( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const LHCb::Node**,std::vector<const LHCb::Node*> >)((((::std::vector<const LHCb::Node*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const LHCb::Node**,std::vector<const LHCb::Node*> >*)arg[0],
    *(const ::LHCb::Node* const*)arg[1]));
  else   (((::std::vector<const LHCb::Node*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const LHCb::Node**,std::vector<const LHCb::Node*> >*)arg[0],
    *(const ::LHCb::Node* const*)arg[1]);
}

static  void method_4733( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const LHCb::Node*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const LHCb::Node**,std::vector<const LHCb::Node*> >*)arg[0],
    *(::size_t*)arg[1],
    *(const ::LHCb::Node* const*)arg[2]);
}

static  void method_4734( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const LHCb::Node**,std::vector<const LHCb::Node*> >)((((::std::vector<const LHCb::Node*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const LHCb::Node**,std::vector<const LHCb::Node*> >*)arg[0]));
  else   (((::std::vector<const LHCb::Node*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const LHCb::Node**,std::vector<const LHCb::Node*> >*)arg[0]);
}

static  void method_4735( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const LHCb::Node**,std::vector<const LHCb::Node*> >)((((::std::vector<const LHCb::Node*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const LHCb::Node**,std::vector<const LHCb::Node*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<const LHCb::Node**,std::vector<const LHCb::Node*> >*)arg[1]));
  else   (((::std::vector<const LHCb::Node*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const LHCb::Node**,std::vector<const LHCb::Node*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<const LHCb::Node**,std::vector<const LHCb::Node*> >*)arg[1]);
}

static  void method_4736( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const LHCb::Node*>*)o)->swap)(*(::std::vector<const LHCb::Node*>*)arg[0]);
}

static  void method_4737( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<const LHCb::Node*>*)o)->clear)();
}

static void method_newdel_2052( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<const LHCb::Node*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<const LHCb::Node*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<const LHCb::Node*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<const LHCb::Node*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<const LHCb::Node*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder("std::_Vector_base<const LHCb::Node*,std::allocator<const LHCb::Node*> >"), ::Reflex::BaseOffset< ::std::vector<const LHCb::Node*>,::std::_Vector_base<const LHCb::Node*,std::allocator<const LHCb::Node*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x2( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<const LHCb::Node*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<const LHCb::Node*> >::Generate();
}

//------Dictionary for class vector<const LHCb::Node*,std::allocator<const LHCb::Node*> > -------------------------------
void __std__vector_constsLHCb__Nodep__db_datamem(Reflex::Class*);
void __std__vector_constsLHCb__Nodep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_constsLHCb__Nodep__datamem_bld(&__std__vector_constsLHCb__Nodep__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_constsLHCb__Nodep__funcmem_bld(&__std__vector_constsLHCb__Nodep__db_funcmem);
void __std__vector_constsLHCb__Nodep__dict() {
  ::Reflex::ClassBuilder("std::vector<const LHCb::Node*>", typeid(::std::vector<const LHCb::Node*>), sizeof(::std::vector<const LHCb::Node*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2006, ::Reflex::BaseOffset< ::std::vector<const LHCb::Node*>, ::std::_Vector_base<const LHCb::Node*,std::allocator<const LHCb::Node*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4530, "std::vector<const LHCb::Node*>::_Alloc_value_type")
  .AddTypedef(type_2006, "std::vector<const LHCb::Node*>::_Base")
  .AddTypedef(type_2387, "std::vector<const LHCb::Node*>::_Tp_alloc_type")
  .AddTypedef(type_4530, "std::vector<const LHCb::Node*>::value_type")
  .AddTypedef(type_4685, "std::vector<const LHCb::Node*>::pointer")
  .AddTypedef(type_4533, "std::vector<const LHCb::Node*>::const_pointer")
  .AddTypedef(type_4688, "std::vector<const LHCb::Node*>::reference")
  .AddTypedef(type_4535, "std::vector<const LHCb::Node*>::const_reference")
  .AddTypedef(type_3448, "std::vector<const LHCb::Node*>::iterator")
  .AddTypedef(type_3447, "std::vector<const LHCb::Node*>::const_iterator")
  .AddTypedef(type_2460, "std::vector<const LHCb::Node*>::const_reverse_iterator")
  .AddTypedef(type_2461, "std::vector<const LHCb::Node*>::reverse_iterator")
  .AddTypedef(type_891, "std::vector<const LHCb::Node*>::size_type")
  .AddTypedef(type_536, "std::vector<const LHCb::Node*>::difference_type")
  .AddTypedef(type_2387, "std::vector<const LHCb::Node*>::allocator_type")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), "vector", constructor_4698, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10983), "vector", constructor_4699, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_891, type_4535, type_10983), "vector", constructor_4700, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11117), "vector", constructor_4701, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), "~vector", destructor_4702, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>("__getNewDelFunctions", method_newdel_2052, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>("__getBasesTable", method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>("createCollFuncTable", method_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_constsLHCb__Nodep__funcmem_bld);
}

//------Delayed data member builder for class vector<const LHCb::Node*,std::allocator<const LHCb::Node*> > -------------------
void __std__vector_constsLHCb__Nodep__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<const LHCb::Node*,std::allocator<const LHCb::Node*> > -------------------
void __std__vector_constsLHCb__Nodep__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11118, type_11117), "operator=", operator_4703, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_595, type_891, type_4535), "assign", method_4704, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3448), "begin", method_4705, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3447), "begin", method_4706, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3448), "end", method_4707, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3447), "end", method_4708, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_891), "size", method_4713, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_891), "max_size", method_4714, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_595, type_891, type_4530), "resize", method_4715, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_891), "capacity", method_4716, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), "empty", method_4717, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_595, type_891), "reserve", method_4718, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4688, type_891), "operator[]", operator_4719, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4535, type_891), "operator[]", operator_4720, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4688, type_891), "at", method_4722, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4535, type_891), "at", method_4723, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4688), "front", method_4724, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4535), "front", method_4725, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4688), "back", method_4726, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4535), "back", method_4727, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4685), "data", method_4728, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4533), "data", method_4729, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_595, type_4535), "push_back", method_4730, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_595), "pop_back", method_4731, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3448, type_3448, type_4535), "insert", method_4732, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_595, type_3448, type_891, type_4535), "insert", method_4733, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3448, type_3448), "erase", method_4734, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3448, type_3448, type_3448), "erase", method_4735, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_595, type_11118), "swap", method_4736, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_595), "clear", method_4737, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Range_<std::vector<const LHCb::Node*, std::allocator<const LHCb::Node*> > > -------------------------------
static  void operator_9244( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator=)(*(const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)arg[0]);
  else   (((::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator=)(*(const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)arg[0]);
}

static void constructor_9245( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Range_<std::vector<const LHCb::Node*> >(*(const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)arg[0]);
  else ::new(mem) ::Gaudi::Range_<std::vector<const LHCb::Node*> >(*(const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)arg[0]);
}

static void constructor_9246( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Range_<std::vector<const LHCb::Node*> >();
  else ::new(mem) ::Gaudi::Range_<std::vector<const LHCb::Node*> >();
}

static void constructor_9247( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Range_<std::vector<const LHCb::Node*> >(*(::__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >*)arg[0],
      *(::__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >*)arg[1]);
  else ::new(mem) ::Gaudi::Range_<std::vector<const LHCb::Node*> >(*(::__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >*)arg[0],
      *(::__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >*)arg[1]);
}

static void constructor_9248( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Range_<std::vector<const LHCb::Node*> >(*(const ::std::pair<__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >,__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> > >*)arg[0]);
  else ::new(mem) ::Gaudi::Range_<std::vector<const LHCb::Node*> >(*(const ::std::pair<__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >,__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> > >*)arg[0]);
}

static void constructor_9249( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Range_<std::vector<const LHCb::Node*> >(*(const ::std::vector<const LHCb::Node*>*)arg[0]);
  else ::new(mem) ::Gaudi::Range_<std::vector<const LHCb::Node*> >(*(const ::std::vector<const LHCb::Node*>*)arg[0]);
}

static void constructor_9250( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Gaudi::Range_<std::vector<const LHCb::Node*> >(*(::__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >*)arg[0]);
  else ::new(mem) ::Gaudi::Range_<std::vector<const LHCb::Node*> >(*(::__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >*)arg[0]);
}

static void destructor_9251(void*, void * o, const std::vector<void*>&, void *) {
  (((::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->::Gaudi::Range_<std::vector<const LHCb::Node*> >::~Range_)();
}
static  void method_9252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->empty)());
  else   (((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->empty)();
}

static  void method_9253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->size)());
  else   (((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->size)();
}

static  void method_9254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >)((((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->begin)());
  else   (((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->begin)();
}

static  void method_9255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >)((((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->end)());
  else   (((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->end)();
}

static  void method_9258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->front)();
  else   (((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->front)();
}

static  void method_9259( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->back)();
  else   (((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->back)();
}

static  void method_9260( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Gaudi::Range_<std::vector<const LHCb::Node*> >)((((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->slice)(*(long*)arg[0],
    *(long*)arg[1]));
  else   (((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->slice)(*(long*)arg[0],
    *(long*)arg[1]);
}

static  void operator_9261( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator())(*(const ::size_t*)arg[0]);
  else   (((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator())(*(const ::size_t*)arg[0]);
}

static  void operator_9262( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator[])(*(const long*)arg[0]);
  else   (((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator[])(*(const long*)arg[0]);
}

static  void method_9263( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->at)(*(const long*)arg[0]);
  else   (((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->at)(*(const long*)arg[0]);
}

static  void operator_9264( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator<)(*(const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)arg[0]));
  else   (((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator<)(*(const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)arg[0]);
}

static  void operator_9265( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator<)(*(const ::std::vector<const LHCb::Node*>*)arg[0]));
  else   (((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator<)(*(const ::std::vector<const LHCb::Node*>*)arg[0]);
}

static  void operator_9266( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator==)(*(const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)arg[0]));
  else   (((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator==)(*(const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)arg[0]);
}

static  void operator_9267( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator==)(*(const ::std::vector<const LHCb::Node*>*)arg[0]));
  else   (((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator==)(*(const ::std::vector<const LHCb::Node*>*)arg[0]);
}

static  void operator_9268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator!)());
  else   (((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator!)();
}

static  void converter_9269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator const std::pair<__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >,__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> > >&)();
  else   (((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->operator const std::pair<__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >,__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> > >&)();
}

static  void method_9270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->base)();
  else   (((const ::Gaudi::Range_<std::vector<const LHCb::Node*> >*)o)->base)();
}

static void method_newdel_3649( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Gaudi::Range_<std::vector<const LHCb::Node*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Gaudi::Range_<std::vector<const LHCb::Node*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Gaudi::Range_<std::vector<const LHCb::Node*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Gaudi::Range_<std::vector<const LHCb::Node*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Gaudi::Range_<std::vector<const LHCb::Node*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder("Gaudi::RangeBase_"), ::Reflex::BaseOffset< ::Gaudi::Range_<std::vector<const LHCb::Node*> >,::Gaudi::RangeBase_ >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Range_<std::vector<const LHCb::Node*, std::allocator<const LHCb::Node*> > > -------------------------------
void __Gaudi__Range__std__vector_constsLHCb__Nodep_s__db_datamem(Reflex::Class*);
void __Gaudi__Range__std__vector_constsLHCb__Nodep_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Gaudi__Range__std__vector_constsLHCb__Nodep_s__datamem_bld(&__Gaudi__Range__std__vector_constsLHCb__Nodep_s__db_datamem);
Reflex::GenreflexMemberBuilder __Gaudi__Range__std__vector_constsLHCb__Nodep_s__funcmem_bld(&__Gaudi__Range__std__vector_constsLHCb__Nodep_s__db_funcmem);
void __Gaudi__Range__std__vector_constsLHCb__Nodep_s__dict() {
  ::Reflex::ClassBuilder("Gaudi::Range_<std::vector<const LHCb::Node*> >", typeid(::Gaudi::Range_<std::vector<const LHCb::Node*> >), sizeof(::Gaudi::Range_<std::vector<const LHCb::Node*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3532, ::Reflex::BaseOffset< ::Gaudi::Range_<std::vector<const LHCb::Node*> >, ::Gaudi::RangeBase_ >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2331, "Gaudi::Range_<std::vector<const LHCb::Node*> >::Base")
  .AddTypedef(type_2052, "Gaudi::Range_<std::vector<const LHCb::Node*> >::Container")
  .AddTypedef(type_4530, "Gaudi::Range_<std::vector<const LHCb::Node*> >::value_type")
  .AddTypedef(type_3447, "Gaudi::Range_<std::vector<const LHCb::Node*> >::iterator")
  .AddTypedef(type_3447, "Gaudi::Range_<std::vector<const LHCb::Node*> >::const_iterator")
  .AddTypedef(type_2460, "Gaudi::Range_<std::vector<const LHCb::Node*> >::reverse_iterator")
  .AddTypedef(type_2460, "Gaudi::Range_<std::vector<const LHCb::Node*> >::const_reverse_iterator")
  .AddTypedef(type_4535, "Gaudi::Range_<std::vector<const LHCb::Node*> >::reference")
  .AddTypedef(type_4535, "Gaudi::Range_<std::vector<const LHCb::Node*> >::const_reference")
  .AddTypedef(type_2331, "Gaudi::Range_<std::vector<const LHCb::Node*> >::_Base")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11974, type_11975), "operator=", operator_9244, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11975), "Range_", constructor_9245, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), "Range_", constructor_9246, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3447, type_3447), "Range_", constructor_9247, 0, "ibegin;iend", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11461), "Range_", constructor_9248, 0, "base", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11117), "Range_", constructor_9249, 0, "cont", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3447), "Range_", constructor_9250, 0, "ibegin", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), "~Range_", destructor_9251, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>("__getNewDelFunctions", method_newdel_3649, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>("__getBasesTable", method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Gaudi__Range__std__vector_constsLHCb__Nodep_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Gaudi__Range__std__vector_constsLHCb__Nodep_s__funcmem_bld);
}

//------Delayed data member builder for class Range_<std::vector<const LHCb::Node*, std::allocator<const LHCb::Node*> > > -------------------
void __Gaudi__Range__std__vector_constsLHCb__Nodep_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2331, "m_base", OffsetOf(__shadow__::__Gaudi__Range__std__vector_constsLHCb__Nodep_s_, m_base), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Range_<std::vector<const LHCb::Node*, std::allocator<const LHCb::Node*> > > -------------------
void __Gaudi__Range__std__vector_constsLHCb__Nodep_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), "empty", method_9252, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_891), "size", method_9253, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3447), "begin", method_9254, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3447), "end", method_9255, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4535), "front", method_9258, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4535), "back", method_9259, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3649, type_139, type_139), "slice", method_9260, 0, "index1;index2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4535, type_891c), "operator()", operator_9261, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4535, type_139c), "operator[]", operator_9262, 0, "index", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4535, type_139c), "at", method_9263, 0, "index", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662, type_11975), "operator<", operator_9264, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662, type_11117), "operator<", operator_9265, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662, type_11975), "operator==", operator_9266, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662, type_11117), "operator==", operator_9267, 0, "right", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), "operator!", operator_9268, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11461), "operator const std::pair<__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> >,__gnu_cxx::__normal_iterator<const LHCb::Node* const*,std::vector<const LHCb::Node*> > >&", converter_9269, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11461), "base", method_9270, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class OTLiteTime -------------------------------
static void destructor_9429(void*, void * o, const std::vector<void*>&, void *) {
  (((::LHCb::OTLiteTime*)o)->::LHCb::OTLiteTime::~OTLiteTime)();
}
static  void operator_9430( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::LHCb::OTLiteTime*)o)->operator=)(*(const ::LHCb::OTLiteTime*)arg[0]);
  else   (((::LHCb::OTLiteTime*)o)->operator=)(*(const ::LHCb::OTLiteTime*)arg[0]);
}

static void constructor_9431( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHCb::OTLiteTime(*(const ::LHCb::OTLiteTime*)arg[0]);
  else ::new(mem) ::LHCb::OTLiteTime(*(const ::LHCb::OTLiteTime*)arg[0]);
}

static void constructor_9432( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHCb::OTLiteTime();
  else ::new(mem) ::LHCb::OTLiteTime();
}

static void constructor_9433( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHCb::OTLiteTime(*(::LHCb::OTChannelID*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::LHCb::OTLiteTime(*(::LHCb::OTChannelID*)arg[0],
      *(double*)arg[1]);
}

static  void method_9434( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::LHCb::OTLiteTime*)o)->channel)();
  else   (((const ::LHCb::OTLiteTime*)o)->channel)();
}

static  void method_9435( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::LHCb::OTLiteTime*)o)->calibratedTime)());
  else   (((const ::LHCb::OTLiteTime*)o)->calibratedTime)();
}

static  void method_9436( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::LHCb::OTLiteTime*)o)->fillStream)(*(::std::ostream*)arg[0]);
  else   (((const ::LHCb::OTLiteTime*)o)->fillStream)(*(::std::ostream*)arg[0]);
}

static void method_newdel_3723( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::LHCb::OTLiteTime >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::LHCb::OTLiteTime >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::LHCb::OTLiteTime >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::LHCb::OTLiteTime >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::LHCb::OTLiteTime >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class OTLiteTime -------------------------------
void __LHCb__OTLiteTime_db_datamem(Reflex::Class*);
void __LHCb__OTLiteTime_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __LHCb__OTLiteTime_datamem_bld(&__LHCb__OTLiteTime_db_datamem);
Reflex::GenreflexMemberBuilder __LHCb__OTLiteTime_funcmem_bld(&__LHCb__OTLiteTime_db_funcmem);
void __LHCb__OTLiteTime_dict() {
  ::Reflex::ClassBuilder("LHCb::OTLiteTime", typeid(::LHCb::OTLiteTime), sizeof(::LHCb::OTLiteTime), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2051, "LHCb::OTLiteTime::Vector")
  .AddTypedef(type_3650, "LHCb::OTLiteTime::Range")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), "~OTLiteTime", destructor_9429, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4624, type_4626), "operator=", operator_9430, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4626), "OTLiteTime", constructor_9431, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), "OTLiteTime", constructor_9432, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3730, type_1717), "OTLiteTime", constructor_9433, 0, "channelid;calibratedtime", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>("__getNewDelFunctions", method_newdel_3723, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__LHCb__OTLiteTime_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__LHCb__OTLiteTime_funcmem_bld);
}

//------Delayed data member builder for class OTLiteTime -------------------
void __LHCb__OTLiteTime_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3730, "m_channelid", OffsetOf(__shadow__::__LHCb__OTLiteTime, m_channelid), ::Reflex::PRIVATE)
  .AddDataMember(type_1717, "m_calibratedTime", OffsetOf(__shadow__::__LHCb__OTLiteTime, m_calibratedTime), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class OTLiteTime -------------------
void __LHCb__OTLiteTime_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9920), "channel", method_9434, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1717), "calibratedTime", method_9435, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3919, type_3919), "fillStream", method_9436, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<LHCb::OTLiteTime,std::allocator<LHCb::OTLiteTime> > -------------------------------
static void constructor_4635( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LHCb::OTLiteTime>();
  else ::new(mem) ::std::vector<LHCb::OTLiteTime>();
}

static void constructor_4636( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LHCb::OTLiteTime>(*(const ::std::allocator<LHCb::OTLiteTime>*)arg[0]);
  else ::new(mem) ::std::vector<LHCb::OTLiteTime>(*(const ::std::allocator<LHCb::OTLiteTime>*)arg[0]);
}

static void constructor_4637( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LHCb::OTLiteTime>(*(::size_t*)arg[0]);
  else ::new(mem) ::std::vector<LHCb::OTLiteTime>(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LHCb::OTLiteTime>(*(::size_t*)arg[0],
      *(const ::LHCb::OTLiteTime*)arg[1]);
  else ::new(mem) ::std::vector<LHCb::OTLiteTime>(*(::size_t*)arg[0],
      *(const ::LHCb::OTLiteTime*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LHCb::OTLiteTime>(*(::size_t*)arg[0],
      *(const ::LHCb::OTLiteTime*)arg[1],
      *(const ::std::allocator<LHCb::OTLiteTime>*)arg[2]);
  else ::new(mem) ::std::vector<LHCb::OTLiteTime>(*(::size_t*)arg[0],
      *(const ::LHCb::OTLiteTime*)arg[1],
      *(const ::std::allocator<LHCb::OTLiteTime>*)arg[2]);
  }
}

static void constructor_4638( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LHCb::OTLiteTime>(*(const ::std::vector<LHCb::OTLiteTime>*)arg[0]);
  else ::new(mem) ::std::vector<LHCb::OTLiteTime>(*(const ::std::vector<LHCb::OTLiteTime>*)arg[0]);
}

static void destructor_4639(void*, void * o, const std::vector<void*>&, void *) {
  (((::std::vector<LHCb::OTLiteTime>*)o)->::std::vector<LHCb::OTLiteTime>::~vector)();
}
static  void operator_4640( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<LHCb::OTLiteTime>*)o)->operator=)(*(const ::std::vector<LHCb::OTLiteTime>*)arg[0]);
  else   (((::std::vector<LHCb::OTLiteTime>*)o)->operator=)(*(const ::std::vector<LHCb::OTLiteTime>*)arg[0]);
}

static  void method_4641( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<LHCb::OTLiteTime>*)o)->assign)(*(::size_t*)arg[0],
    *(const ::LHCb::OTLiteTime*)arg[1]);
}

static  void method_4642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >)((((::std::vector<LHCb::OTLiteTime>*)o)->begin)());
  else   (((::std::vector<LHCb::OTLiteTime>*)o)->begin)();
}

static  void method_4643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >)((((const ::std::vector<LHCb::OTLiteTime>*)o)->begin)());
  else   (((const ::std::vector<LHCb::OTLiteTime>*)o)->begin)();
}

static  void method_4644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >)((((::std::vector<LHCb::OTLiteTime>*)o)->end)());
  else   (((::std::vector<LHCb::OTLiteTime>*)o)->end)();
}

static  void method_4645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >)((((const ::std::vector<LHCb::OTLiteTime>*)o)->end)());
  else   (((const ::std::vector<LHCb::OTLiteTime>*)o)->end)();
}

static  void method_4650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<LHCb::OTLiteTime>*)o)->size)());
  else   (((const ::std::vector<LHCb::OTLiteTime>*)o)->size)();
}

static  void method_4651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<LHCb::OTLiteTime>*)o)->max_size)());
  else   (((const ::std::vector<LHCb::OTLiteTime>*)o)->max_size)();
}

static  void method_4652( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<LHCb::OTLiteTime>*)o)->resize)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<LHCb::OTLiteTime>*)o)->resize)(*(::size_t*)arg[0],
      *(::LHCb::OTLiteTime*)arg[1]);
  }
}

static  void method_4653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::std::vector<LHCb::OTLiteTime>*)o)->capacity)());
  else   (((const ::std::vector<LHCb::OTLiteTime>*)o)->capacity)();
}

static  void method_4654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<LHCb::OTLiteTime>*)o)->empty)());
  else   (((const ::std::vector<LHCb::OTLiteTime>*)o)->empty)();
}

static  void method_4655( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<LHCb::OTLiteTime>*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void operator_4656( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<LHCb::OTLiteTime>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((::std::vector<LHCb::OTLiteTime>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void operator_4657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<LHCb::OTLiteTime>*)o)->operator[])(*(::size_t*)arg[0]);
  else   (((const ::std::vector<LHCb::OTLiteTime>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_4659( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<LHCb::OTLiteTime>*)o)->at)(*(::size_t*)arg[0]);
  else   (((::std::vector<LHCb::OTLiteTime>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_4660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<LHCb::OTLiteTime>*)o)->at)(*(::size_t*)arg[0]);
  else   (((const ::std::vector<LHCb::OTLiteTime>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_4661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<LHCb::OTLiteTime>*)o)->front)();
  else   (((::std::vector<LHCb::OTLiteTime>*)o)->front)();
}

static  void method_4662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<LHCb::OTLiteTime>*)o)->front)();
  else   (((const ::std::vector<LHCb::OTLiteTime>*)o)->front)();
}

static  void method_4663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<LHCb::OTLiteTime>*)o)->back)();
  else   (((::std::vector<LHCb::OTLiteTime>*)o)->back)();
}

static  void method_4664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<LHCb::OTLiteTime>*)o)->back)();
  else   (((const ::std::vector<LHCb::OTLiteTime>*)o)->back)();
}

static  void method_4665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<LHCb::OTLiteTime>*)o)->data)());
  else   (((::std::vector<LHCb::OTLiteTime>*)o)->data)();
}

static  void method_4666( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<LHCb::OTLiteTime>*)o)->data)());
  else   (((const ::std::vector<LHCb::OTLiteTime>*)o)->data)();
}

static  void method_4667( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<LHCb::OTLiteTime>*)o)->push_back)(*(const ::LHCb::OTLiteTime*)arg[0]);
}

static  void method_4668( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<LHCb::OTLiteTime>*)o)->pop_back)();
}

static  void method_4669( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >)((((::std::vector<LHCb::OTLiteTime>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >*)arg[0],
    *(const ::LHCb::OTLiteTime*)arg[1]));
  else   (((::std::vector<LHCb::OTLiteTime>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >*)arg[0],
    *(const ::LHCb::OTLiteTime*)arg[1]);
}

static  void method_4670( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<LHCb::OTLiteTime>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >*)arg[0],
    *(::size_t*)arg[1],
    *(const ::LHCb::OTLiteTime*)arg[2]);
}

static  void method_4671( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >)((((::std::vector<LHCb::OTLiteTime>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >*)arg[0]));
  else   (((::std::vector<LHCb::OTLiteTime>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >*)arg[0]);
}

static  void method_4672( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >)((((::std::vector<LHCb::OTLiteTime>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >*)arg[1]));
  else   (((::std::vector<LHCb::OTLiteTime>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<LHCb::OTLiteTime*,std::vector<LHCb::OTLiteTime> >*)arg[1]);
}

static  void method_4673( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<LHCb::OTLiteTime>*)o)->swap)(*(::std::vector<LHCb::OTLiteTime>*)arg[0]);
}

static  void method_4674( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<LHCb::OTLiteTime>*)o)->clear)();
}

static void method_newdel_2051( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<LHCb::OTLiteTime> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<LHCb::OTLiteTime> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<LHCb::OTLiteTime> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<LHCb::OTLiteTime> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<LHCb::OTLiteTime> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder("std::_Vector_base<LHCb::OTLiteTime,std::allocator<LHCb::OTLiteTime> >"), ::Reflex::BaseOffset< ::std::vector<LHCb::OTLiteTime>,::std::_Vector_base<LHCb::OTLiteTime,std::allocator<LHCb::OTLiteTime> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<LHCb::OTLiteTime> >::Generate();
  else ::Reflex::Proxy< ::std::vector<LHCb::OTLiteTime> >::Generate();
}

//------Dictionary for class vector<LHCb::OTLiteTime,std::allocator<LHCb::OTLiteTime> > -------------------------------
void __std__vector_LHCb__OTLiteTime__db_datamem(Reflex::Class*);
void __std__vector_LHCb__OTLiteTime__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_LHCb__OTLiteTime__datamem_bld(&__std__vector_LHCb__OTLiteTime__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_LHCb__OTLiteTime__funcmem_bld(&__std__vector_LHCb__OTLiteTime__db_funcmem);
void __std__vector_LHCb__OTLiteTime__dict() {
  ::Reflex::ClassBuilder("std::vector<LHCb::OTLiteTime>", typeid(::std::vector<LHCb::OTLiteTime>), sizeof(::std::vector<LHCb::OTLiteTime>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2005, ::Reflex::BaseOffset< ::std::vector<LHCb::OTLiteTime>, ::std::_Vector_base<LHCb::OTLiteTime,std::allocator<LHCb::OTLiteTime> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3723, "std::vector<LHCb::OTLiteTime>::_Alloc_value_type")
  .AddTypedef(type_2005, "std::vector<LHCb::OTLiteTime>::_Base")
  .AddTypedef(type_2386, "std::vector<LHCb::OTLiteTime>::_Tp_alloc_type")
  .AddTypedef(type_3723, "std::vector<LHCb::OTLiteTime>::value_type")
  .AddTypedef(type_4620, "std::vector<LHCb::OTLiteTime>::pointer")
  .AddTypedef(type_4622, "std::vector<LHCb::OTLiteTime>::const_pointer")
  .AddTypedef(type_4624, "std::vector<LHCb::OTLiteTime>::reference")
  .AddTypedef(type_4626, "std::vector<LHCb::OTLiteTime>::const_reference")
  .AddTypedef(type_3445, "std::vector<LHCb::OTLiteTime>::iterator")
  .AddTypedef(type_3446, "std::vector<LHCb::OTLiteTime>::const_iterator")
  .AddTypedef(type_2458, "std::vector<LHCb::OTLiteTime>::const_reverse_iterator")
  .AddTypedef(type_2459, "std::vector<LHCb::OTLiteTime>::reverse_iterator")
  .AddTypedef(type_891, "std::vector<LHCb::OTLiteTime>::size_type")
  .AddTypedef(type_536, "std::vector<LHCb::OTLiteTime>::difference_type")
  .AddTypedef(type_2386, "std::vector<LHCb::OTLiteTime>::allocator_type")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), "vector", constructor_4635, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10971), "vector", constructor_4636, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_891, type_4626, type_10971), "vector", constructor_4637, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11115), "vector", constructor_4638, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), "~vector", destructor_4639, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>("__getNewDelFunctions", method_newdel_2051, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>("__getBasesTable", method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>("createCollFuncTable", method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_LHCb__OTLiteTime__funcmem_bld);
}

//------Delayed data member builder for class vector<LHCb::OTLiteTime,std::allocator<LHCb::OTLiteTime> > -------------------
void __std__vector_LHCb__OTLiteTime__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<LHCb::OTLiteTime,std::allocator<LHCb::OTLiteTime> > -------------------
void __std__vector_LHCb__OTLiteTime__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11116, type_11115), "operator=", operator_4640, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_595, type_891, type_4626), "assign", method_4641, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3445), "begin", method_4642, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3446), "begin", method_4643, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3445), "end", method_4644, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3446), "end", method_4645, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_891), "size", method_4650, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_891), "max_size", method_4651, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_595, type_891, type_3723), "resize", method_4652, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_891), "capacity", method_4653, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), "empty", method_4654, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_595, type_891), "reserve", method_4655, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4624, type_891), "operator[]", operator_4656, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4626, type_891), "operator[]", operator_4657, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4624, type_891), "at", method_4659, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4626, type_891), "at", method_4660, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4624), "front", method_4661, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4626), "front", method_4662, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4624), "back", method_4663, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4626), "back", method_4664, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4620), "data", method_4665, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4622), "data", method_4666, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_595, type_4626), "push_back", method_4667, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_595), "pop_back", method_4668, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3445, type_3445, type_4626), "insert", method_4669, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_595, type_3445, type_891, type_4626), "insert", method_4670, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3445, type_3445), "erase", method_4671, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3445, type_3445, type_3445), "erase", method_4672, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_595, type_11116), "swap", method_4673, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_595), "clear", method_4674, 0, 0, ::Reflex::PUBLIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __std__vector_constsLHCb__Nodep__dict(); 
      __Gaudi__Range__std__vector_constsLHCb__Nodep_s__dict(); 
      __LHCb__OTLiteTime_dict(); 
      __std__vector_LHCb__OTLiteTime__dict(); 
    }
    ~Dictionaries() {
      type_2052.Unload(); // class std::vector<const LHCb::Node*> 
      type_3649.Unload(); // class Gaudi::Range_<std::vector<const LHCb::Node*> > 
      type_3723.Unload(); // class LHCb::OTLiteTime 
      type_2051.Unload(); // class std::vector<LHCb::OTLiteTime> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
