<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE gdd SYSTEM 'gdd.dtd'>
<gdd>
  <package name='TrackFitEvent'>

<!-- ================== FitTrack class definition =================== -->

    <class
      name             = 'FitTrack'
      author           = 'Jose Hernando, Eduardo Rodrigues'
      desc             = 'FitTrack is the class for tracking software.'
      id               = '10020'
      location         = 'Rec/FitTrack/Best'
      keyedContTypeDef = 'TRUE'
      serializers      = 'FALSE'>

      <location name="Velo"    place="Rec/FitTrack/Velo"/>
      <location name="Seed"    place="Rec/FitTrack/Seed"/>
      <location name="Match"   place="Rec/FitTrack/Match"/>
      <location name="Forward" place="Rec/FitTrack/Forward"/>
      <location name="Follow"  place="Rec/FitTrack/Follow"/>
      <location name="VeloTT"  place="Rec/FitTrack/VeloTT"/>
      <location name="KsTrack" place="Rec/FitTrack/KsTrack"/>

      <base name='Track' />
      &KeyedObject;

      <import name='Event/Track' />
      <import name='Event/Node' />
      <import name='Event/Measurement' />

      <enum
        name    = 'TrackType'
        value   = 'Velo=1,VeloR=2,Backward=4,Long=8,Upstream=16,Downstream=32,Ttrack=64'
        desc    = 'enumeration for the track type'
        access  = 'PUBLIC' />

      <enum
        name    = 'HistoryFlag'
        value   = 'LongTrack=1,Seeding=2,TrKshort=4,TrMatching=8,VeloTrack=16,VeloTT=32,TrgForward=64,TrgVelo=128,TrgVeloTT=256'
        desc    = 'enumeration for the track history'
        access  = 'PUBLIC' />

      <enum
        name    = 'Flag'
        value   = 'Valid=1,Unique=2,IPSelected=4,MuSelected=8'
        desc    = 'enumeration for the track flags'
        access  = 'PUBLIC' />

      <attribute
        type      = 'std::vector&lt;Node*&gt;'
        name      = 'nodes'
        desc      = 'container of Nodes'
        access    = 'PROTECTED'
        serialize = 'FALSE' />

      <attribute
        type      = 'std::vector&lt;Measurement*&gt;'
        name      = 'measurements'
        desc      = 'container of Measurements'
        access    = 'PROTECTED'
        serialize = 'FALSE' />

      <method
        type    = 'unsigned int'
        name    = 'nMeasurements'
        const   = 'TRUE'
        desc    = 'number of measurements on track'>
        <code>
  return m_measurements.size();
        </code>
      </method>

      <method
        name    = 'addToMeasurements'
        argList = 'Measurement* meas'
        desc    = 'add a measurement to the list associated to the track'>
        <code>
  m_measurements.push_back( meas );
        </code>
      </method>

      <method
        name = 'sortMeasurements'
        desc = 'sort the measurements by increasing z' />

      <method
        type    = 'State &amp;'
        name    = 'closestState'
        argList = 'double z'
        desc    = 'Retrieve the reference to the state closest to the given z-position'
        virtual = 'TRUE' />

      <method
        type    = 'const State &amp;'
        name    = 'closestState'
        argList = 'double z'
        desc    = 'Retrieve the reference to the state closest to the given z-position'
        const   = 'TRUE'
        virtual = 'TRUE' />

      <method
        type    = 'State &amp;'
        name    = 'closestState'
        argList = 'const HepPlane3D plane'
        desc    = 'Retrieve the reference to the state closest to the given plane'
        virtual = 'TRUE'>
      </method>

      <method
        type    = 'const State &amp;'
        name    = 'closestState'
        argList = 'const HepPlane3D plane'
        desc    = 'Retrieve the reference to the state closest to the given plane'
        const   = 'TRUE'
        virtual = 'TRUE'>
      </method>

      <method
        type    = 'bool'
        name    = 'hasStateAt'
        argList = 'const State::Location value'
        desc    = 'check the existence of a state at a certain predefined location. See State class.'
        const   = 'TRUE'
        virtual = 'FALSE' />

      <method
        type    = 'State*'
        name    = 'stateAt'
        argList = 'const State::Location value'
        desc    = 'Retrieve the pointer to the state at a certain predefined location. See State class.'
        virtual = 'TRUE' />

      <method
        type    = 'const State*'
        name    = 'stateAt'
        argList = 'const State::Location value'
        desc    = 'Retrieve the pointer to the state at a certain predefined location. See State class.'
        const   = 'TRUE'
        virtual = 'TRUE' />

      <method
        type    = 'void'
        name    = 'reset'
        desc    = 'Clear the fit track before re-use'
        virtual = 'TRUE'>
        <code>
  m_chi2PerDoF   = 0;
  m_nDoF         = 0;
  m_flags        = 0;
  m_physicsState.reset();
  m_states.clear();
  m_lhcbIDs.clear();
  m_nodes.clear();
  m_measurements.clear();
        </code>
      </method>

      <method
        type    = 'FitTrack*'
        name    = 'clone'
        desc    = 'Clone the fit track'
        virtual = 'TRUE'
        const   = 'TRUE' />

      <method
        type    = 'bool'
        name    = 'producedByAlgo'
        argList = 'HistoryFlag value'
        desc    = 'Check whether the fit track was produced by a given algorithm'
        const   = 'TRUE'
        virtual = 'TRUE' />

      <method
        name    = 'setProducedByAlgo'
        argList = 'HistoryFlag value'
        desc    = 'Update the name of the algorithm that produced the fit track'
        virtual = 'TRUE' />

    </class>

  </package>
</gdd>
