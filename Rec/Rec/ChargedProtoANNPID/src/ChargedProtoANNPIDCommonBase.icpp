
// local
#include "ChargedProtoANNPIDCommonBase.h"

// Boost
#include "boost/assign/list_of.hpp"

//=============================================================================
// Constructor initialisation
//=============================================================================
template <class PBASE>
void ANNGlobalPID::ChargedProtoANNPIDCommonBase<PBASE>::initCommonConstructor()
{
  // initalise data members
  m_summary = NULL;
  // Job Options
  this->declareProperty( "ProtoParticleLocation",
                         m_protoPath = LHCb::ProtoParticleLocation::Charged );
}

//=============================================================================
// Destructor
//=============================================================================
template <class PBASE>
ANNGlobalPID::ChargedProtoANNPIDCommonBase<PBASE>::~ChargedProtoANNPIDCommonBase() {}

//=============================================================================
// Initialisation
//=============================================================================
template <class PBASE>
StatusCode ANNGlobalPID::ChargedProtoANNPIDCommonBase<PBASE>::initialize()
{
  // Execute the base class initialize
  StatusCode sc = PBASE::initialize();
  if ( sc.isFailure() )
  {
    return this -> Error( "Failed to initialise Gaudi Base class", sc );
  }

  // Printout from initialize
  if ( this -> msgLevel(MSG::DEBUG) )
  {
    this -> debug() << "Initialize" << endmsg;
  }

  // Setup incident services
  IIncidentSvc * incSvc =
    this -> template svc<IIncidentSvc>( "IncidentSvc", true );
  incSvc->addListener( this, IncidentType::EndEvent );
  sc = sc && this -> releaseSvc(incSvc);

  return sc;
}
//=============================================================================

//=============================================================================
// Incident handle
//=============================================================================
template <class PBASE>
void
ANNGlobalPID::ChargedProtoANNPIDCommonBase<PBASE>::handle ( const Incident& )
{
  m_summary = NULL;
}
//=============================================================================

//=============================================================================
// Finalisation
//=============================================================================
template <class PBASE>
StatusCode ANNGlobalPID::ChargedProtoANNPIDCommonBase<PBASE>::finalize()
{
  // Printout from finalization
  if ( this -> msgLevel(MSG::DEBUG) )
  {
    this -> debug() << "Finalize" << endmsg;
  }

  // Finalise base class and return
  return PBASE::finalize();
}
//=============================================================================

//=============================================================================
// Access the RecSummary
//=============================================================================
template <class PBASE>
const LHCb::RecSummary *
ANNGlobalPID::ChargedProtoANNPIDCommonBase<PBASE>::recSummary() const
{
  if ( !m_summary )
  {
    m_summary =
      this -> template getIfExists<LHCb::RecSummary>( LHCb::RecSummaryLocation::Default, false );
    if ( !m_summary )
    {
      m_summary =
        this -> template get<LHCb::RecSummary>( LHCb::RecSummaryLocation::Default, true );
    }
  }
  return m_summary;
}
//=============================================================================

//=============================================================================
template <class PBASE>
typename ANNGlobalPID::ChargedProtoANNPIDCommonBase<PBASE>::Input::ConstVector 
ANNGlobalPID::
ChargedProtoANNPIDCommonBase<PBASE>::getInputs( const StringInputs& names ) const
{
  typename Input::ConstVector inputs;
  inputs.reserve(names.size());
  for ( StringInputs::const_iterator i = names.begin(); i != names.end(); ++i )
  {
    inputs.push_back( getInput(*i) );
  }
  return inputs;
}
//=============================================================================

//=============================================================================
template <class PBASE>
const typename ANNGlobalPID::ChargedProtoANNPIDCommonBase<PBASE>::Input *
ANNGlobalPID::
ChargedProtoANNPIDCommonBase<PBASE>::getInput( const std::string& name ) const
{
  Input * input = NULL;

  // Tracking variables
  if      ( "TrackP"                == name ) { input = new InTrackP(); }
  else if ( "TrackPt"               == name ) { input = new InTrackPt(); }
  else if ( "TrackLikelihood"       == name ) { input = new InTrackLikelihood(); }
  else if ( "TrackGhostProbability" == name ) { input = new InTrackGhostProb(); }
  else if ( "TrackCloneDist"        == name ) { input = new InTrackCloneDist(); }
  else if ( "TrackFitMatchChi2"     == name ) { input = new InTrackExInfo(LHCb::Track::FitMatchChi2); }
  else if ( "TrackFitVeloChi2"      == name ) { input = new InTrackExInfo(LHCb::Track::FitVeloChi2); }
  else if ( "TrackFitVeloNDoF"      == name ) { input = new InTrackExInfo(LHCb::Track::FitVeloNDoF); }
  else if ( "TrackFitTChi2"         == name ) { input = new InTrackExInfo(LHCb::Track::FitTChi2); }
  else if ( "TrackFitTNDoF"         == name ) { input = new InTrackExInfo(LHCb::Track::FitTNDoF); }
  else if ( "TrackMatchChi2"        == name ) { input = new InTrackExInfo(LHCb::Track::MatchChi2); }
  else if ( "TrackDOCA"             == name ) { input = new InTrackDOCA(); }

  // Rich Variables
  else if ( "RichUsedAero"     == name ) { input = new InRichUsedAerogel(); }
  else if ( "RichUsedR1Gas"    == name ) { input = new InRichUsedR1Gas(); }  
  else if ( "RichUsedR2Gas"    == name ) { input = new InRichUsedR2Gas(); }
  else if ( "RichAboveElThres" == name ) { input = new InRichAboveElThres(); }
  else if ( "RichAboveMuThres" == name ) { input = new InRichAboveMuThres(); }
  else if ( "RichAbovePiThres" == name ) { input = new InRichAbovePiThres(); }
  else if ( "RichAboveKaThres" == name ) { input = new InRichAboveKaThres(); }
  else if ( "RichAbovePrThres" == name ) { input = new InRichAbovePrThres(); }
  else if ( "RichDLLe"         == name ) { input = new InRichDLL(Rich::Electron); }
  else if ( "RichDLLmu"        == name ) { input = new InRichDLL(Rich::Muon); }
  else if ( "RichDLLpi"        == name ) { input = new InRichDLL(Rich::Pion); }
  else if ( "RichDLLk"         == name ) { input = new InRichDLL(Rich::Kaon); }
  else if ( "RichDLLp"         == name ) { input = new InRichDLL(Rich::Proton); }
  else if ( "RichDLLbt"        == name ) { input = new InRichDLL(Rich::BelowThreshold); }

  // Muon variables
  else if ( "MuonIsLooseMuon" == name ) { input = new InMuonIsMuonLoose(); }
  else if ( "MuonIsMuon"      == name ) { input = new InMuonIsMuon(); }
  else if ( "MuonNShared"     == name ) { input = new InMuonNShared(); }
  else if ( "MuonMuLL"        == name ) { input = new InMuonLLMu(); }
  else if ( "MuonBkgLL"       == name ) { input = new InMuonLLBkg(); }

  // GEC Variables
  else if ( "NumProtoParticles"   == name ) { input = new InNumProtos(); }
  else if ( "NumCaloHypos"        == name ) { input = new InNumCaloHypos(); }
  else if ( "NumLongTracks"       == name ) { input = new InRecSummary(LHCb::RecSummary::nLongTracks,this); }
  else if ( "NumDownstreamTracks" == name ) { input = new InRecSummary(LHCb::RecSummary::nDownstreamTracks,this); }
  else if ( "NumUpstreamTracks"   == name ) { input = new InRecSummary(LHCb::RecSummary::nUpstreamTracks,this); }
  else if ( "NumVeloTracks"       == name ) { input = new InRecSummary(LHCb::RecSummary::nVeloTracks,this); }
  else if ( "NumTTracks"          == name ) { input = new InRecSummary(LHCb::RecSummary::nTTracks,this); }
  else if ( "NumPVs"              == name ) { input = new InRecSummary(LHCb::RecSummary::nPVs,this); }
  else if ( "NumSPDHits"          == name ) { input = new InRecSummary(LHCb::RecSummary::nSPDhits,this); }
  else if ( "NumRich1Hits"        == name ) { input = new InRecSummary(LHCb::RecSummary::nRich1Hits,this); }
  else if ( "NumRich2Hits"        == name ) { input = new InRecSummary(LHCb::RecSummary::nRich2Hits,this); }
  else if ( "NumMuonTracks"       == name ) { input = new InRecSummary(LHCb::RecSummary::nMuonTracks,this); }

  // Proto Extra Info variables with specific default requirements, not -999
  else if ( "InAccMuon"    == name ) { input = new InProtoExInfo( LHCb::ProtoParticle::InAccMuon, 0 ); }
  else if ( "InAccEcal"    == name ) { input = new InProtoExInfo( LHCb::ProtoParticle::InAccEcal, 0 ); }
  else if ( "InAccHcal"    == name ) { input = new InProtoExInfo( LHCb::ProtoParticle::InAccHcal, 0 ); }
  else if ( "InAccPrs"     == name ) { input = new InProtoExInfo( LHCb::ProtoParticle::InAccPrs,  0 ); }
  else if ( "InAccSpd"     == name ) { input = new InProtoExInfo( LHCb::ProtoParticle::InAccSpd,  0 ); }
  else if ( "InAccBrem"    == name ) { input = new InProtoExInfo( LHCb::ProtoParticle::InAccBrem, 0 ); }
  else if ( "CaloEcalChi2" == name ) { input = new InCaloEcalChi2(); }
  else if ( "CaloBremChi2" == name ) { input = new InCaloBremChi2(); }
  else if ( "CaloClusChi2" == name ) { input = new InCaloClusChi2(); }

  // Generic ProtoParticle Extra Info
  else { input = new InProtoExInfo( LHCb::ProtoParticle::convertExtraInfo(name) ); }

  if ( !input )
  {
    this->Exception( "Failed to create input object for '" + name + "'" );
  }

  return input;
}
//=============================================================================
