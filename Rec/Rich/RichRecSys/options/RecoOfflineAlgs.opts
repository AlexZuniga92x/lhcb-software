
// ============================================================================
// Define the algorithms to run and in which order
// Run the offline quality algorithms on offline tracks
// ============================================================================

// Set offline mode
RecoRICHSeq.Context = "Offline";

//-----------------------------------------------------------------------------
// Uncomment these to make sure data (tracks and raw event) are in memory
// Useful for timing studies
//-----------------------------------------------------------------------------
//RecoRICHSeq.Members += { "Rich::DAQ::LoadRawEvent/LoadRawRichEvent",
//                         "Rich::Rec::Initialise/LoadRawTracks" };
//LoadRawTracks.CheckProcStatus = false;
//LoadRawTracks.CreatePixels    = false;
//LoadRawTracks.CreateTracks    = false;
//LoadRawTracks.CreatePhotons   = false;
//LoadRawTracks.LoadRawTracks   = true;

//-----------------------------------------------------------------------------
// Initialisation (Technically not needed, but useful for timing studies)
//-----------------------------------------------------------------------------
RecoRICHSeq.Members += { "GaudiSequencer/RichRecInitOfflineSeq" };
RichRecInitOfflineSeq.MeasureTime = true;

RichRecInitOfflineSeq.Members += { "Rich::Rec::Initialise/CheckProcOfflineStatus" };

RichRecInitOfflineSeq.Members += { "GaudiSequencer/RichOfflinePixelsSeq" };
RichOfflinePixelsSeq.MeasureTime      = true;
RichOfflinePixelsSeq.Members += { "Rich::DAQ::RawBufferToRichDigitsAlg/DecodeRawRichOffline" };
DecodeRawRichOffline.DecodeBufferOnly = true;
RichOfflinePixelsSeq.Members += { "Rich::Rec::Initialise/CreateOfflinePixels" };
CreateOfflinePixels.CheckProcStatus   = false;
CreateOfflinePixels.CreatePixels      = true;

RichRecInitOfflineSeq.Members += { "GaudiSequencer/RichOfflineTracksSeq" };
RichOfflineTracksSeq.MeasureTime     = true;
RichOfflineTracksSeq.Members += { "Rich::Rec::Initialise/CreateOfflineTracks" };
CreateOfflineTracks.CheckProcStatus  = false;
CreateOfflineTracks.CreateTracks     = true;

RichRecInitOfflineSeq.Members += { "GaudiSequencer/RichOfflinePhotonsSeq" };
RichOfflinePhotonsSeq.MeasureTime    = true;
RichOfflinePhotonsSeq.Members += { "Rich::Rec::Initialise/CreateOfflinePhotons" };
CreateOfflinePhotons.CheckProcStatus = false;
CreateOfflinePhotons.CreatePhotons   = true;
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// General PID sequence
//-----------------------------------------------------------------------------

RecoRICHSeq.Members += { "GaudiSequencer/RichOfflinePIDSeq" };
RichOfflinePIDSeq.MeasureTime   = true;

//-----------------------------------------------------------------------------
// Local PID algorithm
//-----------------------------------------------------------------------------
//RecoRICHSeq.Members += { "GaudiSequencer/RichLocalPIDSeq" };
//RichLocalPIDSeq.MeasureTime   = true;
//RichLocalPIDSeq.Members += { "Rich::Rec::LocalPID::PIDAlg/RichLocPID" };
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Global PID algorithm
//-----------------------------------------------------------------------------
RichOfflinePIDSeq.Members += { "GaudiSequencer/RichOfflineGPIDSeq" };
RichGPIDSeq.MeasureTime   = true;

// Initialise Global PID algorithm for each event
RichOfflineGPIDSeq.Members += { "GaudiSequencer/RichOfflineGPIDInitSeq" };
RichOfflineGPIDInitSeq.MeasureTime   = true;
RichOfflineGPIDInitSeq.Members += { "Rich::Rec::GlobalPID::Initialize/RichOfflineGPIDInit",
                                         "Rich::Rec::GlobalPID::DigitSel/RichOfflineGPIDDigSel",
                                         "Rich::Rec::GlobalPID::TrackSel/RichOfflineGPIDTrSel" };
// Likelihood
RichOfflineGPIDSeq.Members += { "GaudiSequencer/RichOfflineGPIDLLSeq" };
RichOfflineGPIDLLSeq.MeasureTime   = true;

// First iteration of background estimation then Global PID iteration
RichOfflineGPIDLLSeq.Members += {
  "Rich::Rec::PixelBackgroundAlg/RichOfflineBckEstIt0",
  "Rich::Rec::GlobalPID::Likelihood/RichOfflineGPIDLLIt0"
};

// Second iteration of background estimation then Global PID iteration
RichOfflineGPIDLLSeq.Members += {
  "Rich::Rec::PixelBackgroundAlg/RichOfflineBckEstIt1",
  "Rich::Rec::GlobalPID::Likelihood/RichOfflineGPIDLLIt1"
};

// Finalise Global PID algorithm each event
RichOfflineGPIDSeq.Members += { "Rich::Rec::GlobalPID::Finalize/RichOfflineGPIDFin" };

//-----------------------------------------------------------------------------

// Make final output PID results
// Current uses for each track Global PID if it exists,
// otherwise local if that exists
RichOfflinePIDSeq.Members += { "Rich::Rec::HierarchicalPIDMerge/MergeOfflineRichPIDs" };

// Reconstruction summary
//RecoRICHSeq.Members += { "Rich::Rec::SummaryAlg/RichRecSummary" };

// Reconstruction algorithm parameters
// ========================================================================================

// Particle types to consider
//ToolSvc.Offline_RichPhotonCreator.Predictor.ParticleTypes = { "pion", "kaon" };
//ToolSvc.RichParticleProperties.ParticleTypes         = { "pion", "kaon" };

// Local Algorithm parameters
RichLocPID.TrackSelector.TrackAlgs = { "Seed","Match","Forward","KsTrack","VeloTT" };
RichLocPID.MinimumPtot                       = 0.0*GeV;
RichLocPID.MaxUsedTracks                     = 400;
RichLocPID.MaxInputTracks                    = 99999;
ToolSvc.RichLocPIDTool.MinProbThresholdHighP = { 0.03,  0.01, 0.02, 0.02 };
ToolSvc.RichLocPIDTool.MinProbThresholdLowP  = { 0.1,   0.1,  0.1,  0.09 };
ToolSvc.RichLocPIDTool.CherenkovThetaRes     = { 0.002, 0.0014, 0.0007   };
// Cherenkov angle space tool
ToolSvc.Offline_RichToolRegistry.Tools += { "Rich::Rec::LocalPID::PIDToolAngleSpace/RichLocPIDTool" };

// Global PID digit selection
RichOfflineGPIDDigSel.MaxUsedPixels            = 8000;

// Global PID track selection
RichOfflineGPIDTrSel.TrackSelector.TrackAlgs = { "Forward","Match","Seed","VeloTT","KsTrack" };
//RichOfflineGPIDTrSel.TrackSelector.TrackAlgs += {"MCRichTrack"}; // uncomment to add MC tracks to be used by GPID
//RichOfflineGPIDTrSel.TrackSelector.KsTrack.MinPCut = 0;
//RichOfflineGPIDTrSel.TrackSelector.VeloTT.MinPCut  = 0;
RichOfflineGPIDTrSel.MaxUsedTracks             = 400;
RichOfflineGPIDTrSel.MaxInputTracks            = 99999;
RichOfflineGPIDTrSel.MinimumPhysicsMomentum    = 0.0*GeV;
RichOfflineGPIDTrSel.MinimumLikelihoodMomentum = 0.0*GeV;
RichOfflineGPIDTrSel.ResetTracksToPion         = false;

// options to 'freeze' some tracks in the global PID selection
//RichGloPIDTrSel.FreezeSelectedTracks = true;
// Type to freeze : Full list are - "Seed","Match","Forward","KsTrack","VeloTT","MCRichTrack"
//RichGloPIDTrSel.FrozenTrackSelector.TrackAlgs = { "VeloTT" };
//RichGloPIDTrSel.FrozenTrackSelector.MCRichTrack.MaxPCut = 200; // GeV
//RichGloPIDTrSel.FrozenTrackSelector.MCRichTrack.MinPCut = 0; // GeV
// Hypothesis for frozen types : 0=el 1=mu 2=pi 3=ka 4=pr
//RichGloPIDTrSel.FrozenTrackMassHypo = 0;

// Global Algorithm parameters - phase 1
RichOfflineGPIDLLIt0.GPIDLikelihoodTool.TrackFreezeOutDLL           = 2;
RichOfflineGPIDLLIt0.GPIDLikelihoodTool.TrackForceChangeDLL         = -1;
RichOfflineGPIDLLIt0.GPIDLikelihoodTool.LikelihoodThreshold         = -1e-2;
RichOfflineGPIDLLIt0.GPIDLikelihoodTool.MaxTrackChangesPerIt        = 5;
RichOfflineGPIDLLIt0.GPIDLikelihoodTool.MinSignalForNoLLCalc        = 1e-3;

// Global Algorithm parameters - phase 2
RichOfflineGPIDLLIt1.GPIDLikelihoodTool.TrackFreezeOutDLL         = 4;
RichOfflineGPIDLLIt1.GPIDLikelihoodTool.TrackForceChangeDLL       = -2;
RichOfflineGPIDLLIt1.GPIDLikelihoodTool.LikelihoodThreshold       = -1e-3;
RichOfflineGPIDLLIt1.GPIDLikelihoodTool.MaxTrackChangesPerIt      = 5;
RichOfflineGPIDLLIt1.GPIDLikelihoodTool.MinSignalForNoLLCalc      = 1e-3;

// Final iteration must have this option set
RichOfflineGPIDLLIt1.GPIDLikelihoodTool.FinalDLLCheck = true;

// PID merging
MergeOfflineRichPIDs.UseLocalPIDs     = false;
MergeOfflineRichPIDs.UseGlobalPIDs    = true;
//MergeRichPIDs.OutputPIDLocation = "Rec/Rich/NewPIDs";

// summary maker parameters
RichRecSummary.PhotonNSigma = { 1.0, 1.5, 1.5 };

