
// ============================================================================
// Define the algorithms to run and in which order
// Run the offline quality algorithms on offline tracks
// ============================================================================

// Set offline mode
RecoRICHSeq.Context = "Offline";

//-----------------------------------------------------------------------------
// Uncomment these to make sure data (tracks and raw event) are in memory
// Useful for timing studies
//-----------------------------------------------------------------------------
//RecoRICHSeq.Members += { "Rich::DAQ::LoadRawEvent/LoadRawRichEvent",
//                         "Rich::Rec::Initialise/LoadRawTracks" };
//LoadRawTracks.CheckProcStatus = false;
//LoadRawTracks.CreatePixels    = false;
//LoadRawTracks.CreateTracks    = false;
//LoadRawTracks.CreatePhotons   = false;
//LoadRawTracks.LoadRawTracks   = true;

//-----------------------------------------------------------------------------
// Initialisation (Technically not needed, but nuseful for timing studies)
//-----------------------------------------------------------------------------
RecoRICHSeq.Members += { "GaudiSequencer/RichRecInitSeq" };
RichRecInitSeq.MeasureTime = true;

RichRecInitSeq.Members += { "GaudiSequencer/RichPixelsSeq" };
RichPixelsSeq.MeasureTime      = true;
RichPixelsSeq.Members += { "Rich::DAQ::RawBufferToRichDigitsAlg/DecodeRawRich" };
DecodeRawRich.DecodeBufferOnly = true;
RichPixelsSeq.Members += { "Rich::Rec::Initialise/CreatePixels" };
CreatePixels.CheckProcStatus   = false;
CreatePixels.CreatePixels      = true;

RichRecInitSeq.Members += { "GaudiSequencer/RichTracksSeq" };
RichTracksSeq.MeasureTime     = true;
RichTracksSeq.Members += { "Rich::Rec::Initialise/CheckProcStatus" };
RichTracksSeq.Members += { "Rich::Rec::Initialise/CreateTracks" };
CreateTracks.CheckProcStatus  = false;
CreateTracks.CreateTracks     = true;

RichRecInitSeq.Members += { "GaudiSequencer/RichPhotonsSeq" };
RichPhotonsSeq.MeasureTime    = true;
RichPhotonsSeq.Members += { "Rich::Rec::Initialise/CreatePhotons" };
CreatePhotons.CheckProcStatus = false;
CreatePhotons.CreatePhotons   = true;
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Local PID algorithm
//-----------------------------------------------------------------------------
//RecoRICHSeq.Members += { "GaudiSequencer/RichLocalPIDSeq" };
//RichLocalPIDSeq.MeasureTime   = true;
//RichLocalPIDSeq.Members += { "Rich::Rec::LocalPID::PIDAlg/RichLocPID" };
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Global PID algorithm
//-----------------------------------------------------------------------------

// Initialise Global PID algorithm for each event
RecoRICHSeq.Members += { "GaudiSequencer/RichGlobalPIDSeq" };
RichGlobalPIDSeq.MeasureTime   = true;
RichGlobalPIDSeq.Members += { "Rich::Rec::GlobalPID::Initialize/RichGloPIDInit",
                              "Rich::Rec::GlobalPID::DigitSel/RichGloPIDDigSel",
                              "Rich::Rec::GlobalPID::TrackSel/RichGloPIDTrSel" };

// First iteration of background estimation then Global PID iteration
RichGlobalPIDSeq.Members += { "Rich::Rec::BackgroundEstiAvHPD/RichBckEstPreIt" };
RichGlobalPIDSeq.Members += { "Rich::Rec::GlobalPID::Likelihood/RichGloPIDPreIt" };

// Second iteration of background estimation then Global PID iteration
RichGlobalPIDSeq.Members += { "Rich::Rec::BackgroundEstiAvHPD/RichBckEstFinalIt" };
RichGlobalPIDSeq.Members += { "Rich::Rec::GlobalPID::Likelihood/RichGloPIDFinalIt" };

// Finalise Global PID algorithm each event
RichGlobalPIDSeq.Members += { "Rich::Rec::GlobalPID::Finalize/RichGloPIDFin" };

//-----------------------------------------------------------------------------

// Make final output PID results
// Current uses for each track Global PID if it exists,
// otherwise local if that exists
RecoRICHSeq.Members += { "Rich::Rec::HierarchicalPIDMerge/MergeRichPIDs" };

// Reconstruction summary
RecoRICHSeq.Members += { "Rich::Rec::SummaryAlg/RichRecSummary" };

// Reconstruction algorithm parameters
// ========================================================================================

// Particle types to consider
//ToolSvc.Offline.RichPhotonCreator.Predictor.ParticleTypes = { "pion", "kaon" };
//ToolSvc.RichParticleProperties.ParticleTypes         = { "pion", "kaon" };

// Local Algorithm parameters
RichLocPID.TrackSelector.TrackAlgs = { "Seed","Match","Forward","KsTrack","VeloTT" };
RichLocPID.MinimumPtot                       = 0.0*GeV;
RichLocPID.MaxUsedTracks                     = 400;
RichLocPID.MaxInputTracks                    = 99999;
ToolSvc.RichLocPIDTool.MinProbThresholdHighP = { 0.03,  0.01, 0.02, 0.02 };
ToolSvc.RichLocPIDTool.MinProbThresholdLowP  = { 0.1,   0.1,  0.1,  0.09 };
ToolSvc.RichLocPIDTool.CherenkovThetaRes     = { 0.002, 0.0014, 0.0007   };
// Cherenkov angle space tool
ToolSvc.Offline.RichToolRegistry.Tools += { "Rich::Rec::LocalPID::PIDToolAngleSpace/RichLocPIDTool" };

// Global PID digit selection
RichGloPIDDigSel.MaxUsedPixels            = 8000;

// Global PID track selection
RichGloPIDTrSel.TrackSelector.TrackAlgs = { "Seed","Match","Forward","KsTrack","VeloTT" };
RichGloPIDTrSel.TrackSelector.TrackAlgs += {"MCRichTrack"}; // uncomment to all MC tracks to be used by GPID
RichGloPIDTrSel.TrackSelector.KsTrack.MinPCut = 0;
RichGloPIDTrSel.TrackSelector.VeloTT.MinPCut  = 0;
RichGloPIDTrSel.MaxUsedTracks             = 400;
RichGloPIDTrSel.MaxInputTracks            = 99999;
RichGloPIDTrSel.MinimumPhysicsMomentum    = 0.0*GeV;
RichGloPIDTrSel.MinimumLikelihoodMomentum = 0.0*GeV;
RichGloPIDTrSel.ResetTracksToPion         = false;

// options to 'freeze' some tracks in the global PID selection
//RichGloPIDTrSel.FreezeSelectedTracks = true;
// Type to freeze : Full list are - "Seed","Match","Forward","KsTrack","VeloTT","MCRichTrack"
//RichGloPIDTrSel.FrozenTrackSelector.TrackAlgs = { "VeloTT" };
//RichGloPIDTrSel.FrozenTrackSelector.MCRichTrack.MaxPCut = 200; // GeV
//RichGloPIDTrSel.FrozenTrackSelector.MCRichTrack.MinPCut = 0; // GeV
// Hypothesis for frozen types : 0=el 1=mu 2=pi 3=ka 4=pr
//RichGloPIDTrSel.FrozenTrackMassHypo = 0;

// Global Algorithm parameters - phase 1
RichGloPIDPreIt.TrackFreezeOutDLL           = 2;
RichGloPIDPreIt.TrackForceChangeDLL         = -1;
RichGloPIDPreIt.LikelihoodThreshold         = -1e-2;
RichGloPIDPreIt.MaxTrackChangesPerIt        = 5;
RichGloPIDPreIt.MinSignalForNoLLCalc        = 1e-3;

// Global Algorithm parameters - phase 2
RichGloPIDFinalIt.TrackFreezeOutDLL         = 4;
RichGloPIDFinalIt.TrackForceChangeDLL       = -2;
RichGloPIDFinalIt.LikelihoodThreshold       = -1e-3;
RichGloPIDFinalIt.MaxTrackChangesPerIt      = 5;
RichGloPIDFinalIt.MinSignalForNoLLCalc      = 1e-3;

// Final iteration must have this option set
RichGloPIDFinalIt.FinalDLLCheck = true;

// PID merging
//MergeRichPIDs.UseRingRefitPIDs = false; // disabled for the moment
MergeRichPIDs.UseLocalPIDs     = false;
MergeRichPIDs.UseGlobalPIDs    = true;
//MergeRichPIDs.OutputPIDLocation = "Rec/Rich/NewPIDs";

// summary maker parameters
RichRecSummary.PhotonNSigma = { 1.0, 1.5, 1.5 };
