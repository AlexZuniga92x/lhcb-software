
#ifndef LESTER_DEREFERENCING_OSTREAM_ITERATOR_H
#define LESTER_DEREFERENCING_OSTREAM_ITERATOR_H

#include "Utils/DereferencingOstreamIterator.fwd"
#include <ostream>


/// A replacement for std::ostream_iterator which is useful when the data type that the iterator points to needs to be DEREFERENCED before being sent to the ostream.
/** Use for example as follows:

 #include \<string\>\n
 #include \<vector\>\n
 #include \<iostream\>\n
 #include \<algorithm\>\n
 #include "Utils/DereferencingOstreamIterator.h"\n

int main() {\n
  typedef std::vector<const std::string *> PVec;\n
   PVec pVec;\n
   const std::string s1 = "Hello";\n
   const std::string s2 = "World";\n
   copy(pVec.begin(), pVec.end(), DereferencingOstreamIterator<const std::string *>(std::cout , " "));\n
   std::cout<<std::endl;\n
   return 0;\n
};\n

The above code should generate send "Hello World\n" to std::cout.
*/

template<class T>
class DereferencingOstreamIterator {
protected:
  bool m_outputted;
  std::ostream & m_os;
private:
  const char * const m_delimiter;
public:
  DereferencingOstreamIterator(std::ostream & os, 
			       const char * const delimiter=" ") :
    m_outputted(false),
    m_os(os),
    m_delimiter(delimiter) {
  };
  DereferencingOstreamIterator & operator=(const T & t) {
    if (m_outputted) {
      m_os << m_delimiter;
    } else {
      m_outputted=true;
    };
    dereferenceAndSendToOstream(t);
    return *this;
  };
  DereferencingOstreamIterator & operator*() {
    return *this;
  };
  DereferencingOstreamIterator & operator++() { return *this; };
protected:
  virtual void dereferenceAndSendToOstream(const T & t) const {
    m_os << *t;
  };
};


#endif
