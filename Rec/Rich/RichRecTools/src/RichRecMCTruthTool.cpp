// $Id: RichRecMCTruthTool.cpp,v 1.7 2003-06-30 15:47:05 jonrob Exp $

// local
#include "RichRecMCTruthTool.h"

//-----------------------------------------------------------------------------
// Implementation file for class : RichRecMCTruthTool
//
// 15/03/2002 : Chris Jones   Christopher.Rob.Jones@cern.ch
//-----------------------------------------------------------------------------

// Declaration of the Tool Factory
static const  ToolFactory<RichRecMCTruthTool>          s_factory ;
const        IToolFactory& RichRecMCTruthToolFactory = s_factory ;

// Standard constructor
RichRecMCTruthTool::RichRecMCTruthTool( const std::string& type,
                                        const std::string& name,
                                        const IInterface* parent )
  : RichRecToolBase( type, name, parent ) {

  declareInterface<IRichRecMCTruthTool>(this);

  declareProperty( "MCRichDigitsLocation",
                   m_mcRichDigitsLocation = MCRichDigitLocation::Default );
  declareProperty( "MCRichOpticalPhotonsLocation",
                   m_mcRichPhotonsLocation = MCRichOpticalPhotonLocation::Default );
  declareProperty( "TrackAsctName", m_trAsctName = "TrackToMCP" );
  declareProperty( "TrackAsctType",
                   m_trAsctType = "AssociatorWeighted<TrStoredTrack,MCParticle,double>");

}

StatusCode RichRecMCTruthTool::initialize() {

  MsgStream msg( msgSvc(), name() );
  msg << MSG::DEBUG << "Initialize" << endreq;

  // Sets up various tools and services
  if ( !RichRecToolBase::initialize() ) return StatusCode::FAILURE;

  // Get pointer to EDS
  if ( !serviceLocator()->service( "EventDataSvc", m_evtDataSvc, true ) ) {
    msg << MSG::ERROR << "EventDataSvc not found" << endreq;
    return StatusCode::FAILURE;
  }

  // Get pointer to Track MC truth
  if ( !toolSvc()->retrieveTool(m_trAsctType,m_trAsctName,m_trackToMCP) ) {
    msg << MSG::ERROR << m_trAsctName+" not found" << endreq;
    return StatusCode::FAILURE;
  }

  // Acquire instances of tools
  acquireTool( "RichSegmentCreator", m_segCreator );
  acquireTool( "RichTrackCreator", m_trackCreator );
  acquireTool( "RichPixelCreator", m_pixelCreator );

  // Retrieve particle property service
  IParticlePropertySvc* ppSvc = 0;
  if ( !service( "ParticlePropertySvc", ppSvc ) ) {
    log << MSG::WARNING << "Unable to retrieve ParticlePropertySvc" << endreq;
    sc = StatusCode::FAILURE;
  } else {
    // Setup the PDG code mappings
    m_localID[ 0 ] = Rich::Unknown;
    m_localID[ abs(ppSvc->find("e+")->jetsetID()) ]  = Rich::Electron;
    m_localID[ abs(ppSvc->find("mu+")->jetsetID()) ] = Rich::Muon;
    m_localID[ abs(ppSvc->find("pi+")->jetsetID()) ] = Rich::Pion;
    m_localID[ abs(ppSvc->find("K+")->jetsetID()) ]  = Rich::Kaon;
    m_localID[ abs(ppSvc->find("p+")->jetsetID()) ]  = Rich::Proton;
    ppSvc->release();
  }

  // Setup incident services
  IIncidentSvc * incSvc;
  if ( !serviceLocator()->service( "IncidentSvc", incSvc, true ) ) {
    msg << MSG::ERROR << "IncidentSvc not found" << endreq;
    return StatusCode::FAILURE;
  } else {
    incSvc->addListener( this, "BeginEvent" ); // Informed of a new event
    incSvc->release();
  }

  return StatusCode::SUCCESS;
}

StatusCode RichRecMCTruthTool::finalize() {

  MsgStream msg( msgSvc(), name() );
  msg << MSG::DEBUG << "Finalize" << endreq;

  // release tools and services
  if ( m_trackToMCP ) { toolSvc()->releaseTool( m_trackToMCP ); m_trackToMCP=0; }
  if ( m_evtDataSvc ) { m_evtDataSvc->release(); m_evtDataSvc = 0; }

  // Execute base class method
  return RichRecToolBase::finalize();
}

// Method that handles various Gaudi "software events"
void RichRecMCTruthTool::handle ( const Incident& incident ) {

  MsgStream msg( msgSvc(), name() );
  msg << MSG::VERBOSE << "Informed of incident '" << incident.type()
      << "' generated by '" << incident.source() << "'" << endreq;

  if ( "BeginEvent" == incident.type() ) {

    // New event
    m_mcRichDigitsDone = false;
    m_mcRichOptPhotsDone = false;
    m_mcTruePixelsDone = false;

  }

}

MCRichDigits * RichRecMCTruthTool::mcRichDigits() {

  if ( !m_mcRichDigitsDone ) {
    m_mcRichDigitsDone = true;

    MsgStream msg( msgSvc(), name() );

    SmartDataPtr<MCRichDigits> tdsMCDigits( m_evtDataSvc,
                                            m_mcRichDigitsLocation );
    if ( tdsMCDigits ) {
      m_mcRichDigits = tdsMCDigits;
      msg << MSG::DEBUG << "Successfully located " << m_mcRichDigits->size()
          << " MCRichDigits at " << m_mcRichDigitsLocation << endreq;
    } else {
      m_mcRichDigits = NULL;
      msg << MSG::DEBUG << "Failed to locate MCRichDigits at "
          << m_mcRichDigitsLocation << endreq;
    }

  }

  return m_mcRichDigits;
}

MCRichOpticalPhotons * RichRecMCTruthTool::mcRichOpticalPhotons() {

  if ( !m_mcRichOptPhotsDone ) {
    m_mcRichOptPhotsDone = true;

    MsgStream msg( msgSvc(), name() );

    SmartDataPtr<MCRichOpticalPhotons> tdsMCPhots( m_evtDataSvc,
                                                   m_mcRichPhotonsLocation );
    if ( tdsMCPhots ) {
      m_mcRichOpticalPhotons = tdsMCPhots;
      msg << MSG::DEBUG
          << "Successfully located " << m_mcRichOpticalPhotons->size()
          << " MCRichOpticalPhotons at " << m_mcRichPhotonsLocation << endreq;
    } else {
      m_mcRichOpticalPhotons = NULL;
      msg << MSG::DEBUG << "Failed to locate MCRichOpticalPhotons at "
          << m_mcRichPhotonsLocation << endreq;
    }

  }

  return m_mcRichOpticalPhotons;
}

const MCParticle * RichRecMCTruthTool::mcParticle( const RichRecTrack * richTrack ) {

  const ContainedObject * obj = richTrack->parentTrack();
  if ( !obj ) return NULL;

  // Try TrStoredTrack
  const TrStoredTrack * track = dynamic_cast<const TrStoredTrack*>(obj);
  if ( track ) {
    const SmartRef<MCParticle> mcP = m_trackToMCP->associatedFrom( track );
    return mcP;
  }

  // else Try MCParticle
  const MCParticle * mcPart = dynamic_cast<const MCParticle*>(obj);
  if ( mcPart ) return mcPart;
   
  return NULL;
}

const MCRichDigit * RichRecMCTruthTool::mcRichDigit( const RichRecPixel * richPixel )
{
  const RichDigit * digit = dynamic_cast<const RichDigit*>( richPixel->parentPixel() );
  if ( !digit ) return NULL;

  // Try fast method
  MCRichDigit * mcDigit = MCTruth<MCRichDigit>(digit);

  // If failed, try accessing MCRichDigit container directly
  if ( !mcDigit && 
       mcRichDigits() ) mcDigit = m_mcRichDigits->object( digit->key() );

  // Return MCRichDigit
  return mcDigit;
}

const MCParticle * RichRecMCTruthTool::mcParticle( const RichRecPixel * richPixel )
{
  const MCRichDigit * mcDigit = mcRichDigit( richPixel );
  if ( !mcDigit ) return NULL;
  if ( mcDigit->hits().size() < 1 ) return NULL;
  // For the moment take first (and only) MCRichHit
  const MCRichHit * mcHit = *(mcDigit->hits().begin());
  return ( mcHit ? mcHit->mcParticle() : NULL );
}

const MCParticle * RichRecMCTruthTool::trueRecPhoton( const RichRecPhoton * photon ) {

  RichRecTrack * track = (RichRecTrack*)photon->richRecTrack();
  RichRecPixel * pixel = (RichRecPixel*)photon->richRecPixel();

  const MCParticle * mcTrack = ( track ? mcParticle(track) : NULL );
  const MCParticle * mcPixel = ( pixel ? mcParticle(pixel) : NULL );

  return ( mcTrack == mcPixel ? mcTrack : NULL );
}

const MCParticle * RichRecMCTruthTool::trueCherenkovPhoton( const RichRecPhoton * photon ) {

  const MCParticle * mcPart = trueRecPhoton( photon );
  if ( !mcPart ) return NULL;

  if ( const MCRichOpticalPhoton * optPhot = mcRichOpticalPhoton( photon->richRecPixel() ) ) {
    Rich::RadiatorType rad = photon->richRecSegment()->trackSegment().radiator();
    if ( ( rad != Rich::Aerogel && optPhot->gas() ) ||
         ( rad == Rich::Aerogel && optPhot->aerogel() &&
           !optPhot->scatteredAerogel() ) ) return mcPart;
  }
  
  return NULL;
}

Rich::ParticleIDType
RichRecMCTruthTool::mcParticleType( const MCParticle * mcPart ) {
  return (mcPart ? m_localID[abs(mcPart->particleID().pid())] : Rich::Unknown);
}

Rich::ParticleIDType
RichRecMCTruthTool::mcParticleType( const RichRecTrack * richTrack ) {
  const MCParticle * mcPart = this->mcParticle( richTrack );
  return (mcPart ? m_localID[abs(mcPart->particleID().pid())] : Rich::Unknown);
}

Rich::ParticleIDType
RichRecMCTruthTool::mcParticleType( const RichRecSegment * richSegment ) {
  const MCParticle * mcPart = this->mcParticle( richSegment->richRecTrack() );
  return (mcPart ? m_localID[abs(mcPart->particleID().pid())] : Rich::Unknown);
}

const MCParticle *
RichRecMCTruthTool::mcParticle( const RichRecSegment * richSegment ) {
  return this->mcParticle( richSegment->richRecTrack() );
}

const MCRichOpticalPhoton *
RichRecMCTruthTool::mcRichOpticalPhoton( const RichRecPixel * richPixel ) {

  MCRichOpticalPhoton * phot = NULL;
  if ( mcRichOpticalPhotons() ) {
    const MCRichDigit * mcDigit = mcRichDigit( richPixel );
    if ( mcDigit && mcDigit->hits().size() >= 1 ) {
      // For the moment take first (and only) MCHit
      const MCRichHit * mcHit = *(mcDigit->hits().begin());
      phot = m_mcRichOpticalPhotons->object( mcHit->key() );
      if ( phot && phot->mcRichHit() != mcHit ) {
        MsgStream msg( msgSvc(), name() );
        msg << MSG::WARNING << "Problem with optical photon reference" << endreq;
      }
    }
  }

  return phot;
}

RichRecPixelVector*
RichRecMCTruthTool::trueCkPixels( const RichRecSegment * segment ) {

  // Should I consider making this an associator ??

  if ( !m_mcTruePixelsDone ) {
    m_mcTruePixelsDone = true;

    // Get pointer to all pixels
    RichRecPixels * allPixels = m_pixelCreator->richPixels();
    RichRecSegments * allSegments = m_segCreator->richSegments();
    m_mcPixelMap.clear();

    // Loop over all pixel/segment combinations
    for ( RichRecSegments::iterator seg = allSegments->begin();
          seg != allSegments->end();
          ++seg ) {
      Rich::RadiatorType rad = (*seg)->trackSegment().radiator();
      const MCParticle * tkMCPart = mcParticle( (*seg)->richRecTrack() );
      std::vector<RichRecPixel*> & vec = m_mcPixelMap[ *seg ];

      for ( RichRecPixels::iterator pix = allPixels->begin();
            pix != allPixels->end();
            ++pix ) {

        if ( (*seg)->trackSegment().rich() != (*pix)->detector() ) continue;

        const MCParticle * pixMCPart = mcParticle( *pix );
        if ( pixMCPart == tkMCPart ) {
          const MCRichOpticalPhoton * optPhot = mcRichOpticalPhoton( *pix );
          if ( optPhot ) {
            if ( ( rad != Rich::Aerogel && optPhot->gas() ) ||
                 ( rad == Rich::Aerogel && optPhot->aerogel() &&
                   !optPhot->scatteredAerogel() ) ) {
              vec.push_back( *pix );
            }
          }
        }

      } // pixel loop
    } // segment loop

  } // once per event

  return &m_mcPixelMap[ segment ];
}

