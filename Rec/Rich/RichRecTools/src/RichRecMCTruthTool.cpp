// $Id: RichRecMCTruthTool.cpp,v 1.4 2002-12-20 09:33:08 cattanem Exp $

// from Gaudi
#include "GaudiKernel/ToolFactory.h"
#include "GaudiKernel/MsgStream.h"
#include "GaudiKernel/SmartDataPtr.h"
#include "GaudiKernel/IDataProviderSvc.h"
#include "GaudiKernel/GaudiException.h"

// local
#include "RichRecTools/RichRecMCTruthTool.h"

// CLHEP
#include "CLHEP/Units/PhysicalConstants.h"

//-----------------------------------------------------------------------------
// Implementation file for class : RichRecMCTruthTool
//
// 15/03/2002 : Chris Jones   Christopher.Rob.Jones@cern.ch
//-----------------------------------------------------------------------------

// Declaration of the Tool Factory
static const  ToolFactory<RichRecMCTruthTool>          s_factory ;
const        IToolFactory& RichRecMCTruthToolFactory = s_factory ;

// Standard constructor
RichRecMCTruthTool::RichRecMCTruthTool( const std::string& type,
                                        const std::string& name,
                                        const IInterface* parent )
  : AlgTool( type, name, parent ) {

  declareInterface<IRichRecMCTruthTool>(this);

  declareProperty( "MCRichDigitsLocation",
                   m_mcRichDigitsLocation = MCRichDigitLocation::Default );
  declareProperty( "MCRichOpticalPhotonsLocation",
                   m_mcRichPhotonsLocation = MCRichOpticalPhotonLocation::Default );
  declareProperty( "TrackAsctName", m_trAsctName = "TrackToMCP" );
  declareProperty( "TrackAsctType",
                   m_trAsctType = "AssociatorWeighted<TrStoredTrack,MCParticle,double>");

}

StatusCode RichRecMCTruthTool::initialize() {

  MsgStream log( msgSvc(), name() );
  log << MSG::DEBUG << "Initialize" << endreq;

  StatusCode sc = StatusCode::SUCCESS;

  // Get pointer to EDS
  if ( !serviceLocator()->service( "EventDataSvc", m_evtDataSvc, true ) ) {
    log << MSG::ERROR << "EventDataSvc not found" << endreq;
    sc = StatusCode::FAILURE;
  }

  // Get pointer to Track MC truth
  if ( !toolSvc()->retrieveTool(m_trAsctType,m_trAsctName,m_trackToMCP) ) {
    log << MSG::ERROR << m_trAsctName+" not found" << endreq;
    sc = StatusCode::FAILURE;
  }

  // Get pointer to RichRecTrack Tool
  if ( !toolSvc()->retrieveTool( "RichRecTrackTool", m_richRecTrackTool) ) {
    log << MSG::ERROR << "RichRecTrackTool not found" << endreq;
    sc = StatusCode::FAILURE;
  }

  // Get pointer to RichRecSegment Tool
  if ( !toolSvc()->retrieveTool( "RichRecSegmentTool", m_richRecSegmentTool) ) {
    log << MSG::ERROR << "RichRecSegmentTool not found" << endreq;
    sc = StatusCode::FAILURE;
  }

  // Get pointer to RichRecPixel Tool
  if ( !toolSvc()->retrieveTool( "RichRecPixelTool", m_richRecPixelTool) ) {
    log << MSG::ERROR << "RichRecPixelTool not found" << endreq;
    sc = StatusCode::FAILURE;
  }

  // Retrieve particle property service
  if ( !service( "ParticlePropertySvc", m_ppSvc) ) {
    log << MSG::WARNING << "Unable to retrieve ParticlePropertySvc" << endreq;
    sc = StatusCode::FAILURE;
  } else {
    // Setup the PDG code mappings
    m_localID[ 0 ] = Rich::Unknown;
    m_localID[ abs(m_ppSvc->find("e+")->jetsetID()) ]  = Rich::Electron;
    m_localID[ abs(m_ppSvc->find("mu+")->jetsetID()) ] = Rich::Muon;
    m_localID[ abs(m_ppSvc->find("pi+")->jetsetID()) ] = Rich::Pion;
    m_localID[ abs(m_ppSvc->find("K+")->jetsetID()) ]  = Rich::Kaon;
    m_localID[ abs(m_ppSvc->find("p+")->jetsetID()) ]  = Rich::Proton;
  }

  // Setup incident services
  IIncidentSvc * incSvc;
  if ( !serviceLocator()->service( "IncidentSvc", incSvc, true ) ) {
    log << MSG::ERROR << "IncidentSvc not found" << endreq;
    sc = StatusCode::FAILURE;
  } else {
    incSvc->addListener( this, "BeginEvent" ); // Informed of a new event
  }

  return sc;
}

StatusCode RichRecMCTruthTool::finalize() {

  // Release all tools
  if( m_trackToMCP )         toolSvc()->releaseTool( m_trackToMCP );
  if( m_richRecTrackTool )   toolSvc()->releaseTool( m_richRecTrackTool );
  if( m_richRecSegmentTool ) toolSvc()->releaseTool( m_richRecSegmentTool );
  if( m_richRecPixelTool )   toolSvc()->releaseTool( m_richRecPixelTool );
  
  return StatusCode::SUCCESS;
}

// Method that handles various Gaudi "software events"
void RichRecMCTruthTool::handle ( const Incident& incident ) {

  MsgStream log( msgSvc(), name() );
  log << MSG::VERBOSE << "Informed of incident '" << incident.type()
      << "' generated by '" << incident.source() << "'" << endreq;

  if ( "BeginEvent" == incident.type() ) {

    // New event
    m_mcRichDigitsDone = false;
    m_mcRichOptPhotsDone = false;
    m_mcTruePixelsDone = false;

  }

}

MCRichDigits * RichRecMCTruthTool::mcRichDigits() {

  if ( !m_mcRichDigitsDone ) {
    m_mcRichDigitsDone = true;

    MsgStream log( msgSvc(), name() );

    SmartDataPtr<MCRichDigits> tdsMCDigits( m_evtDataSvc,
                                            m_mcRichDigitsLocation );
    if ( tdsMCDigits ) {
      m_mcRichDigits = tdsMCDigits;
      log << MSG::DEBUG << "Successfully located " << m_mcRichDigits->size()
          << " MCRichDigits at " << m_mcRichDigitsLocation << endreq;
    } else {
      m_mcRichDigits = NULL;
      log << MSG::DEBUG << "Failed to locate MCRichDigits at "
          << m_mcRichDigitsLocation << endreq;
    }

  }

  return m_mcRichDigits;
}

MCRichOpticalPhotons * RichRecMCTruthTool::mcRichOpticalPhotons() {

  if ( !m_mcRichOptPhotsDone ) {
    m_mcRichOptPhotsDone = true;

    MsgStream log( msgSvc(), name() );

    SmartDataPtr<MCRichOpticalPhotons> tdsMCPhots( m_evtDataSvc,
                                                   m_mcRichPhotonsLocation );
    if ( tdsMCPhots ) {
      m_mcRichOpticalPhotons = tdsMCPhots;
      log << MSG::DEBUG
          << "Successfully located " << m_mcRichOpticalPhotons->size()
          << " MCRichOpticalPhotons at " << m_mcRichPhotonsLocation << endreq;
    } else {
      m_mcRichOpticalPhotons = NULL;
      log << MSG::DEBUG << "Failed to locate MCRichOpticalPhotons at "
          << m_mcRichPhotonsLocation << endreq;
    }

  }

  return m_mcRichOpticalPhotons;
}

MCParticle * RichRecMCTruthTool::mcParticle( const RichRecTrack * richTrack ) {

  SmartRef<MCParticle> mcPart;

  // Are we using reco or MC tracks
  Rich::RecTrack::ParentType parentType = richTrack->parentType();
  if ( Rich::RecTrack::TrStoredTrack == parentType ) {

    TrStoredTrack * track = m_richRecTrackTool->parentTrTrack( richTrack );
    if ( 0 != track ) mcPart = m_trackToMCP->associatedFrom( track );

  } else if ( Rich::RecTrack::MCParticle == parentType ) {

    mcPart = m_richRecTrackTool->parentMCP( richTrack );

  }

  return mcPart;
}

MCRichDigit * RichRecMCTruthTool::mcRichDigit( const RichRecPixel * richPixel )
{
  RichDigit * digit = m_richRecPixelTool->parentRichDigit( richPixel );
  if ( !digit ) return NULL;

  // Try fast method
  MCRichDigit * mcDigit = MCTruth<MCRichDigit>(digit);

  // If failed, try accessing MCRichDigit container directly
  if ( !mcDigit && mcRichDigits() ) {
    mcDigit = m_mcRichDigits->object( digit->key() );
  }

  // Return MCRichDigit
  return mcDigit;
}

MCParticle * RichRecMCTruthTool::mcParticle( const RichRecPixel * richPixel )
{
  MCRichDigit * mcDigit = mcRichDigit( richPixel );
  if ( !mcDigit ) return NULL;
  if ( mcDigit->hits().size() < 1 ) return NULL;
  // For the moment take first (and only) MCHit
  MCHit * mcHit = *(mcDigit->hits().begin());
  return ( mcHit ? mcHit->mcParticle() : NULL );
}

MCParticle * RichRecMCTruthTool::trueRecPhoton( const RichRecPhoton * photon ) {

  RichRecTrack * track= (RichRecTrack*)photon->richRecSegment()->richRecTrack();
  RichRecPixel * pixel = (RichRecPixel*)photon->richRecPixel();

  MCParticle * mcTrack = ( track ? mcParticle(track) : NULL );
  MCParticle * mcPixel = ( pixel ? mcParticle(pixel) : NULL );

  return ( mcTrack == mcPixel ? mcTrack : NULL);
}

Rich::ParticleIDType
RichRecMCTruthTool::mcParticleType( const MCParticle * mcPart ) {
  return (mcPart ? m_localID[abs(mcPart->particleID().pid())] : Rich::Unknown);
}

Rich::ParticleIDType
RichRecMCTruthTool::mcParticleType( const RichRecTrack * richTrack ) {
  MCParticle * mcPart = this->mcParticle( richTrack );
  return (mcPart ? m_localID[abs(mcPart->particleID().pid())] : Rich::Unknown);
}

Rich::ParticleIDType
RichRecMCTruthTool::mcParticleType( const RichRecSegment * richSegment ) {
  MCParticle * mcPart = this->mcParticle( richSegment->richRecTrack() );
  return (mcPart ? m_localID[abs(mcPart->particleID().pid())] : Rich::Unknown);
}

MCParticle *
RichRecMCTruthTool::mcParticle( const RichRecSegment * richSegment ) {
  return this->mcParticle( richSegment->richRecTrack() );
}

MCRichOpticalPhoton *
RichRecMCTruthTool::mcRichOpticalPhoton( const RichRecPixel * richPixel ) {

  MCRichOpticalPhoton * phot = NULL;
  if ( mcRichOpticalPhotons() ) {
    MCRichDigit * mcDigit = mcRichDigit( richPixel );
    if ( mcDigit && mcDigit->hits().size() >= 1 ) {
      // For the moment take first (and only) MCHit
      MCHit * mcHit = *(mcDigit->hits().begin());
      phot = m_mcRichOpticalPhotons->object( mcHit->key() );
      if ( phot && phot->mcRichHit() != mcHit ) {
        MsgStream log( msgSvc(), name() );
        log << MSG::WARNING << "Problem with optical photon reference" << endreq;
      }
    }
  }

  return phot;
}

RichRecPixelVector*
RichRecMCTruthTool::trueCkPixels( const RichRecSegment * segment ) {

  // Should I consider making this an associator ??

  if ( !m_mcTruePixelsDone ) {
    m_mcTruePixelsDone = true;

    // Get pointer to all pixels
    RichRecPixels * allPixels = m_richRecPixelTool->richPixels();
    RichRecSegments * allSegments = m_richRecSegmentTool->richSegments();
    m_mcPixelMap.clear();

    // Loop over all pixel/segment combinations
    for ( RichRecSegments::iterator seg = allSegments->begin();
          seg != allSegments->end();
          seg++ ) {
      Rich::RadiatorType rad = (*seg)->trackSegment().radiator();
      MCParticle * tkMCPart = mcParticle( (*seg)->richRecTrack() );
      std::vector<RichRecPixel*> & vec = m_mcPixelMap[ *seg ];

      for ( RichRecPixels::iterator pix = allPixels->begin();
            pix != allPixels->end();
            pix++ ) {

        if ( (*seg)->trackSegment().rich() != (*pix)->detector() ) continue;

        MCParticle * pixMCPart = mcParticle( *pix );
        if ( pixMCPart == tkMCPart ) {
          MCRichOpticalPhoton * optPhot = mcRichOpticalPhoton( *pix );
          if ( optPhot ) {
            if ( ( rad != Rich::Aerogel && optPhot->gas() ) ||
                 ( rad == Rich::Aerogel && optPhot->aerogel() &&
                   !optPhot->scatteredAerogel() ) ) {
              vec.push_back( *pix );
            }
          }
        }

      } // pixel loop
    } // segment loop

  } // once per event

  return &m_mcPixelMap[ segment ];
}

