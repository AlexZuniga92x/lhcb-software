// $Id: RichRecPhotonTool.cpp,v 1.1.1.1 2002-07-28 10:46:20 jonesc Exp $
#include <cmath>

// from Gaudi
#include "GaudiKernel/ToolFactory.h"
#include "GaudiKernel/MsgStream.h"
#include "GaudiKernel/SmartDataPtr.h"
#include "GaudiKernel/IDataProviderSvc.h"
#include "GaudiKernel/GaudiException.h"

// RichUtils
#include "RichUtils/RichGeomPhoton.h"

// local
#include "RichRecTools/RichRecPhotonTool.h"


//-----------------------------------------------------------------------------
// Implementation file for class : RichRecPhotonTool
//
// 15/03/2002 : Chris Jones
//-----------------------------------------------------------------------------

// Declaration of the Tool Factory
static const  ToolFactory<RichRecPhotonTool>          s_factory ;
const        IToolFactory& RichRecPhotonToolFactory = s_factory ;

// Standard constructor
RichRecPhotonTool::RichRecPhotonTool( const std::string& type,
                                      const std::string& name,
                                      const IInterface* parent )
  : AlgTool( type, name, parent ) {

  declareInterface<IRichRecPhotonTool>(this);

  // Define job option parameters
  declareProperty( "RichRecPhotonLocation",
                   m_richRecPhotonLocation = RichRecPhotonLocation::Default );

  // Get pointer to EDS
  StatusCode scEvent = serviceLocator()->service( "EventDataSvc",
                                                  m_eventDataService, true );
  if( scEvent.isFailure() ) {
    throw GaudiException( "EventDataSvc not found",
                          "RichRecPhotonToolException", scEvent );
  }

  // Get Pointer to ToolSvc
  StatusCode scTool = serviceLocator()->service( "ToolSvc",
                                                 m_toolService, true );
  if( scTool.isFailure() ) {
    throw GaudiException( "ToolSvc not found",
                          "RichRecPhotonToolException", scTool );
  }

  // Get pointer to RichRecDataTool
  StatusCode scData = m_toolService->retrieveTool( "RichRecDataTool",
                                                   m_richRecDataTool );
  if ( scData.isFailure() ) {
    throw GaudiException( "RichRecDataTool not found",
                          "RichRecPhotonToolException", scData );
  }

  // Get pointer to RichDetInterface
  StatusCode scDet = m_toolService->retrieveTool( "RichDetInterface",
                                                   m_richDetInterface );
  if ( scDet.isFailure() ) {
    throw GaudiException( "RichDetInterface not found",
                          "RichRecPhotonToolException", scDet );
  }

  // Setup incident services
  IIncidentSvc * incSvc;
  StatusCode sc = serviceLocator()->service( "IncidentSvc", incSvc, true );
  if ( sc.isFailure() ) { 
    throw GaudiException( "IncidentSvc not found",
                          "RichRecPhotonToolException", sc );
  }
  incSvc->addListener( this, "BeginEvent" ); // Ask to be informed of a new event
  incSvc->addListener( this, "EndEvent"   ); // Ask to be informed at the end of event

}

// Method that handles various Gaudi "software events"
void RichRecPhotonTool::handle ( const Incident& incident ) {

  MsgStream log( msgSvc(), name() );
  log << MSG::DEBUG << "Informed of incident '" << incident.type()
      << "' generated by '" << incident.source() << "'" << endreq;

  if ( "BeginEvent" == incident.type() ) {

    SmartDataPtr<RichRecPhotons> tdsPhotons(m_eventDataService,
                                            m_richRecPhotonLocation);
    if ( !tdsPhotons ) {

      // Reinitialise the Photon Container
      m_photons = new RichRecPhotons();

      // Empty the photon map
      m_photonExists.clear();

      m_fromTDS = false;

    } else {

      // Set smartref to TDS photon contianer
      m_photons = tdsPhotons;

      // Remake local photon reference map
      for ( RichRecPhotons::const_iterator iPhoton = tdsPhotons->begin();
            iPhoton != tdsPhotons->end();
            ++iPhoton ) {
        m_photonExists[(int)(*iPhoton)->key()] = *iPhoton;
      }
      m_fromTDS = true;

    }

  } else if ( "EndEvent" == incident.type() ) {

    if ( !m_fromTDS ) {
      // Register new RichRecPhoton container to Gaudi data store
      // Note gaudi framework now owns the object and is in charge of deletion
      StatusCode registerRichPhotons =
        m_eventDataService->registerObject(m_richRecPhotonLocation, m_photons);
      if ( registerRichPhotons.isFailure() ) {
        log << MSG::ERROR << "Failed to register RichRecPhotons at "
            << m_richRecPhotonLocation << endreq;
      } else {
        log << MSG::DEBUG << "Successfully registered " << m_photons->size()
            << " RichRecPhotons at " << m_richRecPhotonLocation << endreq;
      }
    }

  }
  return;
}

RichRecPhoton*
RichRecPhotonTool::reconstructPhoton( const SmartRef<RichRecSegment>& segment,
                                      const SmartRef<RichRecPixel>& pixel ) {

  // Form the key for this photon
  RichRecPhotonKey key;
  key.setSegmentNumber( segment->index() );
  key.setPixelNumber( pixel->index() );
  int keyInt = (int)key;

  ///
  /// NB: This code needs to be profiled to see how efficient it is.
  /// That can come later though, for the moment focus on functionality.
  ///

  // See if this photon already exists
  SmartRef<RichRecPhoton> photon = m_photonExists[keyInt];
  if ( 0 != photon ) {
    return photon;
  } else {    
    
    // Verify if it is physically possible to form a photon candidate
    // from this segment pixel combination
    if ( !photonPossible( segment, pixel ) ) { return NULL; }

    // Form a new RichRecPhoton
    RichRecPhoton * newPhoton = new RichRecPhoton();

    // Reconstruct the Cherenkov angles
    RichGeomPhoton geomPhoton;
    m_richDetInterface->reconstructPhoton( segment->trackSegment(), 
                                           pixel->position(), geomPhoton );
    newPhoton->setGeomPhoton( geomPhoton );

    // Note remaining data members of RichRecPhoton not available

    // Add to reference map
    m_photonExists[keyInt] = newPhoton;

    // Give to the Photon container (note this then takes care of object deletion)
    m_photons->insert( newPhoton, key );

    // Return pointer to this photon
    return newPhoton;
  }

}

SmartRefVector<RichRecPhoton>
RichRecPhotonTool::reconstructPhotons(const SmartRef<RichRecTrack>& track,
                                      const SmartRef<RichRecPixel>& pixel) {

  MsgStream log( msgSvc(), name() );

  // Form SmartRefVector of RichRecPhotons
  SmartRefVector<RichRecPhoton> photons;

  // Get the SmartRefVector of RichRecSegments for this track
  SmartRefVector<RichRecSegment> segments = track->radiatorSegments();

  // Iterate over segments
  for ( SmartRefVector<RichRecSegment>::const_iterator segment = segments.begin();
        segment != segments.end();
        ++segment) {

    // Make a new photon with this segment+pixel combination
    SmartRef<RichRecPhoton> photon = reconstructPhoton( *segment, pixel );
    if ( 0 != photon ) {
      // Add this photon to SmartRefVector
      photons.push_back( photon );
    }

  }

  return photons;
}

SmartRefVector<RichRecPhoton>
RichRecPhotonTool::reconstructPhotons(const SmartRef<RichRecTrack>& track) {

  MsgStream log( msgSvc(), name() );

  // Form SmartRefVector of RichRecPhotons
  SmartRefVector<RichRecPhoton> photons;

  // Locate pixel data container
  SmartDataPtr<RichRecPixels> pixels = m_richRecDataTool->getRichPixels();

  // Iterative over pixels
  // Note at some point some sort of filtering should be placed here....
  // For example, check if pixel and segment are in the same Rich ??
  for ( RichRecPixels::const_iterator pixel = pixels->begin();
        pixel != pixels->end();
        ++pixel ) {

    SmartRefVector<RichRecPhoton> photonsPix = reconstructPhotons(track,*pixel);

    // Add New photons to vector
    for ( SmartRefVector<RichRecPhoton>::const_iterator
            iPhoton = photonsPix.begin();
          iPhoton != photonsPix.end();
          ++iPhoton ) { photons.push_back( *iPhoton ); }

  }

  return photons;
}

SmartRefVector<RichRecPhoton>
RichRecPhotonTool::reconstructPhotons(const SmartRef<RichRecPixel>& pixel) {

  MsgStream log( msgSvc(), name() );

  // Form SmartRefVector of RichRecPhotons
  SmartRefVector<RichRecPhoton> photons;

  // Locate pixel data container
  SmartDataPtr<RichRecTracks> tracks = m_richRecDataTool->getRichTracks();

  // Iterate over tracks
  // Note at some point some sort of filtering should be placed here....
  // For example, check if pixel and segment are in the same Rich ??
  for ( RichRecTracks::const_iterator track = tracks->begin();
        track != tracks->end();
        ++track ) {

    SmartRefVector<RichRecPhoton> photonsPix = reconstructPhotons(*track,pixel);

    // Add New photons to vector
    for ( SmartRefVector<RichRecPhoton>::const_iterator
            iPhoton = photonsPix.begin();
          iPhoton != photonsPix.end();
          ++iPhoton ) { photons.push_back( *iPhoton ); }

  }

  return photons;
}

void RichRecPhotonTool::reconstructPhotons() {

  MsgStream log( msgSvc(), name() );

  // Locate data containers
  SmartDataPtr<RichRecPixels> pixels = m_richRecDataTool->getRichPixels();
  SmartDataPtr<RichRecTracks> tracks = m_richRecDataTool->getRichTracks();

  // Iterate over all tracks
  for ( RichRecTracks::const_iterator track = tracks->begin();
        track != tracks->end();
        ++track ) {

    // Get the SmartRefVector of RichRecSegments for this track
    SmartRefVector<RichRecSegment> segments = (*track)->radiatorSegments();

    // Iterative over pixels
    // Note at some point some sort of filtering should be placed here....
    // For example, check if pixel and segment are in the same Rich ??
    for ( RichRecPixels::const_iterator pixel = pixels->begin();
          pixel != pixels->end();
          ++pixel ) {

      // Iterate over segments
      for ( SmartRefVector<RichRecSegment>::const_iterator segment =
              segments.begin();
            segment != segments.end();
            ++segment) {

        // Make a new photon with this segment+pixel combination
        SmartRef<RichRecPhoton> photon = reconstructPhoton( *segment, *pixel );
        if ( 0==photon ) {
          //log << MSG::ERROR << "Photon reference is Null !" << endreq;
        }

      } // End iteration over segments

    } // end iteration over pixels

  } // end iteration over tracks

}

bool RichRecPhotonTool::photonPossible( const SmartRef<RichRecSegment>& segment,
                                        const SmartRef<RichRecPixel>& pixel ) {

  MsgStream log( msgSvc(), name() );

  double zTrack = segment->trackSegment().middlePoint().z();
  double zPixel = pixel->position().z();
  
  // Are they in the same Rich detector. For now, use z positions but in
  // the future a more refined method would be nice
  bool possible = true;
  if ( abs(zTrack-zPixel) > 500. ) { possible = false; }

  log << MSG::VERBOSE << "Track z = " << zTrack
      << " pixel z " << zPixel << " : Photon possible = " 
      << possible << endreq;
  
  return possible;
}
