//---------------------------
// HLT Reconstruction
//--------------------------
#include "$HLTSYSROOT/options/HltRecoSequence.opts"
//#include "$HLTSYSROOT/options/HltMuonAlleySequence.opts"
// init is needed for ANNSvc
#include "$HLTSYSROOT/options/HltLumiInit.opts"

//---------------------------
// HLT Lumi Alley
//--------------------------

// (not) in HltSummary but in LumiSummary
HltSummaryWriter.Save += {
  // not clear:  "Hlt1LumiDecision"
};

// decision is part of the OR of alleys
HltAlleys.InputSelections += {"Hlt1LumiDecision"};
HltAlleys.InputSelections += {"Hlt1LumiDecision2"};



// *************************************************
// Alley sequence
Hlt1LumiAlleySequence.Members = {
  // "HltL0Filter/LumiEntry",       // L0 not needed, use Odin bit directly
  // filter on Odin trigger types
  "OdinTypesFilter/OdinTypesFilter",
  // should put in here some reco sequence which always passes
  "GaudiSequencer/Hlt1LumiRecoSequence",
  // should put some new algo which writes summary bank
  // "CollectLumiData/CollectLumiData",
  "GaudiSequencer/HltLumiCountSequence",
  // just for debugging puposes
  "HltLumiOdinReader/HltLumiOdinReader",
  // sequences depending on Odin BX types
  "GaudiSequencer/Hlt1LumiBXTypesSequence",
  // prescale to allow for higher rate histogramming than storage
  "DeterministicPrescaler/PrescaleLumiDecision",
  "DummyLumiAlley/Hlt1LumiDecision",
  // writing the bank
  "HltLumiFillRawBuffer/HltLumiFillRawBuffer",
  // another prescaler, just to try
  "DeterministicPrescaler/PrescaleLumiDecision2",
  "DummyLumiAlley/Hlt1LumiDecision2"
};


// *************************************************
// Reconstruction envelope
Hlt1LumiRecoSequence.Members = {
  "GaudiSequencer/Hlt1LumiPreRecoSequence",
  "DummyLumiAlley/HltDummyReco"
};

// *************************************************
// Reconstruction (always pass)
Hlt1LumiPreRecoSequence.Members = {
  "GaudiSequencer/HltRecoSequence",
  //"GaudiSequencer/HltMuonAlley"
};


// *************************************************
// Counting (always pass)
HltLumiCountSequence.Members = {
  "LumiCountTracks/LumiCountVelo",
  "LumiCountTracks/LumiCountRZVelo",
  "GaudiSequencer/HltBWRZVeloSequence",
  "LumiCountHltTracks/LumiCountHltBWRZVelo",
  "LumiCountTracks/LumiCountMuon",
  "LumiCountVertices/LumiCountPV2D",
  "LumiCountVertices/LumiCountPV3D",
  "LumiFromL0DU/LumiCountSpd",
  "LumiFromL0DU/LumiCountPU",
  "LumiFromL0DU/LumiCountET",
  // try to write other/new bank   (TEMP)
  "LumiCountTracks/LumiCountVeloTwo",
  "DummyLumiAlley/HltDummyCount"
};

// *************************************************
// filter to get backward tracks (always pass)
HltBWRZVeloSequence.Members += { 
  "HltTrackPrepare/HltPrepareBWRZVelo",
  "DummyLumiAlley/HltDummyBWRZVelo"
};

// *************************************************
// container sequence (just to make sure it doesn't block)
Hlt1LumiBXTypesSequence.Members = {
  // sequences depending on Odin BX types
  "GaudiSequencer/Hlt1LumiBeamCrossingSequence",
  "GaudiSequencer/Hlt1LumiNoBeamSequence",
  "DummyLumiAlley/HltDummyBXType"
};

// *************************************************
// place for histograms with NoBeam condition
Hlt1LumiNoBeamSequence.Members = {
  "OdinTypesFilter/FilterNoBeam",
  "HltLumiOdinReader/OdinReaderNoBeam"
};

// place for histograms with BeamCrossing condition
Hlt1LumiBeamCrossingSequence.Members = {
  "OdinTypesFilter/FilterBeamCrossing",
  "HltLumiOdinReader/OdinReaderBeamCrossing"
};


//-------------------------------------------------------------------------
// HLT LumiAlley options
//-------------------------------------------------------------------------
Hlt1LumiRecoSequence.ModeOr = true;         // should always pass
Hlt1LumiRecoSequence.ShortCircuit = false;  // execute the last always
Hlt1LumiRecoSequence.MeasureTime = true;
Hlt1LumiRecoSequence.OutputLevel=3;

Hlt1LumiPreRecoSequence.MeasureTime = true;
Hlt1LumiPreRecoSequence.OutputLevel=3;

HltLumiCountSequence.ModeOr = true;         // should always pass
HltLumiCountSequence.ShortCircuit = false;  // execute the last always
HltLumiCountSequence.MeasureTime = true;
HltLumiCountSequence.OutputLevel=3;

LumiCountVelo.OutputLevel=2;
LumiCountVelo.InputSelection="Hlt/Track/Velo";
LumiCountVelo.CounterName="Velo";
LumiCountVelo.OutputContainer="Hlt/LumiSummary";

LumiCountRZVelo.OutputLevel=2;
LumiCountRZVelo.InputSelection="Hlt/Track/RZVelo";
LumiCountRZVelo.CounterName="RZVelo";
LumiCountRZVelo.OutputContainer="Hlt/LumiSummary";

HltBWRZVeloSequence.MeasureTime = true;
HltBWRZVeloSequence.ModeOr = true;         // should always pass

HltPrepareBWRZVelo.InputSelection   = "Hlt/Track/RZVelo";
HltPrepareBWRZVelo.AddInfo = false;
HltPrepareBWRZVelo.FilterDescriptor = {"IsBackward,>,0.5"};
HltPrepareBWRZVelo.OutputSelection     = "BWRZVelo";

LumiCountHltBWRZVelo.OutputLevel=2;
LumiCountHltBWRZVelo.InputSelection="BWRZVelo";
LumiCountHltBWRZVelo.CounterName="RZVeloBW";
LumiCountHltBWRZVelo.OutputContainer="Hlt/LumiSummary";

LumiCountMuon.OutputLevel=2;
LumiCountMuon.InputSelection="Rec/Track/Muons";
LumiCountMuon.CounterName="Muon";
LumiCountMuon.OutputContainer="Hlt/LumiSummary";

LumiCountPV2D.OutputLevel=2;
LumiCountPV2D.InputSelection="Hlt/Vertex/PV2D";
LumiCountPV2D.CounterName="PV2D";
LumiCountPV2D.OutputContainer="Hlt/LumiSummary";

LumiCountPV3D.OutputLevel=2;
LumiCountPV3D.InputSelection="Hlt/Vertex/PV3D";
LumiCountPV3D.CounterName="PV3D";
LumiCountPV3D.OutputContainer="Hlt/LumiSummary";

LumiCountSpd.OutputLevel=2;
LumiCountSpd.InputSelection="Trig/L0/L0DUReport";
LumiCountSpd.CounterName="SPD";
LumiCountSpd.ValueName="Spd(Mult)";
LumiCountSpd.OutputContainer="Hlt/LumiSummary";

LumiCountPU.OutputLevel=2;
LumiCountPU.InputSelection="Trig/L0/L0DUReport";
LumiCountPU.CounterName="PUMult";
LumiCountPU.ValueName="PUHits(Mult)";
LumiCountPU.OutputContainer="Hlt/LumiSummary";

LumiCountET.OutputLevel=2;
LumiCountET.InputSelection="Trig/L0/L0DUReport";
LumiCountET.CounterName="Calo";
LumiCountET.ValueName="Sum(Et)";
LumiCountET.OutputContainer="Hlt/LumiSummary";

LumiCountVeloTwo.OutputLevel=2;
LumiCountVeloTwo.InputSelection="Hlt/Track/Velo";
LumiCountVeloTwo.CounterName="Velo";
LumiCountVeloTwo.OutputContainer="Hlt/LumiSummaryTwo";

Hlt1LumiBXTypesSequence.ModeOr = true;         // should always pass
Hlt1LumiBXTypesSequence.ShortCircuit = false;  // execute the last always
Hlt1LumiBXTypesSequence.MeasureTime = true;
Hlt1LumiBXTypesSequence.OutputLevel=3;

FilterNoBeam.BXTypes={"NoBeam"};
OdinReaderNoBeam.OutputLevel=3;
Hlt1LumiNoBeamSequence.MeasureTime = true;
Hlt1LumiNoBeamSequence.OutputLevel=3;

FilterBeamCrossing.BXTypes={"BeamCrossing"};
OdinReaderBeamCrossing.OutputLevel=3;
Hlt1LumiBeamCrossingSequence.MeasureTime = true;
Hlt1LumiBeamCrossingSequence.OutputLevel=3;

//CollectLumiData.OutputLevel=3;
HltLumiOdinReader.OutputLevel=3;

OdinTypesFilter.OutputLevel=3;
//OdinTypesFilter.TriggerTypes="ALL";
//OdinTypesFilter.TriggerTypes={"Reserve","PhysicsTrigger","RandomTrigger","TimingTrigger","CalibrationTrigger"};
OdinTypesFilter.TriggerTypes={"Reserve"};  // should become "Random"
OdinTypesFilter.BXTypes={"NoBeam","BeamCrossing","SingleBeamRight","SingleBeamLeft"};

PrescaleLumiDecision.AcceptFraction=0.5;
PrescaleLumiDecision2.AcceptFraction=0.5;

Hlt1LumiAlleySequence.MeasureTime = true;
Hlt1LumiAlleySequence.OutputLevel=3;

HltLumiFillRawBuffer.OutputLevel=1;

//-------------------------------------------------------------------------
// HLT Hlt1LumiDecision is empty to always pass
//-------------------------------------------------------------------------
Hlt1LumiDecision.OutputLevel=3;

// // L0 entry: random prescaler
// LumiEntry.L0Channels = {"Random"};
// LumiEntry.OutputLevel=3;

