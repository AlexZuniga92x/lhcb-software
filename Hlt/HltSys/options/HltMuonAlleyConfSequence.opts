#include "$HLTSYSROOT/options/TsaTool.opts"

HltSummaryWriter.Save += {
"MuonTriggerSingle",
"MuonTriggerSingleNoIP",
//"MuonTriggerDiMuon",
//"MuonTriggerIPDiMuon",
"MuonTriggerPureDiMuon",
"MuonTriggerPureIPDiMuon",
"DimuonFromL0SingleWithIP",
"DimuonFromL0SingleNoIP",
"DimuonFromL0SingleAndMuonSegWithIP",
"DimuonFromL0SingleAndMuonSegNoIP",
"MuonAndTVelo" ,
"DiMuonAndTVelo",
"MuonAndTVeloFromMuonSeg",
"MuonAndTVeloForDimuonFromL0Single"
};

HltMuonAlley.MeasureTime=true;

HltMuonAlley.Members = {  
  "HltSequencer/EnterMuonAlley",
  "HltSequencer/RealMuonAlley"
};

EnterMuonAlley.Members = {
"L0Entry/L0MuonEntry"
// ,"L0MuonCandidatesFromRaw"   moved to HltL0TriggerSequence
};
L0MuonEntry.L0ChannelsName = {"muon" ,"muonnoglob", "dimuon"};
L0MuonEntry.SelectionName = "L0MuonEntry";
//L0MuonEntry.OutputLevel=3;


RealMuonAlley.Members = {
"HltSequencer/HltSingleL0MuonAlleyTConf"
, "HltSequencer/HltDiMuonAlleyTConf"
};
RealMuonAlley.MeasureTime=true;
RealMuonAlley.ModeOr = true;

HltSingleL0MuonAlleyTConf.MeasureTime=true;
HltSingleL0MuonAlleyTConf.Members = {
  "L0Entry/L0SingleMuonEntry",
  "HltSequencer/HltL0SingleMuonPreparation",
  "SpaceMuonMatch/SpaceMuonMatchForL0Single",
  "HltSequencer/HltMuonTConfL0SingleTrigger"
 };

HltL0SingleMuonPreparation.MeasureTime=true;
HltL0SingleMuonPreparation.Members = { 
          "HltTrackFilter/FilterL0SingleMuonsByPt",
          "GaudiSequencer/HltDecodeT",
          "GaudiSequencer/HltDecodeTT",
          "HltTrackUpgrade/L0MuonSingleTConf" , 
          "GaudiSequencer/MuonRecon",
          "HltTrackFilter/TTrackAndDistCutL0Single" ,
          //         "TTrackAndDistCut/TTrackAndDistCutL0Single" ,
          "GaudiSequencer/HltRecoVeloRZSeq",
          "RZMuonMatch/RZMuonMatchForL0Single",
          "HltTrackUpgrade/HltMuonTConfL0SingleRecoVeloSpace"
};

MuonRecon.Members={"MuonRec"};

HltMuonTConfL0SingleTrigger.ModeOr = true;
HltMuonTConfL0SingleTrigger.Members = {
  "HltTrackFilter/MuonTConfL0SingleTriggerSingle"
 ,"HltTrackFilter/MuonTConfL0SingleTriggerSingleNoIP"
};


HltL0DiMuonConfAlley.ModeOr = true;
HltDiMuonAlleyTConf.Members = { 
 "HltSequencer/HltDiMuonFromL0DiMuon",
 "HltSequencer/HltDiMuonFromSingleL0"
 ,"HltSequencer/HltDiMuonFromSingleL0AndMuonSeg"
};



HltDiMuonFromL0DiMuon.MeasureTime=true;
HltDiMuonFromL0DiMuon.Members = { 
              "L0Entry/L0DimuonEntry",
              "HltVertexMaker/VertexFromL0Dimuon",
              "HltVertexToTracks/L0Vertex2Tracks",
              "GaudiSequencer/HltDecodeT",
              "GaudiSequencer/HltDecodeTT",
              "HltTrackUpgrade/L0MuonDimuonTConf",
              "GaudiSequencer/MuonRecon", 
              "TTrackAndDistCut/TTrackAndDistCutL0Dimuon",
              "GaudiSequencer/HltRecoVeloRZSeq",
              "RZMuonMatch/RZMuonMatchForL0Dimuon",
              "HltTrackUpgrade/HltMuonTConfL0DimuonRecoVeloSpace",
              "SpaceMuonMatch/SpaceMuonMatchForL0Dimuon",
              "HltVertexMaker/VertexOfSpaceMuonMatchForL0Dimuon",
              "HltVertexFilter/PureL0Dimuons",
              "HltSequencer/HltMuonTConfL0DimuonTrigger"
};


HltMuonTConfL0DimuonTrigger.ModeOr = true;
HltMuonTConfL0DimuonTrigger.Members = {
   "HltVertexFilter/HltMuonTConfL0DimuonTriggerDiMuonsNoIP",
   "HltVertexFilter/HltMuonTConfL0DimuonTriggerDiMuonsWithIP"
};

HltDiMuonFromSingleL0.MeasureTime=true;
HltDiMuonFromSingleL0.Members = {
   "L0Entry/L0SingleMuonEntry",
   "HltSequencer/HltL0SingleMuonPreparation",
   "SpaceMuonMatch/SpaceMuonMatchForDimuonFromL0Single",
   "HltVertexMaker/VertexFromL0Single"
  , "HltSequencer/TriggerFromTwoSingleL0"
};

TriggerFromTwoSingleL0.ModeOr = true;
TriggerFromTwoSingleL0.Members = {
   "HltVertexFilter/DimuonFromL0SingleWithIP",
   "HltVertexFilter/DimuonFromL0SingleNoIP"
};


HltDiMuonFromSingleL0AndMuonSeg.MeasureTime=true;
HltDiMuonFromSingleL0AndMuonSeg.Members = {
   "L0Entry/L0SingleMuonEntry"
  , "HltSequencer/HltMuonSegPreparation" 
   ,"SpaceMuonMatch/SpaceMuonMatchForMuonSeg"
   ,"HltVertexMaker/VertexFromL0SingleAndMuonSeg"

   , "HltSequencer/TriggerFromOneL0OneMuonSegment"  

};

HltMuonSegPreparation.Members = {
  "HltSelectionEntry/MuonSegEntry"
  ,"HltMuonRec/MuonTrackRecForL0Single"
  ,"HltTrackFilter/FilterMuonSegments"
  //,"FilterMuonSegments"
  ,"HltPrepareMuonSeg"
  ,"GaudiSequencer/HltDecodeT"
  ,"GaudiSequencer/HltDecodeTT"
  ,"HltTrackUpgrade/MuonSegmentTConf"
  ,"TTrackAndDistCut/MuonSegmentAndDistCut" 
  ,"RZMuonMatch/RZMuonMatchForMuonSeg"
  ,"HltTrackUpgrade/HltRecoVeloSpaceForMuonSeg"
};

TriggerFromOneL0OneMuonSegment.ModeOr = true;
TriggerFromOneL0OneMuonSegment.Members = {
   "HltVertexFilter/DimuonFromL0SingleAndMuonSegWithIP",
   "HltVertexFilter/DimuonFromL0SingleAndMuonSegNoIP"
};





//--------------- L0 single muon condition


L0SingleMuonEntry.L0ChannelsName = {"muon" ,"muonnoglob"};
L0SingleMuonEntry.SelectionName = "MuonEntry";
L0SingleMuonEntry.OutputLevel=3;


FilterL0SingleMuonsByPt.InputTracksName ="L0TriggerAllMuons";
FilterL0SingleMuonsByPt.OutputTracksName = "L0MuonSingle";
FilterL0SingleMuonsByPt.FilterDescriptor = {"PT,>,1300"};

L0MuonSingleTConf.RecoName = "TConf";
L0MuonSingleTConf.InputTracksName = "L0MuonSingle";
L0MuonSingleTConf.OutputTracksName = "L0MuonConfirmedWithT";

 
TTrackAndDistCutL0Single.InputTracksName = "L0MuonConfirmedWithT";
TTrackAndDistCutL0Single.FilterDescriptor = {"MuonIDDistance,<,100."};
TTrackAndDistCutL0Single.OutputTracksName = "L0MuonAndTConfirmed";
TTrackAndDistCutL0Single.OutputLevel = 3;


RZMuonMatchForL0Single.InputTracksName = "L0MuonAndTConfirmed";
RZMuonMatchForL0Single.InputTracks2Name = "RZVelo";
RZMuonMatchForL0Single.OutputTracksName = "RZMuon";
RZMuonMatchForL0Single.OutputLevel=3;

HltMuonTConfL0SingleRecoVeloSpace.InputTracksName = "RZMuon";
HltMuonTConfL0SingleRecoVeloSpace.OutputTracksName = "VeloMuonConf";
HltMuonTConfL0SingleRecoVeloSpace.RecoName = "Velo";

SpaceMuonMatchForL0Single.InputTracksName =    "VeloMuonConf";
SpaceMuonMatchForL0Single.InputTracks2Name =  "L0MuonAndTConfirmed";
SpaceMuonMatchForL0Single.OutputMuonTracksName ="MuonVelo";	
SpaceMuonMatchForL0Single.OutputTracksName ="MuonAndTVelo";



MuonTConfL0SingleTriggerSingle.InputTracksName ="MuonAndTVelo";
MuonTConfL0SingleTriggerSingle.PrimaryVerticesName = "PV2D";
MuonTConfL0SingleTriggerSingle.OutputTracksName = "MuonTriggerSingle";
//MuonTConfL0SingleTriggerSingle.FilterDescriptor = {"IP,||[],0.15,30.",
//                                       "PT,>,3000"
MuonTConfL0SingleTriggerSingle.FilterDescriptor = {"IP,||[],0.08,30.",
                                      "PT,>,1300"
};
//MuonTConfL0SingleTriggerSingle.FilterDescriptor += {"FlagL0Candidate,=,1"};


MuonTConfL0SingleTriggerSingleNoIP.InputTracksName ="MuonAndTVelo";
MuonTConfL0SingleTriggerSingleNoIP.OutputTracksName = "MuonTriggerSingleNoIP";
MuonTConfL0SingleTriggerSingleNoIP.FilterDescriptor = {"PT,>,6000"};
//MuonTConfL0SingleTriggerSingleNoIP.FilterDescriptor += {"FlagL0Candidate,=,1"};


//-------------- L0 dimuon conditions ---------------------------
L0DimuonEntry.L0ChannelsName = {"dimuon"};
L0DimuonEntry.SelectionName = "DiMuonEntry";


VertexFromL0Dimuon.InputTracksName    = "L0TriggerAllMuons";
//VertexFromL0Dimuon.InputTracks2Name   = "L0TriggerAllMuons";
VertexFromL0Dimuon.OutputVerticesName = "L0TriggerDiMuon";
VertexFromL0Dimuon.FilterDescriptor = {"SumPT,>,1500."};

L0Vertex2Tracks.InputVerticesName="L0TriggerDiMuon";
L0Vertex2Tracks.OutputTracksName="L0MuonDimuon";


L0MuonDimuonTConf.RecoName = "TConf";
L0MuonDimuonTConf.InputTracksName = "L0MuonDimuon";
L0MuonDimuonTConf.OutputTracksName="DiMuonConfirmedWithT";



TTrackAndDistCutL0Dimuon.InputTracksName = "DiMuonConfirmedWithT";
TTrackAndDistCutL0Dimuon.OutputTracksName = "DiMuonAndTConfirmed";

RZMuonMatchForL0Dimuon.InputTracksName = "DiMuonAndTConfirmed";
RZMuonMatchForL0Dimuon.InputTracks2Name = "RZVelo";
RZMuonMatchForL0Dimuon.OutputTracksName = "RZDiMuon";
RZMuonMatchForL0Dimuon.OutputLevel=3;

HltMuonTConfL0DimuonRecoVeloSpace.InputTracksName = "RZDiMuon";
HltMuonTConfL0DimuonRecoVeloSpace.OutputTracksName = "VeloDiMuonConf";
HltMuonTConfL0DimuonRecoVeloSpace.RecoName = "Velo";

SpaceMuonMatchForL0Dimuon.InputTracksName =    "VeloDiMuonConf";
SpaceMuonMatchForL0Dimuon.InputTracks2Name =  "DiMuonAndTConfirmed";
SpaceMuonMatchForL0Dimuon.OutputMuonTracksName ="DiMuonVelo";	
SpaceMuonMatchForL0Dimuon.OutputTracksName ="DiMuonAndTVelo";	

VertexOfSpaceMuonMatchForL0Dimuon.InputTracksName    = "DiMuonAndTVelo";
VertexOfSpaceMuonMatchForL0Dimuon.OutputVerticesName = "DiMuonAndTVeloVertices";
VertexOfSpaceMuonMatchForL0Dimuon.FilterDescriptor   = {"DOCA,<,0.5"};

//Still need to check against "Hlt/Vertex/L0TriggerDiMuon";

PureL0Dimuons.InputVerticesName    = "DiMuonAndTVeloVertices";
PureL0Dimuons.PrimaryVerticesName  = "L0TriggerDiMuon"; // Just a trick
PureL0Dimuons.OutputVerticesName = "PureL0Dimuons";
PureL0Dimuons.FilterDescriptor   = {"VertexMatchIDsFraction,>,1.9"};
PureL0Dimuons.OutputLevel = 3;


HltMuonTConfL0DimuonTriggerDiMuonsNoIP.OutputVerticesName="MuonTriggerPureDiMuon";
HltMuonTConfL0DimuonTriggerDiMuonsNoIP.PrimaryVerticesName = "PV2D";
HltMuonTConfL0DimuonTriggerDiMuonsNoIP.InputVerticesName = "DiMuonAndTVeloVertices";
HltMuonTConfL0DimuonTriggerDiMuonsNoIP.FilterDescriptor = {"VertexDimuonMass,>,2500."};


HltMuonTConfL0DimuonTriggerDiMuonsWithIP.OutputVerticesName="MuonTriggerPureIPDiMuon";
HltMuonTConfL0DimuonTriggerDiMuonsWithIP.InputVerticesName = "DiMuonAndTVeloVertices";
HltMuonTConfL0DimuonTriggerDiMuonsWithIP.PrimaryVerticesName = "PV2D";
HltMuonTConfL0DimuonTriggerDiMuonsWithIP.FilterDescriptor = {"VertexDimuonMass,>,500.",
                                                             "VertexMinIP,||>,0.05"};

//=========Configuration for dimuons from L0single
SpaceMuonMatchForDimuonFromL0Single.InputTracksName =    "VeloMuonConf";
SpaceMuonMatchForDimuonFromL0Single.InputTracks2Name =  "L0MuonAndTConfirmed";
SpaceMuonMatchForDimuonFromL0Single.OutputMuonTracksName ="MuonVeloForDimuonFromL0Single";
SpaceMuonMatchForDimuonFromL0Single.OutputTracksName ="MuonAndTVeloForDimuonFromL0Single";

VertexFromL0Single.InputTracksName    = "MuonAndTVeloForDimuonFromL0Single";
//VertexFromL0Single.InputTracks2Name   = "MuonAndTVeloForDimuonFromL0Single";
VertexFromL0Single.OutputVerticesName = "DimuonFromL0Single";
VertexFromL0Single.FilterDescriptor = {"DOCA,<,0.5"};


DimuonFromL0SingleWithIP.InputVerticesName = "DimuonFromL0Single";
DimuonFromL0SingleWithIP.PrimaryVerticesName = "PV2D";
DimuonFromL0SingleWithIP.OutputVerticesName = "DimuonFromL0SingleWithIP";
DimuonFromL0SingleWithIP.FilterDescriptor = {"VertexDimuonMass,>,500.",
                                             "VertexMinIP,||>,0.05"};

DimuonFromL0SingleNoIP.InputVerticesName = "DimuonFromL0Single";
DimuonFromL0SingleNoIP.OutputVerticesName = "DimuonFromL0SingleNoIP";
DimuonFromL0SingleNoIP.FilterDescriptor = {"VertexDimuonMass,>,2500."};

//=========Configuration for dimuons from One L0 and One muon segment
MuonSegEntry.Selections = {"MuonAndTVelo"};

MuonTrackRecForL0Single.OutputMuonTracksName="MuonSegmentForL0Single";
MuonTrackRecForL0Single.OutputTracksName = "MuonTForL0Single";
MuonTrackRecForL0Single.DecodingFromCoord=true;
MuonTrackRecForL0Single.SelectionName="MuonTRecForL0Single";


// WITH CARE: if you use the FilterMuonSegmets algo, the order
// ot the input tracks [1-2], is the other way around!!
FilterMuonSegments.InputTracksName = "MuonTForL0Single";
FilterMuonSegments.InputTracks2Name = "L0MuonConfirmedWithT";
FilterMuonSegments.FilterDescriptor = {"DoShareM3,<,0.5"};
FilterMuonSegments.OutputTracksName = "FilteredMuonSegments";
FilterMuonSegments.OutputLevel = 3;


HltPrepareMuonSeg.InputTracksName = "FilteredMuonSegments";
HltPrepareMuonSeg.OutputTracksName = "PreparedMuonSegments";
//HltPrepareMuonSeg.OutputLevel =2;

MuonSegmentTConf.RecoName = "TConf";
MuonSegmentTConf.InputTracksName = "PreparedMuonSegments";
MuonSegmentTConf.OutputTracksName = "MuonTConfirmedWithT";
//MuonSegmentTConf.OutputLevel =2;

MuonSegmentAndDistCut.PassPeriod = 1;
MuonSegmentAndDistCut.InputTracksName = "MuonTConfirmedWithT";
MuonSegmentAndDistCut.OutputTracksName = "MuonTAndTConfirmed";

RZMuonMatchForMuonSeg.InputTracksName = "MuonTAndTConfirmed";
RZMuonMatchForMuonSeg.InputTracks2Name = "RZVelo";
RZMuonMatchForMuonSeg.OutputTracksName = "RZMuonSeg";

HltRecoVeloSpaceForMuonSeg.InputTracksName = "RZMuonSeg";
HltRecoVeloSpaceForMuonSeg.OutputTracksName = "VeloMuonFromMuonSeg";
HltRecoVeloSpaceForMuonSeg.RecoName = "Velo";


SpaceMuonMatchForMuonSeg.InputTracksName = "VeloMuonFromMuonSeg";
SpaceMuonMatchForMuonSeg.InputTracks2Name = "MuonTAndTConfirmed";
SpaceMuonMatchForMuonSeg.OutputTracksName = "MuonAndTVeloFromMuonSeg";
SpaceMuonMatchForMuonSeg.OutputMuonTracksName ="MuonVeloFromMuonSeg";

VertexFromL0SingleAndMuonSeg.InputTracksName = "MuonAndTVeloForDimuonFromL0Single";
VertexFromL0SingleAndMuonSeg.InputTracks2Name   = "MuonAndTVeloFromMuonSeg";
VertexFromL0SingleAndMuonSeg.OutputVerticesName = "DimuonFromL0SingleAndMuonSeg";
VertexFromL0SingleAndMuonSeg.FilterDescriptor = {"DOCA,<,0.5"};

DimuonFromL0SingleAndMuonSegWithIP.InputVerticesName = "DimuonFromL0SingleAndMuonSeg";
DimuonFromL0SingleAndMuonSegWithIP.PrimaryVerticesName = "PV2D";
DimuonFromL0SingleAndMuonSegWithIP.OutputVerticesName = "DimuonFromL0SingleAndMuonSegWithIP";
DimuonFromL0SingleAndMuonSegWithIP.FilterDescriptor = {"VertexDimuonMass,>,500.",
                                                       "VertexMinIP,||>,0.05"};


DimuonFromL0SingleAndMuonSegNoIP.InputVerticesName = "DimuonFromL0SingleAndMuonSeg";
DimuonFromL0SingleAndMuonSegNoIP.OutputVerticesName = "DimuonFromL0SingleAndMuonSegNoIP";
DimuonFromL0SingleAndMuonSegNoIP.FilterDescriptor = {"VertexDimuonMass,>,2500."};


