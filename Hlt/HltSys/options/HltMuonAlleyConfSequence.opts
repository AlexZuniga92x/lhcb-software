#include "$HLTSYSROOT/options/TsaTool.opts"

// to write in the summary
HltSummaryWriter.Save += {
  "MuonTriggerSingle",
  "MuonTriggerSingleNoIP",
  "MuonTriggerDiMuon",
  "MuonTriggerIPDiMuon",
  "MuonTriggerPureDiMuon",
  "MuonTriggerPureIPDiMuon",
  "MuonAndTVelo",
  "DiMuonAndTVelo",
  "MuonAndTVeloFromMuonSeg"
};



// to declare as input for the OR of the muon alley
HltAlleys.InputSelections += {
  "MuonTriggerSingle",
  "MuonTriggerSingleNoIP",
  "MuonTriggerPureDiMuon",
  "MuonTriggerPureIPDiMuon",
  "MuonTriggerIPDiMuon2L0",
  "MuonTriggerDiMuon2L0",
  "MuonTriggerIPDiMuonMuonSeg",
  "MuonTriggerDiMuonMuonSeg"
};


HltMuonAlleySequence.Members = {  
  "GaudiSequencer/HltSingleMuonIPandPT",
  "GaudiSequencer/HltSingleMuonNoIP",
  "GaudiSequencer/HltDiMuonFrom2L0NoIP",
  "GaudiSequencer/HltDiMuonFrom2L0IP",
  "GaudiSequencer/HltDiMuonFromMuonSegNoIP",
  "GaudiSequencer/HltDiMuonFromMuonSegIP",
  "GaudiSequencer/HltDiMuonFromL0DiMuonNoIP",
  "GaudiSequencer/HltDiMuonFromL0DiMuonIP",
  "HltSelectionFilter/HltMuonSingleAlleys",
  "HltSelectionFilter/HltMuonAlleys",
  "HltSelectionFilter/HltDiMuonAlleys",  
  "HltSelectionFilter/HltDiMuonAlleysNoIP",
  "HltSelectionFilter/HltDiMuonAlleysIP"
};
HltMuonAlleySequence.ModeOR=true;
HltMuonAlleySequence.ShortCircuit=false;
HltMuonAlleySequence.MeasureTime=true;

HltMuonSingleAlleys.InputSelections = {
  "MuonTriggerSingle",
  "MuonTriggerSingleNoIP"
};

HltMuonAlleys.InputSelections = {
  "MuonTriggerSingle",
  "MuonTriggerSingleNoIP",
  "MuonTriggerPureDiMuon",
  "MuonTriggerPureIPDiMuon",
  "MuonTriggerIPDiMuon2L0",
  "MuonTriggerDiMuon2L0",
  "MuonTriggerIPDiMuonMuonSeg",
  "MuonTriggerDiMuonMuonSeg"
};


HltDiMuonAlleys.InputSelections = {
  "MuonTriggerPureDiMuon",
  "MuonTriggerPureIPDiMuon",
  "MuonTriggerIPDiMuon2L0",
  "MuonTriggerDiMuon2L0",
  "MuonTriggerIPDiMuonMuonSeg",
  "MuonTriggerDiMuonMuonSeg"
};

HltDiMuonAlleysNoIP.InputSelections = {
  "MuonTriggerPureDiMuon",
  "MuonTriggerDiMuon2L0",
  "MuonTriggerDiMuonMuonSeg"
};

HltDiMuonAlleysIP.InputSelections = {
  "MuonTriggerPureIPDiMuon",
  "MuonTriggerIPDiMuon2L0",
  "MuonTriggerIPDiMuonMuonSeg"
};
//-------------------------------
//   SINGLE MUON ALLEY
//-------------------------------

HltSingleMuonIPandPT.Members = {
  "GaudiSequencer/HltL0SingleMuonPreparation",
  "HltTrackFilter/MuonTriggerSingle"
 };

HltSingleMuonNoIP.Members = {
  "GaudiSequencer/HltL0SingleMuonPreparation",
  "HltTrackFilter/MuonTriggerSingleNoIP"
};


MuonTriggerSingle.InputSelection ="MuonAndTVelo";
MuonTriggerSingle.FilterDescriptor = {
  "IP_PV2D,||[],0.08,30.",
  "PT,>,1300"
};
MuonTriggerSingle.OutputLevel = 3;


MuonTriggerSingleNoIP.InputSelection ="MuonAndTVelo";
MuonTriggerSingleNoIP.FilterDescriptor = {"PT,>,6000"};
MuonTriggerSingleNoIP.OutputLevel = 3;


//---- L0 muon single preparation


HltL0SingleMuonPreparation.MeasureTime=true;
HltL0SingleMuonPreparation.Members = { 
  "L0Entry/MuonEntry",
  "HltTrackFilter/L0MuonSingle",
  "GaudiSequencer/HltDecodeT",
  "HltTrackUpgrade/L0MuonConfirmedWithT" , 
  "GaudiSequencer/MuonRecon",
  "HltTrackFilter/L0MuonAndTConfirmed",
  "GaudiSequencer/HltRecoVeloRZSeq",
  "HltTrackFilter/RZMuon",
  "HltTrackUpgrade/VeloMuonConf",
  "HltTrackMatch/MuonAndTVelo"
};

MuonRecon.Members={"MuonRec"};


//--------------------------
// options of the muon alley
//--------------------------

MuonEntry.L0ChannelsName = {"Muon" ,"MuonNoGlob"};
MuonEntry.OutputLevel = 3;

L0MuonSingle.InputSelection ="L0AllMuons";
L0MuonSingle.FilterDescriptor = {"PT0,||>,1300"};
L0MuonSingle.OutputLevel = 3;

L0MuonConfirmedWithT.InputSelection = "L0MuonSingle";
L0MuonConfirmedWithT.RecoName = "TConf";
L0MuonConfirmedWithT.OutputLevel = 3;
 
L0MuonAndTConfirmed.InputSelection = "L0MuonConfirmedWithT";
L0MuonAndTConfirmed.FilterDescriptor = {"IsMuon,>,0."};
L0MuonAndTConfirmed.OutputLevel = 3;

RZMuon.InputSelection = "RZVelo";
RZMuon.FilterDescriptor = {"RZVeloTMatch_L0MuonAndTConfirmed,||<,80."};
RZMuon.OutputLevel = 3;

VeloMuonConf.InputSelection = "RZMuon";
VeloMuonConf.RecoName = "Velo";
VeloMuonConf.OutputLevel = 3;

MuonAndTVelo.InputSelection =    "VeloMuonConf";
MuonAndTVelo.InputTracks2Name =  "L0MuonAndTConfirmed";
MuonAndTVelo.MatchName = "VeloT";
MuonAndTVelo.OutputLevel = 3;


//----------------------------
// DIMUON ALLEY from L0Dimuon
//----------------------------

HltDiMuonFromL0DiMuonNoIP.MeasureTime=true;
HltDiMuonFromL0DiMuonNoIP.Members = {
  "GaudiSequencer/HltDiMuonFromL0DiMuonPreparation",
  "HltVertexFilter/MuonTriggerPureDiMuon"
};

HltDiMuonFromL0DiMuonIP.MeasureTime=true;
HltDiMuonFromL0DiMuonIP.Members = {
  "GaudiSequencer/HltDiMuonFromL0DiMuonPreparation",
  "HltVertexFilter/MuonTriggerPureIPDiMuon"
};

HltDiMuonFromL0DiMuonPreparation.MeasureTime=true;
HltDiMuonFromL0DiMuonPreparation.Members = { 
  "L0Entry/L0DimuonEntry",
  "HltVertexMaker/L0TriggerDiMuon",
  "HltVertexToTracks/L0MuonDimuon",
  "GaudiSequencer/HltDecodeT",
  "HltTrackUpgrade/DiMuonConfirmedWithT",
  "GaudiSequencer/MuonRecon", 
  "HltTrackFilter/DiMuonAndTConfirmed",
  "GaudiSequencer/HltRecoVeloRZSeq",
  "HltTrackFilter/RZDiMuon",
  "HltTrackUpgrade/VeloDiMuonConf",
  "HltTrackMatch/DiMuonAndTVelo",
  "HltVertexMaker/DiMuonAndTVeloVertices",
  "HltVertexFilter/PureL0Dimuons"
};


L0DimuonEntry.L0ChannelsName = {"DiMuon"};
L0DimuonEntry.OutputLevel = 3;


L0MuonDimuon.InputSelection ="L0TriggerDiMuon";
L0MuonDimuon.OutputLevel = 3;

DiMuonConfirmedWithT.InputSelection = "L0MuonDimuon";
DiMuonConfirmedWithT.RecoName = "TConf";
DiMuonConfirmedWithT.OutputLevel = 3;

DiMuonAndTConfirmed.InputSelection = "DiMuonConfirmedWithT";
DiMuonAndTConfirmed.FilterDescriptor = {"IsMuon,>,0."};
DiMuonAndTConfirmed.OutputLevel = 3;

RZDiMuon.InputSelection = "RZVelo";
RZDiMuon.FilterDescriptor = {"RZVeloTMatch_DiMuonAndTConfirmed,||<,80."};
RZDiMuon.OutputLevel = 3;

VeloDiMuonConf.InputSelection = "RZDiMuon";
VeloDiMuonConf.RecoName = "Velo";
VeloDiMuonConf.OutputLevel = 3;

DiMuonAndTVelo.InputSelection =    "VeloDiMuonConf";
DiMuonAndTVelo.InputSelection2 =  "DiMuonAndTConfirmed";
DiMuonAndTVelo.MatchName = "VeloT";
DiMuonAndTVelo.OutputLevel = 3;

DiMuonAndTVeloVertices.InputSelection = "DiMuonAndTVelo";
DiMuonAndTVeloVertices.FilterDescriptor   = {"DOCA,<,0.5"};
DiMuonAndTVeloVertices.OutputLevel = 3;

PureL0Dimuons.InputSelection    = "DiMuonAndTVeloVertices";
PureL0Dimuons.FilterDescriptor   = {
  "VertexMatchIDsFraction_L0TriggerDiMuon,>,1.9"};
PureL0Dimuons.OutputLevel = 3;

MuonTriggerPureDiMuon.InputSelection = "PureL0Dimuons";
MuonTriggerPureDiMuon.FilterDescriptor = {"VertexDimuonMass,>,2500."};
MuonTriggerPureDiMuon.OutputLevel = 3;

MuonTriggerPureIPDiMuon.InputSelection = "PureL0Dimuons";
MuonTriggerPureIPDiMuon.FilterDescriptor = { 
  "VertexDimuonMass,>,500.",
  "VertexMinIP_PV2D,||>,0.05"
};
MuonTriggerPureIPDiMuon.OutputLevel = 3;


//-----------------------------------------------------
// DIMUON ALLEY : from L0Muon + L0Muon
//-----------------------------------------------------



HltDiMuonFrom2L0IP.MeasureTime=true;
HltDiMuonFrom2L0IP.Members = {
  "GaudiSequencer/HltL0SingleMuonPreparation",
  "HltVertexMaker/DimuonFromTwoL0",
  "HltVertexFilter/MuonTriggerIPDiMuon2L0"
};

HltDiMuonFrom2L0NoIP.MeasureTime=true;
HltDiMuonFrom2L0NoIP.Members = {
  "GaudiSequencer/HltL0SingleMuonPreparation",
  "HltVertexMaker/DimuonFromTwoL0",
  "HltVertexFilter/MuonTriggerDiMuon2L0"
};

DimuonFromTwoL0.InputSelection = "MuonAndTVelo";
DimuonFromTwoL0.FilterDescriptor = {"DOCA,<,0.5"};
DimuonFromTwoL0.OutputLevel = 3;

MuonTriggerIPDiMuon2L0.InputSelection = "DimuonFromTwoL0";
MuonTriggerIPDiMuon2L0.FilterDescriptor = {"VertexDimuonMass,>,500.",
                                        "VertexMinIP_PV2D,||>,0.05"};
MuonTriggerIPDiMuon2L0.OutputLevel = 3;

MuonTriggerDiMuon2L0.InputSelection = "DimuonFromTwoL0";
MuonTriggerDiMuon2L0.FilterDescriptor = {"VertexDimuonMass,>,2500."};
MuonTriggerDiMuon2L0.OutputLevel = 3;

//-----------------------------------------------------
// DIMUON ALLEY : from L0Muon + Muon Segment
//-----------------------------------------------------

HltDiMuonFromMuonSegIP.MeasureTime=true;
HltDiMuonFromMuonSegIP.Members = {
  "GaudiSequencer/HltL0SingleMuonPreparation",
  "GaudiSequencer/HltMuonSegPreparation",
  "HltVertexMaker/DimuonFromOneL0MuonSeg",
  "HltVertexFilter/MuonTriggerIPDiMuonMuonSeg"
};

HltDiMuonFromMuonSegNoIP.MeasureTime=true;
HltDiMuonFromMuonSegNoIP.Members = {
  "GaudiSequencer/HltL0SingleMuonPreparation",
  "GaudiSequencer/HltMuonSegPreparation",
  "HltVertexMaker/DimuonFromOneL0MuonSeg",
  "HltVertexFilter/MuonTriggerDiMuonMuonSeg"
};


HltMuonSegPreparation.MeasureTime = true;
HltMuonSegPreparation.Members = {
  "HltSelectionFilter/MuonSegEntry",
  "HltMuonRec/MuonTrackRecForL0Single",
  "HltTrackPrepare/FilteredMuonSegments",
  "GaudiSequencer/HltDecodeT",
  "HltTrackUpgrade/MuonTConfirmedWithT",
  "HltTrackFilter/MuonTAndTConfirmed", 
  "HltTrackFilter/RZMuonSeg",
  "HltTrackUpgrade/VeloMuonFromMuonSeg",
  "HltTrackMatch/MuonAndTVeloFromMuonSeg"
};


MuonSegEntry.InputSelections = {"MuonAndTVelo"};
MuonSegEntry.OutputLevel = 3;

// It already Prepare the muon segments with proper error calling the tool MuonSeedTool
MuonTrackRecForL0Single.OutputMuonTracksName="Hlt/Track/MuonSegmentForL0Single";
MuonTrackRecForL0Single.DecodingFromCoord=true;
MuonTrackRecForL0Single.OutputLevel = 3;

FilteredMuonSegments.TESInputName = "Hlt/Track/MuonSegmentForL0Single";
FilteredMuonSegments.FilterDescriptor = {
  "DoShareM3_L0MuonConfirmedWithT,<,0.5"
};
FilteredMuonSegments.OutputLevel = 3;

MuonTConfirmedWithT.InputSelection = "FilteredMuonSegments";
MuonTConfirmedWithT.RecoName = "TConf";
MuonTConfirmedWithT.OutputLevel = 3;

MuonTAndTConfirmed.InputSelection = "MuonTConfirmedWithT";
MuonTAndTConfirmed.FilterDescriptor = {"IsMuon,>,0."};
MuonTAndTConfirmed.OutputLevel = 3;

RZMuonSeg.InputSelection = "RZVelo";
RZMuonSeg.FilterDescriptor = {"RZVeloTMatch_MuonTAndTConfirmed,||<,80."};
RZMuonSeg.OutputLevel = 3;

VeloMuonFromMuonSeg.InputSelection = "RZMuonSeg";
VeloMuonFromMuonSeg.RecoName = "Velo";
VeloMuonFromMuonSeg.OutputLevel = 3;

MuonAndTVeloFromMuonSeg.InputSelection = "VeloMuonFromMuonSeg";
MuonAndTVeloFromMuonSeg.InputSelection2 = "MuonTAndTConfirmed";
MuonAndTVeloFromMuonSeg.MatchName = "VeloT";
MuonAndTVeloFromMuonSeg.OutputLevel = 3;


DimuonFromOneL0MuonSeg.InputSelection = "MuonAndTVelo";
DimuonFromOneL0MuonSeg.InputSelection2   = "MuonAndTVeloFromMuonSeg";
DimuonFromOneL0MuonSeg.FilterDescriptor = {"DOCA,<,0.5"};
//If you do not set DoMergeInputs = False it will make vertices
//with 2 tracks from  InputSelection and
//one track from InputSelection and another track from InputSelection2 
DimuonFromOneL0MuonSeg.DoMergeInputs = False;
DimuonFromOneL0MuonSeg.OutputLevel = 3;


MuonTriggerIPDiMuonMuonSeg.InputSelection = "DimuonFromOneL0MuonSeg";
MuonTriggerIPDiMuonMuonSeg.FilterDescriptor = {"VertexDimuonMass,>,500.",
                                        "VertexMinIP_PV2D,||>,0.05"};
MuonTriggerIPDiMuonMuonSeg.OutputLevel = 3;

MuonTriggerDiMuonMuonSeg.InputSelection = "DimuonFromOneL0MuonSeg";
MuonTriggerDiMuonMuonSeg.FilterDescriptor = {"VertexDimuonMass,>,2500."};
MuonTriggerDiMuonMuonSeg.OutputLevel = 3;									  



