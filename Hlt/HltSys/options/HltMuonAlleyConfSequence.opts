#include "$HLTSYSROOT/options/TsaTool.opts"

// to write in the summary
HltSummaryWriter.Save += {
  "MuonTriggerSingle",
  "MuonTriggerSingleNoIP",
  "MuonTriggerDiMuon",
  "MuonTriggerIPDiMuon",
  "MuonTriggerPureDiMuon",
  "MuonTriggerPureIPDiMuon",
  "MuonAndTVelo",
  "DiMuonAndTVelo",
  "MuonAndTVeloFromMuonSeg"
};


HltSelectionToTES.Copy += {
  "MuonAndTVelo",
  "DiMuonAndTVelo",
  "MuonAndTVeloFromMuonSeg"
}; 

// to declare as input for the OR of the muon alley
HltAlleys.InputSelections += {
  "MuonTriggerSingle",
  "MuonTriggerSingleNoIP",
  "MuonTriggerDiMuon",
  "MuonTriggerIPDiMuon",
  "MuonTriggerPureDiMuon",
  "MuonTriggerPureIPDiMuon"
};


HltMuonAlleySequence.Members = {  
  "GaudiSequencer/HltSingleL0MuonAlleyTConf",
  "GaudiSequencer/HltDiMuonAlleyTConf",
  "HltSelectionFilter/HltMuonAlleys"
};
HltMuonAlleySequence.ModeOR=true;
HltMuonAlleySequence.ShortCircuit=false;
HltMuonAlleySequence.MeasureTime=true;

HltMuonAlleys.InputSelections = {
  "MuonTriggerSingle",
  "MuonTriggerSingleNoIP",
  "MuonTriggerDiMuon",
  "MuonTriggerIPDiMuon",
  "MuonTriggerPureDiMuon",
  "MuonTriggerPureIPDiMuon"
};

HltDiMuonAlleyTConf.Members = { 
  "GaudiSequencer/HltDiMuonFromL0DiMuon",
  "GaudiSequencer/HltDiMuonFromL0Single",
  "HltSelectionFilter/HltDiMuonAlleys"
};
HltDiMuonAlleyTConf.ModeOr = true;
HltDiMuonAlleyTConf.ShortCircuit = false;
HltDiMuonAlleyTConf.MeasureTime = true;

HltDiMuonAlleys.InputSelections = {
  "MuonTriggerDiMuon",
  "MuonTriggerIPDiMuon",
  "MuonTriggerPureDiMuon",
  "MuonTriggerPureIPDiMuon"
};

//-------------------------------
//   MUON ALLEY
//-------------------------------

HltSingleL0MuonAlleyTConf.MeasureTime=true;
HltSingleL0MuonAlleyTConf.Members = {
  "GaudiSequencer/HltL0SingleMuonPreparation",
  "GaudiSequencer/HltMuonTConfL0SingleTrigger",
  "HltSelectionFilter/HltMuonSingleAlleys"
 };
HltMuonSingleAlleys.InputSelections = {"MuonTriggerSingle","MuonTriggerSingleNoIP"};

HltL0SingleMuonPreparation.MeasureTime=true;
HltL0SingleMuonPreparation.Members = { 
  "L0Entry/MuonEntry",
  "HltTrackFilter/L0MuonSingle",
  "GaudiSequencer/HltDecodeT",
  "HltTrackUpgrade/L0MuonConfirmedWithT" , 
  "GaudiSequencer/MuonRecon",
  "HltTrackFilter/L0MuonAndTConfirmed",
  "GaudiSequencer/HltRecoVeloRZSeq",
  "HltTrackFilter/RZMuon",
  "HltTrackUpgrade/VeloMuonConf",
  "HltTrackMatch/MuonAndTVelo"
};

MuonRecon.Members={"MuonRec"};

HltMuonTConfL0SingleTrigger.ModeOr = true;
HltMuonTConfL0SingleTrigger.ShortCircuit = false;
HltMuonTConfL0SingleTrigger.Members = {
  "HltTrackFilter/MuonTriggerSingle"
 ,"HltTrackFilter/MuonTriggerSingleNoIP"
};

//--------------------------
// options of the muon alley
//--------------------------

MuonEntry.L0ChannelsName = {"Muon" ,"MuonNoGlob"};
MuonEntry.OutputLevel = 3;

L0MuonSingle.InputSelection ="L0AllMuons";
L0MuonSingle.FilterDescriptor = {"PT,||>,1300"};
L0MuonSingle.OutputLevel = 3;

L0MuonConfirmedWithT.InputSelection = "L0MuonSingle";
L0MuonConfirmedWithT.RecoName = "TConf";
L0MuonConfirmedWithT.OutputLevel = 3;
 
L0MuonAndTConfirmed.InputSelection = "L0MuonConfirmedWithT";
L0MuonAndTConfirmed.FilterDescriptor = {"IsMuon,>,0."};
L0MuonAndTConfirmed.OutputLevel = 3;

RZMuon.InputSelection = "RZVelo";
RZMuon.FilterDescriptor = {"RZVeloTMatch_L0MuonAndTConfirmed,<,80."};
RZMuon.OutputLevel = 3;

VeloMuonConf.InputSelection = "RZMuon";
VeloMuonConf.RecoName = "Velo";
VeloMuonConf.OutputLevel = 3;

MuonAndTVelo.InputSelection =    "VeloMuonConf";
MuonAndTVelo.InputTracks2Name =  "L0MuonAndTConfirmed";
MuonAndTVelo.MatchName = "VeloT";
MuonAndTVelo.OutputLevel = 3;

MuonTriggerSingle.InputSelection ="MuonAndTVelo";
MuonTriggerSingle.FilterDescriptor = {
  "IP_PV2D,||[],0.08,30.",
  "PT,>,1300"
};
MuonTriggerSingle.OutputLevel = 3;


MuonTriggerSingleNoIP.InputSelection ="MuonAndTVelo";
MuonTriggerSingleNoIP.FilterDescriptor = {"PT,>,6000"};
MuonTriggerSingleNoIP.OutputLevel = 3;

//----------------------------
// DIMUON ALLEY from L0Dimuon
//----------------------------


HltDiMuonFromL0DiMuon.MeasureTime=true;
HltDiMuonFromL0DiMuon.Members = { 
  "L0Entry/L0DimuonEntry",
  "HltVertexMaker/L0TriggerDiMuon",
  "HltVertexToTracks/L0MuonDimuon",
  "GaudiSequencer/HltDecodeT",
  "HltTrackUpgrade/DiMuonConfirmedWithT",
  "GaudiSequencer/MuonRecon", 
  "HltTrackFilter/DiMuonAndTConfirmed",
  "GaudiSequencer/HltRecoVeloRZSeq",
  "HltTrackFilter/RZDiMuon",
  "HltTrackUpgrade/VeloDiMuonConf",
  "HltTrackMatch/DiMuonAndTVelo",
  "HltVertexMaker/DiMuonAndTVeloVertices",
  "HltVertexFilter/PureL0Dimuons",
  "GaudiSequencer/HltMuonTConfL0DimuonTrigger"
};

HltMuonTConfL0DimuonTrigger.ModeOr = true;
HltMuonTConfL0DimuonTrigger.ShortCircuit = false;
HltMuonTConfL0DimuonTrigger.Members = {
   "HltVertexFilter/MuonTriggerPureDiMuon",
   "HltVertexFilter/MuonTriggerPureIPDiMuon"
};

L0DimuonEntry.L0ChannelsName = {"DiMuon"};
L0DimuonEntry.OutputLevel = 3;


L0MuonDimuon.InputSelection ="L0TriggerDiMuon";
L0MuonDimuon.OutputLevel = 3;

DiMuonConfirmedWithT.InputSelection = "L0MuonDimuon";
DiMuonConfirmedWithT.RecoName = "TConf";
DiMuonConfirmedWithT.OutputLevel = 3;

DiMuonAndTConfirmed.InputSelection = "DiMuonConfirmedWithT";
DiMuonAndTConfirmed.FilterDescriptor = {"IsMuon,>,0."};
DiMuonAndTConfirmed.OutputLevel = 3;

RZDiMuon.InputSelection = "RZVelo";
RZDiMuon.FilterDescriptor = {"RZVeloTMatch_DiMuonAndTConfirmed,<,80."};
RZDiMuon.OutputLevel = 3;

VeloDiMuonConf.InputSelection = "RZDiMuon";
VeloDiMuonConf.RecoName = "Velo";
VeloDiMuonConf.OutputLevel = 3;

DiMuonAndTVelo.InputSelection =    "VeloDiMuonConf";
DiMuonAndTVelo.InputSelection2 =  "DiMuonAndTConfirmed";
DiMuonAndTVelo.MatchName = "VeloT";
DiMuonAndTVelo.OutputLevel = 3;

DiMuonAndTVeloVertices.InputSelection = "DiMuonAndTVelo";
DiMuonAndTVeloVertices.FilterDescriptor   = {"DOCA,<,0.5"};
DiMuonAndTVeloVertices.OutputLevel = 3;

PureL0Dimuons.InputSelection    = "DiMuonAndTVeloVertices";
PureL0Dimuons.FilterDescriptor   = {
  "VertexMatchIDsFraction_L0TriggerDiMuon,>,1.9"};
PureL0Dimuons.OutputLevel = 3;

MuonTriggerPureDiMuon.InputSelection = "PureL0Dimuons";
MuonTriggerPureDiMuon.FilterDescriptor = {"VertexDimuonMass,>,2500."};
MuonTriggerPureDiMuon.OutputLevel = 3;

MuonTriggerPureIPDiMuon.InputSelection = "PureL0Dimuons";
MuonTriggerPureIPDiMuon.FilterDescriptor = { 
  "VertexDimuonMass,>,500.",
  "VertexMinIP_PV2D,||>,0.05"
};
MuonTriggerPureIPDiMuon.OutputLevel = 3;

//-----------------------------------------------------
// DIMUON ALLEY : from L0Muon +(L0Muon or Muon Segment)
//-----------------------------------------------------

HltDiMuonFromL0Single.MeasureTime=true;
HltDiMuonFromL0Single.Members = {
  "GaudiSequencer/HltDiMuonFromTwoSingleL0AndOneL0OneMuonSeg",
  "HltVertexMaker/DimuonFromL0Single",
  "GaudiSequencer/TriggerDimuonFromSingle"
};

HltDiMuonFromTwoSingleL0AndOneL0OneMuonSeg.ModeOr = true;
HltDiMuonFromTwoSingleL0AndOneL0OneMuonSeg.ShortCircuit = false;
HltDiMuonFromTwoSingleL0AndOneL0OneMuonSeg.MeasureTime = true;
HltDiMuonFromTwoSingleL0AndOneL0OneMuonSeg.Members = {
  "GaudiSequencer/HltL0SingleMuonPreparation",
  "GaudiSequencer/HltMuonSegPreparation"
};

HltMuonSegPreparation.MeasureTime = true;
HltMuonSegPreparation.Members = {
  "HltSelectionFilter/MuonSegEntry",
  "HltMuonRec/MuonTrackRecForL0Single",
  "HltTrackPrepare/FilteredMuonSegments",
  "GaudiSequencer/HltDecodeT",
  "HltTrackUpgrade/MuonTConfirmedWithT",
  "HltTrackFilter/MuonTAndTConfirmed", 
  "HltTrackFilter/RZMuonSeg",
  "HltTrackUpgrade/VeloMuonFromMuonSeg",
  "HltTrackMatch/MuonAndTVeloFromMuonSeg"
};

TriggerDimuonFromSingle.ModeOr = true;
TriggerDimuonFromSingle.ShortCircuit = false;
TriggerDimuonFromSingle.Members = {
  "HltVertexFilter/MuonTriggerIPDiMuon",
  "HltVertexFilter/MuonTriggerDiMuon"
};

MuonSegEntry.InputSelections = {"MuonAndTVelo"};
MuonSegEntry.OutputLevel = 3;

// It already Prepare the muon segments with proper error calling the tool MuonSeedTool
MuonTrackRecForL0Single.OutputMuonTracksName="Hlt/Track/MuonSegmentForL0Single";
MuonTrackRecForL0Single.DecodingFromCoord=true;
MuonTrackRecForL0Single.OutputLevel = 3;

FilteredMuonSegments.TESInputName = "Hlt/Track/MuonSegmentForL0Single";
FilteredMuonSegments.FilterDescriptor = {
  "DoShareM3_L0MuonConfirmedWithT,<,0.5"};
FilteredMuonSegments.OutputLevel = 3;

MuonTConfirmedWithT.InputSelection = "FilteredMuonSegments";
MuonTConfirmedWithT.RecoName = "TConf";
MuonTConfirmedWithT.OutputLevel = 3;

MuonTAndTConfirmed.InputSelection = "MuonTConfirmedWithT";
MuonTAndTConfirmed.FilterDescriptor = {"IsMuon,>,0."};
MuonTAndTConfirmed.OutputLevel = 3;

RZMuonSeg.InputSelection = "RZVelo";
RZMuonSeg.FilterDescriptor = {"RZVeloTMatch_MuonTAndTConfirmed,<,80."};
RZMuonSeg.OutputLevel = 3;

VeloMuonFromMuonSeg.InputSelection = "RZMuonSeg";
VeloMuonFromMuonSeg.RecoName = "Velo";
VeloMuonFromMuonSeg.OutputLevel = 3;

MuonAndTVeloFromMuonSeg.InputSelection = "VeloMuonFromMuonSeg";
MuonAndTVeloFromMuonSeg.InputSelection2 = "MuonTAndTConfirmed";
MuonAndTVeloFromMuonSeg.MatchName = "VeloT";
MuonAndTVeloFromMuonSeg.OutputLevel = 3;

//Configuration for dimuons from L0single: L0+L0  and L0+muonsegment
//This will make vertices using two tracks from InputTracksName
//And one track from InputTracksName and one from InputTracks2Name
DimuonFromL0Single.InputSelection = "MuonAndTVelo";
DimuonFromL0Single.InputSelection2   = "MuonAndTVeloFromMuonSeg";
DimuonFromL0Single.FilterDescriptor = {"DOCA,<,0.5"};
DimuonFromL0Single.OutputLevel = 3;

MuonTriggerIPDiMuon.InputSelection = "DimuonFromL0Single";
MuonTriggerIPDiMuon.FilterDescriptor = {"VertexDimuonMass,>,500.",
                                        "VertexMinIP_PV2D,||>,0.05"};
MuonTriggerIPDiMuon.OutputLevel = 3;

MuonTriggerDiMuon.InputSelection = "DimuonFromL0Single";
MuonTriggerDiMuon.FilterDescriptor = {"VertexDimuonMass,>,2500."};
MuonTriggerDiMuon.OutputLevel = 3;


