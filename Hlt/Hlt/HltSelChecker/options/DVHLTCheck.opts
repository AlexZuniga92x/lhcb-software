#include "$HLTSELCHECKERROOT/options/DVHLTExSelections.opts"

// WARNING: comment the NTuples in DVHLTExSelections.opts when running DVHLTCheck
// and comment the all the other exclusive channels, excepted the one to check

// Include this if you also need to run on offline particles and if not already
// included in DVHLTExSelections.opts
#include "$DAVINCIROOT/options/DaVinciReco.opts"

//==============================================================================
// Checking B -> H H
//==============================================================================

/*
//==============================================================================
// Checking B -> H H on all events with previous MC truth filtering
//==============================================================================

ApplicationMgr.TopAlg += {"Sequencer/CheckHLTB2HH"};
CheckHLTB2HH.Members ={ "TriggerFilter/L0Filter", "PrintHeader/PassedL0",
                        "TriggerFilter/L1Filter", "PrintHeader/PassedL1",
                        "CheckSelResult/MergeHLTB2HH", "PrintHeader/HappyHLTB2HH",
                        "DecayChainNTuple/HLTB2HHTree", "PrintHeader/HappyHLTB2HHTree"};
 
L0Filter.RequireL0 = true;
L1Filter.RequireL1 = true;

PassedL0.OutputLevel = 3;
PassedL1.OutputLevel = 3;
 
MergeHLTB2HH.Algorithms = {"HLTFilterB2HH"};

MergeHLTB2HH.OutputLevel = 3;
HappyHLTB2HH.OutputLevel = 3;
HappyHLTB2HHTree.OutputLevel = 3;
 
//------------------------------------------------------------------------------
// Write Tree for HLT selection
HLTB2HHTree.PhysDesktop.InputLocations = {"Phys/HLTFilterB2HH"};

HLTB2HHTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksHLTB2HH";
HLTB2HHTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
HLTB2HHTree.LinkAsct.AlgorithmName = "Particle2MCLinksHLTB2HH";
HLTB2HHTree.LinkAsct.OutputLevel = 3;
 
Particle2MCLinksHLTB2HH.InputData  = { "Phys/SelectB2HH/Particles", "Phys/HLTB2HHDaughters/Particles"};
Particle2MCLinksHLTB2HH.OutputLevel = 3;

// In the HLT we always form B0 -> pi+ pi-
HLTB2HHTree.Decay = "B0 -> ^pi+ ^pi-";
HLTB2HHTree.MCDecay = "{B0 -> ^pi+ ^pi-, B~0 -> ^pi+ ^pi-, B0 -> ^K+ ^pi-, B0 -> ^K- ^pi+, B~0 -> ^K- ^pi+, B~0 -> ^K+ ^pi-, B_s0 -> ^K+ ^K-, B_s~0 -> ^K+ ^K-, B_s0 -> ^pi+ ^K-, B_s0 -> ^pi- ^K+, B_s~0 -> ^pi- ^K+, B_s~0 -> ^pi+ ^K-}";
HLTB2HHTree.NtupleName = "FILE1/HLTB2HH";
HLTB2HHTree.MCNtupleName = "FILE1/MCHLTB2HH";
HLTB2HHTree.OutputLevel = 3;
//------------------------------------------------------------------------------
*/

//==============================================================================
// Checking Bd -> pi+ pi- and cc
//==============================================================================

// The offline selection
#include "$B2HHROOT/options/DoTDRselBd2PiPi.opts"

ApplicationMgr.TopAlg += {"Sequencer/CheckHLTBd2PiPi"};
CheckHLTBd2PiPi.Members ={ "TriggerFilter/L0Filter", "PrintHeader/PassedL0",
                           "TriggerFilter/L1Filter", "PrintHeader/PassedL1",
                           "CheckSelResult/MergeTDRBd2PiPi", "PrintHeader/HappyTDRBd2PiPi",
                           "DecayChainNTuple/TDRBd2PiPiTree", "PrintHeader/HappyTDRBd2PiPiTree",
                           "CheckSelResult/MergeHLTBd2PiPi", "PrintHeader/HappyHLTBd2PiPi",
                           "DecayChainNTuple/HLTBd2PiPiTree", "PrintHeader/HappyHLTBd2PiPiTree"};
 
L0Filter.RequireL0 = true;
L1Filter.RequireL1 = true;

PassedL0.OutputLevel = 3;
PassedL1.OutputLevel = 3;
 
MergeTDRBd2PiPi.Algorithms = {"TDRselBd2PiPi"};
// When not running with MCTruth
// MergeHLTBd2PiPi.Algorithms = { "HLTFilterB2HH"};
// To have MC truth in HLT when no reconstructed HLT B (all particles are originally made as pions)
MergeHLTBd2PiPi.Algorithms = {"HLTPions"};

MergeTDRBd2PiPi.OutputLevel = 3;
MergeHLTBd2PiPi.OutputLevel = 3;

HappyTDRBd2PiPi.OutputLevel = 3;
HappyHLTBd2PiPi.OutputLevel = 3;

HappyTDRBd2PiPiTree.OutputLevel = 3;
HappyHLTBd2PiPiTree.OutputLevel = 3;
 
//------------------------------------------------------------------------------
// Write Tree for TDR selection
TDRBd2PiPiTree.PhysDesktop.InputLocations = {"Phys/TDRselBd2PiPi"};

TDRBd2PiPiTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksTDRBd2PiPi";
TDRBd2PiPiTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
TDRBd2PiPiTree.LinkAsct.AlgorithmName = "Particle2MCLinksTDRBd2PiPi";
TDRBd2PiPiTree.LinkAsct.OutputLevel = 3;

Particle2MCLinksTDRBd2PiPi.InputData  = { "Phys/Combined/Particles"};
Particle2MCLinksTDRBd2PiPi.OutputLevel = 3;

TDRBd2PiPiTree.Decay = "B0 -> ^pi+ ^pi-";
TDRBd2PiPiTree.MCDecay = "{B0 -> ^pi+ ^pi-, B~0 -> ^pi+ ^pi-}";
TDRBd2PiPiTree.NtupleName = "FILE1/TDRBd2PiPi";
TDRBd2PiPiTree.MCNtupleName = "FILE1/MCTDRBd2PiPi";
TDRBd2PiPiTree.OutputLevel = 3;
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Write Tree for HLT selection
HLTBd2PiPiTree.PhysDesktop.InputLocations = {"Phys/HLTFilterB2HH"};

HLTBd2PiPiTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksHLTBd2PiPi";
HLTBd2PiPiTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
HLTBd2PiPiTree.LinkAsct.AlgorithmName = "Particle2MCLinksHLTBd2PiPi";
HLTBd2PiPiTree.LinkAsct.OutputLevel = 3;
 
Particle2MCLinksHLTBd2PiPi.InputData  = { "Phys/HLTPions/Particles", "Phys/HLTB2HHDaughters/Particles"};
Particle2MCLinksHLTBd2PiPi.OutputLevel = 3;

// In the HLT we always form B0 -> pi+ pi-
HLTBd2PiPiTree.Decay = "B0 -> ^pi+ ^pi-";
HLTBd2PiPiTree.MCDecay = "{B0 -> ^pi+ ^pi-, B~0 -> ^pi+ ^pi-}";
HLTBd2PiPiTree.NtupleName = "FILE1/HLTBd2PiPi";
HLTBd2PiPiTree.MCNtupleName = "FILE1/MCHLTBd2PiPi";
HLTBd2PiPiTree.OutputLevel = 3;
//------------------------------------------------------------------------------

/*
//==============================================================================
// Checking Bd -> K+ pi- and cc
//==============================================================================

// The offline selection
#include "$B2HHROOT/options/DoTDRselBd2KPi.opts"

ApplicationMgr.TopAlg += {"Sequencer/CheckHLTBd2KPi"};
CheckHLTBd2KPi.Members ={ "TriggerFilter/L0Filter", "PrintHeader/PassedL0",
                          "TriggerFilter/L1Filter", "PrintHeader/PassedL1",
                          "CheckSelResult/MergeTDRBd2KPi", "PrintHeader/HappyTDRBd2KPi",
                          "DecayChainNTuple/TDRBd2KPiTree", "PrintHeader/HappyTDRBd2KPiTree",
                          "CheckSelResult/MergeHLTBd2KPi", "PrintHeader/HappyHLTBd2KPi",
                          "DecayChainNTuple/HLTBd2KPiTree", "PrintHeader/HappyHLTBd2KPiTree"};
 
L0Filter.RequireL0 = true;
L1Filter.RequireL1 = true;

PassedL0.OutputLevel = 3;
PassedL1.OutputLevel = 3;

MergeTDRBd2KPi.Algorithms = {"TDRselBd2KPi"};
// When not running with MCTruth
// MergeHLTBd2KPi.Algorithms = { "HLTFilterB2HH"};
// To have MC truth in HLT when no reconstructed HLT B (all particles are originally made as pions)
MergeHLTBd2KPi.Algorithms = {"HLTPions"};

MergeTDRBd2KPi.OutputLevel = 3;
MergeHLTBd2KPi.OutputLevel = 3;

HappyTDRBd2KPi.OutputLevel = 3;
HappyHLTBd2KPi.OutputLevel = 3;

HappyTDRBd2KPiTree.OutputLevel = 3;
HappyHLTBd2KPiTree.OutputLevel = 3;
 
//------------------------------------------------------------------------------
// Write Tree for TDR selection
TDRBd2KPiTree.PhysDesktop.InputLocations = {"Phys/TDRselBd2KPi"};

TDRBd2KPiTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksTDRBd2KPi";
TDRBd2KPiTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
TDRBd2KPiTree.LinkAsct.AlgorithmName = "Particle2MCLinksTDRBd2KPi";
TDRBd2KPiTree.LinkAsct.OutputLevel = 3;

Particle2MCLinksTDRBd2KPi.InputData  = { "Phys/Combined/Particles"};
Particle2MCLinksTDRBd2KPi.OutputLevel = 3;

// WARNING: The offline does not create B~0 but always B0
// TDRBd2KPiTree.Decay = "{B0 -> ^K+ ^pi-, B~0 -> ^K- ^pi+ }";
TDRBd2KPiTree.Decay = "{B0 -> ^K+ ^pi-, B0 -> ^K- ^pi+ }";
// Do not use cc, but write explicitly all possibilities
TDRBd2KPiTree.MCDecay = "{B0 -> ^K+ ^pi-, B0 -> ^K- ^pi+, B~0 -> ^K- ^pi+, B~0 -> ^K+ ^pi-}";
TDRBd2KPiTree.NtupleName = "FILE1/TDRBd2KPi";
TDRBd2KPiTree.MCNtupleName = "FILE1/MCTDRBd2KPi";
TDRBd2KPiTree.OutputLevel = 3;

//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Write Tree for HLT selection
HLTBd2KPiTree.PhysDesktop.InputLocations = {"Phys/HLTFilterB2HH"};

HLTBd2KPiTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksHLTBd2KPi";
HLTBd2KPiTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
HLTBd2KPiTree.LinkAsct.AlgorithmName = "Particle2MCLinksHLTBd2KPi";
HLTBd2KPiTree.LinkAsct.OutputLevel = 3;

Particle2MCLinksHLTBd2KPi.InputData  = { "Phys/HLTPions/Particles", "Phys/HLTB2HHDaughters/Particles"};
Particle2MCLinksHLTBd2KPi.OutputLevel = 3;

// In the HLT we always form B0 -> pi+ pi-
HLTBd2KPiTree.Decay = "B0 -> ^pi+ ^pi-";
// Do not use cc, but write explicitly all possibilities
HLTBd2KPiTree.MCDecay = "{B0 -> ^K+ ^pi-, B0 -> ^K- ^pi+, B~0 -> ^K- ^pi+, B~0 -> ^K+ ^pi-}";
HLTBd2KPiTree.NtupleName = "FILE1/HLTBd2KPi";
HLTBd2KPiTree.MCNtupleName = "FILE1/MCHLTBd2KPi";
HLTBd2KPiTree.OutputLevel = 3;
//------------------------------------------------------------------------------
*/

/*
//==============================================================================
// Checking Bs -> K+ K- and cc
//==============================================================================

// The offline selection
#include "$B2HHROOT/options/DoTDRselBs2KK.opts"

ApplicationMgr.TopAlg += {"Sequencer/CheckHLTBs2KK"};
CheckHLTBs2KK.Members ={ "TriggerFilter/L0Filter", "PrintHeader/PassedL0",
                         "TriggerFilter/L1Filter", "PrintHeader/PassedL1",
                         "CheckSelResult/MergeTDRBs2KK", "PrintHeader/HappyTDRBs2KK",
                         "DecayChainNTuple/TDRBs2KKTree", "PrintHeader/HappyTDRBs2KKTree",
                         "CheckSelResult/MergeHLTBs2KK", "PrintHeader/HappyHLTBs2KK",
                         "DecayChainNTuple/HLTBs2KKTree", "PrintHeader/HappyHLTBs2KKTree"};
 
L0Filter.RequireL0 = true;
L1Filter.RequireL1 = true;

PassedL0.OutputLevel = 3;
PassedL1.OutputLevel = 3;

MergeTDRBs2KK.Algorithms = {"TDRselBs2KK"};
// When not running with MCTruth
// MergeHLTBs2KK.Algorithms = { "HLTFilterB2HH"};
// To have MC truth in HLT when no reconstructed HLT B (all particles are originally made as pions)
MergeHLTBs2KK.Algorithms = {"HLTPions"};

MergeTDRBs2KK.OutputLevel = 3;
MergeHLTBs2KK.OutputLevel = 3;

HappyTDRBs2KK.OutputLevel = 3;
HappyHLTBs2KK.OutputLevel = 3;

HappyTDRBs2KKTree.OutputLevel = 3;
HappyHLTBs2KKTree.OutputLevel = 3;
 
//------------------------------------------------------------------------------
// Write Tree for TDR selection
TDRBs2KKTree.PhysDesktop.InputLocations = {"Phys/TDRselBs2KK"};

TDRBs2KKTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksTDRBs2KK";
TDRBs2KKTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
TDRBs2KKTree.LinkAsct.AlgorithmName = "Particle2MCLinksTDRBs2KK";
TDRBs2KKTree.LinkAsct.OutputLevel = 3;

Particle2MCLinksTDRBs2KK.InputData  = { "Phys/Combined/Particles"};
Particle2MCLinksTDRBs2KK.OutputLevel = 3;

TDRBs2KKTree.Decay = "B_s0 -> ^K+ ^K-";
TDRBs2KKTree.MCDecay = "{B_s0 -> ^K+ ^K-, B_s~0 -> ^K+ ^K-}";
TDRBs2KKTree.NtupleName = "FILE1/TDRBs2KK";
TDRBs2KKTree.MCNtupleName = "FILE1/MCTDRBs2KK";
TDRBs2KKTree.OutputLevel = 3;
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Write Tree for HLT selection
HLTBs2KKTree.PhysDesktop.InputLocations = {"Phys/HLTFilterB2HH"};

HLTBs2KKTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksHLTBs2KK";
HLTBs2KKTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
HLTBs2KKTree.LinkAsct.AlgorithmName = "Particle2MCLinksHLTBs2KK";
HLTBs2KKTree.LinkAsct.OutputLevel = 3;

Particle2MCLinksHLTBs2KK.InputData  = { "Phys/HLTPions/Particles", "Phys/HLTB2HHDaughters/Particles"};
Particle2MCLinksHLTBs2KK.OutputLevel = 3;

// In the HLT we always form B0 -> pi+ pi-
HLTBs2KKTree.Decay = "B0 -> ^pi+ ^pi-";
HLTBs2KKTree.MCDecay = "{B_s0 -> ^K+ ^K-, B_s~0 -> ^K+ ^K-}";
HLTBs2KKTree.NtupleName = "FILE1/HLTBs2KK";
HLTBs2KKTree.MCNtupleName = "FILE1/MCHLTBs2KK";
HLTBs2KKTree.OutputLevel = 3;
//------------------------------------------------------------------------------
*/

/*
//==============================================================================
// Checking Bs -> pi+ K- and cc
//==============================================================================

// The offline selection
#include "$B2HHROOT/options/DoTDRselBs2PiK.opts" 

ApplicationMgr.TopAlg += {"Sequencer/CheckHLTBs2PiK"};
CheckHLTBs2PiK.Members ={ "TriggerFilter/L0Filter", "PrintHeader/PassedL0",
                          "TriggerFilter/L1Filter", "PrintHeader/PassedL1",
                          "CheckSelResult/MergeTDRBs2PiK", "PrintHeader/HappyTDRBs2PiK",
                          "DecayChainNTuple/TDRBs2PiKTree", "PrintHeader/HappyTDRBs2PiKTree",
                          "CheckSelResult/MergeHLTBs2PiK", "PrintHeader/HappyHLTBs2PiK",
                          "DecayChainNTuple/HLTBs2PiKTree", "PrintHeader/HappyHLTBs2PiKTree"};
 
L0Filter.RequireL0 = true;
L1Filter.RequireL1 = true;

PassedL0.OutputLevel = 3;
PassedL1.OutputLevel = 3;

MergeTDRBs2PiK.Algorithms = {"TDRselBs2PiK"};
// When not running with MCTruth
// MergeHLTBs2PiK.Algorithms = { "HLTFilterB2HH"};
// To have MC truth in HLT when no reconstructed HLT B (all particles are originally made as pions)
MergeHLTBs2PiK.Algorithms = {"HLTPions"};

MergeTDRBs2PiK.OutputLevel = 3;
MergeHLTBs2PiK.OutputLevel = 3;

HappyTDRBs2PiK.OutputLevel = 3;
HappyHLTBs2PiK.OutputLevel = 3;

HappyTDRBs2PiKTree.OutputLevel = 3;
HappyHLTBs2PiKTree.OutputLevel = 3;
 
//------------------------------------------------------------------------------
// Write Tree for TDR selection
TDRBs2PiKTree.PhysDesktop.InputLocations = {"Phys/TDRselBs2PiK"};

TDRBs2PiKTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksTDRBs2PiK";
TDRBs2PiKTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
TDRBs2PiKTree.LinkAsct.AlgorithmName = "Particle2MCLinksTDRBs2PiK";
TDRBs2PiKTree.LinkAsct.OutputLevel = 3;

Particle2MCLinksTDRBs2PiK.InputData  = { "Phys/Combined/Particles"};
Particle2MCLinksTDRBs2PiK.OutputLevel = 3;


// WARNING: The offline does not create B_s~0 but always B_s0
// TDRBs2PiKTree.Decay = "{B_s0 -> ^pi+ ^K-, B_s~0 -> ^pi- ^K+}";
TDRBs2PiKTree.Decay = "{B_s0 -> ^pi+ ^K-, B_s0 -> ^pi- ^K+}";
TDRBs2PiKTree.MCDecay = "{B_s0 -> ^pi+ ^K-, B_s0 -> ^pi- ^K+, B_s~0 -> ^pi- ^K+, B_s~0 -> ^pi+ ^K-}";
TDRBs2PiKTree.NtupleName = "FILE1/TDRBs2PiK";
TDRBs2PiKTree.MCNtupleName = "FILE1/MCTDRBs2PiK";
TDRBs2PiKTree.OutputLevel = 3;
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Write Tree for HLT selection
HLTBs2PiKTree.PhysDesktop.InputLocations = {"Phys/HLTFilterB2HH"};

HLTBs2PiKTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksHLTBs2PiK";
HLTBs2PiKTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
HLTBs2PiKTree.LinkAsct.AlgorithmName = "Particle2MCLinksHLTBs2PiK";
HLTBs2PiKTree.LinkAsct.OutputLevel = 3;

Particle2MCLinksHLTBs2PiK.InputData  = {"Phys/HLTPions/Particles", "Phys/HLTB2HHDaughters/Particles"};
Particle2MCLinksHLTBs2PiK.OutputLevel = 3;


// In the HLT we always form B0 -> pi+ pi-
HLTBs2PiKTree.Decay = "B0 -> ^pi+ ^pi-";
HLTBs2PiKTree.MCDecay = "{B_s0 -> ^pi+ ^K-, B_s0 -> ^pi- ^K+, B_s~0 -> ^pi- ^K+, B_s~0 -> ^pi+ ^K-}";
HLTBs2PiKTree.NtupleName = "FILE1/HLTBs2PiK";
HLTBs2PiKTree.MCNtupleName = "FILE1/MCHLTBs2PiK";
HLTBs2PiKTree.OutputLevel = 3;
//------------------------------------------------------------------------------
*/

/*
//==============================================================================
// Checking B_s0 -> phi(1020) phi(1020)
//==============================================================================

// The offline selection
#include "$BS2PHIPHIROOT/options/DoTDRselBs2PhiPhi.opts"

ApplicationMgr.TopAlg += {"Sequencer/CheckHLTBs2PhiPhi"};
CheckHLTBs2PhiPhi.Members ={ "TriggerFilter/L0Filter", "PrintHeader/PassedL0",
                             "TriggerFilter/L1Filter", "PrintHeader/PassedL1",
                             "CheckSelResult/MergeTDRBs2PhiPhi", "PrintHeader/HappyTDRBs2PhiPhi",
                             "DecayChainNTuple/TDRBs2PhiPhiTree", "PrintHeader/HappyTDRBs2PhiPhiTree",
                             "CheckSelResult/MergeHLTBs2PhiPhi", "PrintHeader/HappyHLTBs2PhiPhi",
                             "DecayChainNTuple/HLTBs2PhiPhiTree", "PrintHeader/HappyHLTBs2PhiPhiTree"};
 
L0Filter.RequireL0 = true;
L1Filter.RequireL1 = true;

PassedL0.OutputLevel = 3;
PassedL1.OutputLevel = 3;
 
MergeTDRBs2PhiPhi.Algorithms = {"TDRselBs2PhiPhi"};
// When not running with MCTruth
// MergeHLTBs2PhiPhi.Algorithms = {"HLTFilterBs2PhiPhi"};
// To have MC truth in HLT when no reconstructed HLT B (all particles are originally made as pions)
MergeHLTBs2PhiPhi.Algorithms = {"HLTPions"};

MergeTDRBs2PhiPhi.OutputLevel = 3;
MergeHLTBs2PhiPhi.OutputLevel = 3;

HappyTDRBs2PhiPhi.OutputLevel = 3;
HappyHLTBs2PhiPhi.OutputLevel = 3;

HappyTDRBs2PhiPhiTree.OutputLevel = 3;
HappyHLTBs2PhiPhiTree.OutputLevel = 3;
 
//------------------------------------------------------------------------------
// Write Tree for TDR selection
TDRBs2PhiPhiTree.PhysDesktop.InputLocations = {"Phys/TDRselBs2PhiPhi"};

TDRBs2PhiPhiTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksTDRBs2PhiPhi";
TDRBs2PhiPhiTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
TDRBs2PhiPhiTree.LinkAsct.AlgorithmName = "Particle2MCLinksTDRBs2PhiPhi";
TDRBs2PhiPhiTree.LinkAsct.OutputLevel = 3;

Particle2MCLinksTDRBs2PhiPhi.InputData  = { "Phys/CombinedForBs2PhiPhi/Particles"};
Particle2MCLinksTDRBs2PhiPhi.OutputLevel = 3;

TDRBs2PhiPhiTree.Decay = "B_s0 -> (^phi(1020) -> ^K- ^K+) (^phi(1020) -> ^K- ^K+)";
TDRBs2PhiPhiTree.MCDecay = "{B_s0 -> (^phi(1020) -> ^K- ^K+) (^phi(1020) -> ^K- ^K+),B_s~0 -> (^phi(1020) -> ^K- ^K+) (^phi(1020) -> ^K- ^K+)}";
TDRBs2PhiPhiTree.NtupleName = "FILE1/TDRBs2PhiPhi";
TDRBs2PhiPhiTree.MCNtupleName = "FILE1/MCTDRBs2PhiPhi";
TDRBs2PhiPhiTree.OutputLevel = 3;
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Write Tree for HLT selection
HLTBs2PhiPhiTree.PhysDesktop.InputLocations = {"Phys/HLTFilterBs2PhiPhi"};

HLTBs2PhiPhiTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksHLTBs2PhiPhi";
HLTBs2PhiPhiTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
HLTBs2PhiPhiTree.LinkAsct.AlgorithmName = "Particle2MCLinksHLTBs2PhiPhi";
HLTBs2PhiPhiTree.LinkAsct.OutputLevel = 3;

Particle2MCLinksHLTBs2PhiPhi.InputData  = {"Phys/HLTPions/Particles", "Phys/HLTKKFromDaughters/Particles"};
Particle2MCLinksHLTBs2PhiPhi.OutputLevel = 3;

HLTBs2PhiPhiTree.Decay = "B_s0 -> (^phi(1020) -> ^K- ^K+) (^phi(1020) -> ^K- ^K+)";
HLTBs2PhiPhiTree.MCDecay = "{B_s0 -> (^phi(1020) -> ^K- ^K+) (^phi(1020) -> ^K- ^K+),B_s~0 -> (^phi(1020) -> ^K- ^K+) (^phi(1020) -> ^K- ^K+)}";
HLTBs2PhiPhiTree.NtupleName = "FILE1/HLTBs2PhiPhi";
HLTBs2PhiPhiTree.MCNtupleName = "FILE1/MCHLTBs2PhiPhi";
HLTBs2PhiPhiTree.OutputLevel = 3;
//------------------------------------------------------------------------------
*/

/*
//==============================================================================
// Checking B0 -> (D~0 -> K+ pi-) (K*(892)0 -> K+ pi-) and cc
//==============================================================================

// The offline selection
#include "$BD2D0KSTARROOT/options/DoTDRselBd2D02KpiKstar.opts"

ApplicationMgr.TopAlg += {"Sequencer/CheckHLTBd2D02KPiKstar"};
CheckHLTBd2D02KPiKstar.Members ={ "TriggerFilter/L0Filter", "PrintHeader/PassedL0",
                                  "TriggerFilter/L1Filter", "PrintHeader/PassedL1",
                                  "CheckSelResult/MergeTDRBd2D02KPiKstar", "PrintHeader/HappyTDRBd2D02KPiKstar",
                                  "DecayChainNTuple/TDRBd2D02KPiKstarTree", "PrintHeader/HappyTDRBd2D02KPiKstarTree",
                                  "CheckSelResult/MergeHLTBd2D02KPiKstar", "PrintHeader/HappyHLTBd2D02KPiKstar",
                                  "DecayChainNTuple/HLTBd2D02KPiKstarTree", "PrintHeader/HappyHLTBd2D02KPiKstarTree"};
 
L0Filter.RequireL0 = true;
L1Filter.RequireL1 = true;

PassedL0.OutputLevel = 3;
PassedL1.OutputLevel = 3;
 
MergeTDRBd2D02KPiKstar.Algorithms = {"TDRselBd2D02KpiKstar"};
// When not running with MCTruth
// MergeHLTBd2D02KPiKstar.Algorithms = {"HLTFilterBd2D02KPiKstar"};
// To have MC truth in HLT when no reconstructed HLT B (all particles are originally made as pions)
MergeHLTBd2D02KPiKstar.Algorithms = {"HLTPions"};

MergeTDRBd2D02KPiKstar.OutputLevel = 3;
MergeHLTBd2D02KPiKstar.OutputLevel = 3;

HappyTDRBd2D02KPiKstar.OutputLevel = 3;
HappyHLTBd2D02KPiKstar.OutputLevel = 3;

HappyTDRBd2D02KPiKstarTree.OutputLevel = 3;
HappyHLTBd2D02KPiKstarTree.OutputLevel = 3;
 
//------------------------------------------------------------------------------
// Write Tree for TDR selection
TDRBd2D02KPiKstarTree.PhysDesktop.InputLocations = {"Phys/TDRselBd2D02KpiKstar"};

TDRBd2D02KPiKstarTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksTDRBd2D02KPiKstar";
TDRBd2D02KPiKstarTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
TDRBd2D02KPiKstarTree.LinkAsct.AlgorithmName = "Particle2MCLinksTDRBd2D02KPiKstar";
TDRBd2D02KPiKstarTree.LinkAsct.OutputLevel = 3;

Particle2MCLinksTDRBd2D02KPiKstar.InputData  = { "Phys/TDRselD02Kpi/Particles", "Phys/TDRselKstar2KpiForBd2D02Kpi/Particles"};
Particle2MCLinksTDRBd2D02KPiKstar.OutputLevel = 3;

TDRBd2D02KPiKstarTree.Decay = "{B0 -> (^D~0 -> ^K+ ^pi-) (^K*(892)0 -> ^K+ ^pi-), B~0 -> (^D0 -> ^K- ^pi+) (^K*(892)~0 -> ^K- ^pi+)}";
TDRBd2D02KPiKstarTree.MCDecay = "{B0 -> (^D~0 -> ^K+ ^pi-) (^K*(892)0 -> ^K+ ^pi-), B0 -> (^D0 -> ^K- ^pi+) (^K*(892)~0 -> ^K- ^pi+), B~0 -> (^D0 -> ^K- ^pi+) (^K*(892)~0 -> ^K- ^pi+), B~0 -> (^D~0 -> ^K+ ^pi-) (^K*(892)0 -> ^K+ ^pi-)}";
TDRBd2D02KPiKstarTree.NtupleName = "FILE1/TDRBd2D02KPiKstar";
TDRBd2D02KPiKstarTree.MCNtupleName = "FILE1/MCTDRBd2D02KPiKstar";
TDRBd2D02KPiKstarTree.OutputLevel = 3;
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Write Tree for HLT selection
HLTBd2D02KPiKstarTree.PhysDesktop.InputLocations = {"Phys/HLTFilterBd2D02KPiKstar"};

HLTBd2D02KPiKstarTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksHLTBd2D02KPiKstar";
HLTBd2D02KPiKstarTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
HLTBd2D02KPiKstarTree.LinkAsct.AlgorithmName = "Particle2MCLinksHLTBd2D02KPiKstar";
HLTBd2D02KPiKstarTree.LinkAsct.OutputLevel = 3;

// Note: ChangePID breaks the association???
Particle2MCLinksHLTBd2D02KPiKstar.InputData  = { "Phys/HLTPions/Particles", "Phys/HLTKPiFromDaughters/Particles", "Phys/HLTD02KPi/Particles"};
Particle2MCLinksHLTBd2D02KPiKstar.OutputLevel = 3;

HLTBd2D02KPiKstarTree.Decay = "{B0 -> (^D~0 -> ^K+ ^pi-) (^K*(892)0 -> ^K+ ^pi-), B~0 -> (^D0 -> ^K- ^pi+) (^K*(892)~0 -> ^K- ^pi+)}";
HLTBd2D02KPiKstarTree.MCDecay = "{B0 -> (^D~0 -> ^K+ ^pi-) (^K*(892)0 -> ^K+ ^pi-), B0 -> (^D0 -> ^K- ^pi+) (^K*(892)~0 -> ^K- ^pi+), B~0 -> (^D0 -> ^K- ^pi+) (^K*(892)~0 -> ^K- ^pi+), B~0 -> (^D~0 -> ^K+ ^pi-) (^K*(892)0 -> ^K+ ^pi-)}";
HLTBd2D02KPiKstarTree.NtupleName = "FILE1/HLTBd2D02KPiKstar";
HLTBd2D02KPiKstarTree.MCNtupleName = "FILE1/MCHLTBd2D02KPiKstar";
HLTBd2D02KPiKstarTree.OutputLevel = 3;
//------------------------------------------------------------------------------
*/

/*
//==============================================================================
// Checking B0 -> (D*(2010)- -> (D~0 -> K+ pi-)  pi-) pi+ and cc
//==============================================================================

// The offline selection
#include "$BD2DSTARPIROOT/options/DoTDRselBd2DstarPi.opts"

ApplicationMgr.TopAlg += {"Sequencer/CheckHLTBd2DstarPi"};
CheckHLTBd2DstarPi.Members ={ "TriggerFilter/L0Filter", "PrintHeader/PassedL0",
                              "TriggerFilter/L1Filter", "PrintHeader/PassedL1",
                              "CheckSelResult/MergeTDRBd2DstarPi", "PrintHeader/HappyTDRBd2DstarPi",
                              "DecayChainNTuple/TDRBd2DstarPiTree", "PrintHeader/HappyTDRBd2DstarPiTree",
                              "CheckSelResult/MergeHLTBd2DstarPi", "PrintHeader/HappyHLTBd2DstarPi",
                              "DecayChainNTuple/HLTBd2DstarPiTree", "PrintHeader/HappyHLTBd2DstarPiTree"};
 
L0Filter.RequireL0 = true;
L1Filter.RequireL1 = true;

PassedL0.OutputLevel = 3;
PassedL1.OutputLevel = 3;
 
MergeTDRBd2DstarPi.Algorithms = {"TDRselBd2DstarPi"};
// When not running with MCTruth
// MergeHLTBd2DstarPi.Algorithms = {"HLTFilterBd2DstarPi"};
// To have MC truth in HLT when no reconstructed HLT B (all particles are originally made as pions)
MergeHLTBd2DstarPi.Algorithms = {"HLTPions"};

MergeTDRBd2DstarPi.OutputLevel = 3;
MergeHLTBd2DstarPi.OutputLevel = 3;

HappyTDRBd2DstarPi.OutputLevel = 3;
HappyHLTBd2DstarPi.OutputLevel = 3;

HappyTDRBd2DstarPiTree.OutputLevel = 3;
HappyHLTBd2DstarPiTree.OutputLevel = 3;
 
//------------------------------------------------------------------------------
// Write Tree for TDR selection
TDRBd2DstarPiTree.PhysDesktop.InputLocations = {"Phys/TDRselBd2DstarPi"};

TDRBd2DstarPiTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksTDRBd2DstarPi";
TDRBd2DstarPiTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
TDRBd2DstarPiTree.LinkAsct.AlgorithmName = "Particle2MCLinksTDRBd2DstarPi";
TDRBd2DstarPiTree.LinkAsct.OutputLevel = 3;

Particle2MCLinksTDRBd2DstarPi.InputData  = { "Phys/CombinedForTDRselBd2DstarPi/Particles"};
Particle2MCLinksTDRBd2DstarPi.OutputLevel = 3;

TDRBd2DstarPiTree.Decay = "{B0 -> (^D*(2010)- -> (^D~0 -> ^K+ ^pi-)  ^pi-) ^pi+, B~0 -> (^D*(2010)+ -> (^D0 -> ^K- ^pi+)  ^pi+) ^pi-}";
TDRBd2DstarPiTree.MCDecay = "{B0 -> (^D*(2010)- -> (^D~0 -> ^K+ ^pi-)  ^pi-) ^pi+, B0 -> (^D*(2010)+ -> (^D0 -> ^K- ^pi+)  ^pi+) ^pi-, B~0 -> (^D*(2010)+ -> (^D0 -> ^K- ^pi+)  ^pi+) ^pi-, B~0 -> (^D*(2010)- -> (^D~0 -> ^K+ ^pi-)  ^pi-) ^pi+}";
TDRBd2DstarPiTree.NtupleName = "FILE1/TDRBd2DstarPi";
TDRBd2DstarPiTree.MCNtupleName = "FILE1/MCTDRBd2DstarPi";
TDRBd2DstarPiTree.OutputLevel = 3;
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Write Tree for HLT selection
HLTBd2DstarPiTree.PhysDesktop.InputLocations = {"Phys/HLTFilterBd2DstarPi"};

HLTBd2DstarPiTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksHLTBd2DstarPi";
HLTBd2DstarPiTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
HLTBd2DstarPiTree.LinkAsct.AlgorithmName = "Particle2MCLinksHLTBd2DstarPi";
HLTBd2DstarPiTree.LinkAsct.OutputLevel = 3;

// Note: ChangePID breaks the association???
Particle2MCLinksHLTBd2DstarPi.InputData  = { "Phys/HLTPions/Particles", "Phys/HLTD02KPi/Particles", "Phys/SoftPionForHLTDstar2D02KPi/Particles", "Phys/HardPionForHLTDstar2D02KPi/Particles"};
Particle2MCLinksHLTBd2DstarPi.OutputLevel = 3;

HLTBd2DstarPiTree.Decay = "{B0 -> (^D*(2010)- -> (^D~0 -> ^K+ ^pi-)  ^pi-) ^pi+, B~0 -> (^D*(2010)+ -> (^D0 -> ^K- ^pi+)  ^pi+) ^pi-}";
HLTBd2DstarPiTree.MCDecay = "{B0 -> (^D*(2010)- -> (^D~0 -> ^K+ ^pi-)  ^pi-) ^pi+, B0 -> (^D*(2010)+ -> (^D0 -> ^K- ^pi+)  ^pi+) ^pi-, B~0 -> (^D*(2010)+ -> (^D0 -> ^K- ^pi+)  ^pi+) ^pi-, B~0 -> (^D*(2010)- -> (^D~0 -> ^K+ ^pi-)  ^pi-) ^pi+}";
HLTBd2DstarPiTree.NtupleName = "FILE1/HLTBd2DstarPi";
HLTBd2DstarPiTree.MCNtupleName = "FILE1/MCHLTBd2DstarPi";
HLTBd2DstarPiTree.OutputLevel = 3;
//------------------------------------------------------------------------------
*/

//==============================================================================
// Checking B_s0 -> (D_s- -> K+ K- pi-) h+ and cc
//==============================================================================

/*
//==============================================================================
// B_s0 -> (D_s- -> K+ K- pi-) pi+ and cc
//==============================================================================

// The offline selection
#include "$BS2DSHROOT/options/DoTDRselBs2DsPi.opts"

ApplicationMgr.TopAlg += {"Sequencer/CheckHLTBs2DsPi"};
CheckHLTBs2DsPi.Members ={ "TriggerFilter/L0Filter", "PrintHeader/PassedL0",
                           "TriggerFilter/L1Filter", "PrintHeader/PassedL1",
                           "CheckSelResult/MergeTDRBs2DsPi", "PrintHeader/HappyTDRBs2DsPi",
                           "DecayChainNTuple/TDRBs2DsPiTree", "PrintHeader/HappyTDRBs2DsPiTree",
                           "CheckSelResult/MergeHLTBs2DsPi", "PrintHeader/HappyHLTBs2DsPi",
                           "DecayChainNTuple/HLTBs2DsPiTree", "PrintHeader/HappyHLTBs2DsPiTree"};
 
L0Filter.RequireL0 = false;
L1Filter.RequireL1 = false;

PassedL0.OutputLevel = 3;
PassedL1.OutputLevel = 3;
 
MergeTDRBs2DsPi.Algorithms = {"TDRselBs2DsPi"};
// When not running with MCTruth
// MergeHLTBs2DsPi.Algorithms = {"HLTFilterBs2DsH"};
// To have MC truth in HLT when no reconstructed HLT B (all particles are originally made as pions)
MergeHLTBs2DsPi.Algorithms = {"HLTPions"};

MergeTDRBs2DsPi.OutputLevel = 3;
MergeHLTBs2DsPi.OutputLevel = 3;

HappyTDRBs2DsPi.OutputLevel = 3;
HappyHLTBs2DsPi.OutputLevel = 3;

HappyTDRBs2DsPiTree.OutputLevel = 3;
HappyHLTBs2DsPiTree.OutputLevel = 3;
 
//------------------------------------------------------------------------------
// Write Tree for TDR selection
TDRBs2DsPiTree.PhysDesktop.InputLocations = {"Phys/TDRselBs2DsPi"};

TDRBs2DsPiTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksTDRBs2DsPi";
TDRBs2DsPiTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
TDRBs2DsPiTree.LinkAsct.AlgorithmName = "Particle2MCLinksTDRBs2DsPi";
TDRBs2DsPiTree.LinkAsct.OutputLevel = 3;

Particle2MCLinksTDRBs2DsPi.InputData  = { "Phys/CombinedForBs2DsH/Particles"};
Particle2MCLinksTDRBs2DsPi.OutputLevel = 3;

// WARNING: The offline does not create B_s~0 but always B_s0
TDRBs2DsPiTree.Decay = "{B_s0 -> (^D_s- => ^K+ ^K- ^pi-) ^pi+, B_s0 -> (^D_s+ => ^K- ^K+ ^pi+) ^pi-}";
TDRBs2DsPiTree.MCDecay = "{B_s0 -> (^D_s- => ^K+ ^K- ^pi-) ^pi+, B_s0 -> (^D_s+ => ^K- ^K+ ^pi+) ^pi-, B_s~0 -> (^D_s+ => ^K- ^K+ ^pi+) ^pi-, B_s~0 -> (^D_s- => ^K+ ^K- ^pi-) ^pi+}";
TDRBs2DsPiTree.NtupleName = "FILE1/TDRBs2DsPi";
TDRBs2DsPiTree.MCNtupleName = "FILE1/MCTDRBs2DsPi";
TDRBs2DsPiTree.OutputLevel = 3;
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Write Tree for HLT selection
HLTBs2DsPiTree.PhysDesktop.InputLocations = {"Phys/HLTFilterBs2DsH"};

HLTBs2DsPiTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksHLTBs2DsPi";
HLTBs2DsPiTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
HLTBs2DsPiTree.LinkAsct.AlgorithmName = "Particle2MCLinksHLTBs2DsPi";
HLTBs2DsPiTree.LinkAsct.OutputLevel = 3;

// Note: ChangePID breaks the association???
Particle2MCLinksHLTBs2DsPi.InputData  = {"Phys/HLTPions/Particles", "Phys/HLTKaons/Particles", "Phys/HLTBachelorForHLTBs2DsH/Particles", "Phys/HLTDaughtersFromDs/Particles"};
Particle2MCLinksHLTBs2DsPi.OutputLevel = 3;

// H is generically a pion in the HLT
HLTBs2DsPiTree.Decay = "{B_s0 -> (^D_s- => ^K+ ^K- ^pi-) ^pi+, B_s~0 -> (^D_s+ => ^K- ^K+ ^pi+) ^pi-}";
HLTBs2DsPiTree.MCDecay = "{B_s0 -> (^D_s- => ^K+ ^K- ^pi-) ^pi+, B_s0 -> (^D_s+ => ^K- ^K+ ^pi+) ^pi-, B_s~0 -> (^D_s+ => ^K- ^K+ ^pi+) ^pi-, B_s~0 -> (^D_s- => ^K+ ^K- ^pi-) ^pi+}";
HLTBs2DsPiTree.NtupleName = "FILE1/HLTBs2DsPi";
HLTBs2DsPiTree.MCNtupleName = "FILE1/MCHLTBs2DsPi";
HLTBs2DsPiTree.OutputLevel = 3;
//------------------------------------------------------------------------------
*/

/*
//==============================================================================
// B_s0 -> (D_s- -> K+ K- pi-) K+ and cc
//==============================================================================

// The offline selection
#include "$BS2DSHROOT/options/DoTDRselBs2DsK.opts"

ApplicationMgr.TopAlg += {"Sequencer/CheckHLTBs2DsK"};
CheckHLTBs2DsK.Members ={ "TriggerFilter/L0Filter", "PrintHeader/PassedL0",
                           "TriggerFilter/L1Filter", "PrintHeader/PassedL1",
                           "CheckSelResult/MergeTDRBs2DsK", "PrintHeader/HappyTDRBs2DsK",
                           "DecayChainNTuple/TDRBs2DsKTree", "PrintHeader/HappyTDRBs2DsKTree",
                           "CheckSelResult/MergeHLTBs2DsK", "PrintHeader/HappyHLTBs2DsK",
                           "DecayChainNTuple/HLTBs2DsKTree", "PrintHeader/HappyHLTBs2DsKTree"};
 
L0Filter.RequireL0 = false;
L1Filter.RequireL1 = false;

PassedL0.OutputLevel = 3;
PassedL1.OutputLevel = 3;

MergeTDRBs2DsK.Algorithms = {"TDRselBs2DsK"};
// When not running with MCTruth
// MergeHLTBs2DsK.Algorithms = {"HLTFilterBs2DsH"};
// To have MC truth in HLT when no reconstructed HLT B (all particles are originally made as pions)
MergeHLTBs2DsK.Algorithms = {"HLTPions"};

MergeTDRBs2DsK.OutputLevel = 3;
MergeHLTBs2DsK.OutputLevel = 3;

HappyTDRBs2DsK.OutputLevel = 3;
HappyHLTBs2DsK.OutputLevel = 3;

HappyTDRBs2DsKTree.OutputLevel = 3;
HappyHLTBs2DsKTree.OutputLevel = 3;
 
//------------------------------------------------------------------------------
// Write Tree for TDR selection
TDRBs2DsKTree.PhysDesktop.InputLocations = {"Phys/TDRselBs2DsK"};

TDRBs2DsKTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksTDRBs2DsK";
TDRBs2DsKTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
TDRBs2DsKTree.LinkAsct.AlgorithmName = "Particle2MCLinksTDRBs2DsK";
TDRBs2DsKTree.LinkAsct.OutputLevel = 3;

Particle2MCLinksTDRBs2DsK.InputData  = { "Phys/CombinedForBs2DsH/Particles"};
Particle2MCLinksTDRBs2DsK.OutputLevel = 3;

// WARNING: The offline does not create B_s~0 but always B_s0
TDRBs2DsKTree.Decay = "{B_s0 -> (^D_s- => ^K+ ^K- ^pi-) ^K+, B_s0 -> (^D_s+ => ^K- ^K+ ^pi+) ^K-}";
TDRBs2DsKTree.MCDecay = "{B_s0 -> (^D_s- => ^K+ ^K- ^pi-) ^K+, B_s0 -> (^D_s+ => ^K- ^K+ ^pi+) ^K-, B_s~0 -> (^D_s+ => ^K- ^K+ ^pi+) ^K-, B_s~0 -> (^D_s- => ^K+ ^K- ^pi-) ^K+}";
TDRBs2DsKTree.NtupleName = "FILE1/TDRBs2DsK";
TDRBs2DsKTree.MCNtupleName = "FILE1/MCTDRBs2DsK";
TDRBs2DsKTree.OutputLevel = 3;
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Write Tree for HLT selection
HLTBs2DsKTree.PhysDesktop.InputLocations = {"Phys/HLTFilterBs2DsH"};

HLTBs2DsKTree.LinkAsct.Location      = "Phys/Relations/Particle2MCLinksHLTBs2DsK";
HLTBs2DsKTree.LinkAsct.AlgorithmType = "Particle2MCLinks";
HLTBs2DsKTree.LinkAsct.AlgorithmName = "Particle2MCLinksHLTBs2DsK";
HLTBs2DsKTree.LinkAsct.OutputLevel = 3;

// Note: ChangePID breaks the association???
Particle2MCLinksHLTBs2DsK.InputData  = {"Phys/HLTPions/Particles", "Phys/HLTKaons/Particles", "Phys/HLTBachelorForHLTBs2DsH/Particles", "Phys/HLTDaughtersFromDs/Particles"};
Particle2MCLinksHLTBs2DsK.OutputLevel = 3;

// HLTBs2DsKTree.Decay = "{B_s0 -> (^D_s- => ^K+ ^K- ^pi-) ^K+, B_s~0 -> (^D_s+ => ^K- ^K+ ^pi+) ^K-}";
// H is generically a pion in the HLT
HLTBs2DsKTree.Decay = "{B_s0 -> (^D_s- => ^K+ ^K- ^pi-) ^pi+, B_s~0 -> (^D_s+ => ^K- ^K+ ^pi+) ^pi-}";
HLTBs2DsKTree.MCDecay = "{B_s0 -> (^D_s- => ^K+ ^K- ^pi-) ^K+, B_s0 -> (^D_s+ => ^K- ^K+ ^pi+) ^K-, B_s~0 -> (^D_s+ => ^K- ^K+ ^pi+) ^K-, B_s~0 -> (^D_s- => ^K+ ^K- ^pi-) ^K+}";
HLTBs2DsKTree.NtupleName = "FILE1/HLTBs2DsK";
HLTBs2DsKTree.MCNtupleName = "FILE1/MCHLTBs2DsK";
HLTBs2DsKTree.OutputLevel = 3;
//------------------------------------------------------------------------------
*/

//------------------------------------------------------------------------------
ApplicationMgr.ExtSvc += { "NTupleSvc" };
NTupleSvc.Output={"FILE1 DATAFILE='DVNtuples.root' TYP='ROOT' OPT='NEW'"};
NTupleSvc.OutputLevel = 3;
//------------------------------------------------------------------------------ 

MessageSvc.Format = "% F%60W%S%7W%R%T %0W%M";
ApplicationMgr.EvtMax    = 10; // not reco in pipi (+1 for FirstEvent): record 60, 63, 366, 662, 729, 855, 993
// ApplicationMgr.EvtMax    = -1;
EventSelector.FirstEvent = 1;
EventSelector.PrintFreq  = 1;

// HltTrgChecker.OutputLevel = 2;
// MessageSvc.OutputLevel  = 2;

// L0L1 stripped (DV v12r2)
#include "$HLTSELECTIONSROOT/options/DC04_L0L1_Bd2PiPi.opts"
// #include "$HLTSELECTIONSROOT/options/DC04_L0L1_Bd2KPi.opts"
// #include "$HLTSELECTIONSROOT/options/DC04_L0L1_Bs2KK.opts"
// #include "$HLTSELECTIONSROOT/options/DC04_L0L1_Bs2PiK.opts"
// #include "$HLTSELECTIONSROOT/options/DC04_L0L1_Bs_phiphi.opts"
// #include "$HLTSELECTIONSROOT/options/DC04_L0L1_Bd_D0_KPi_Kstar.opts"
// #include "$HLTSELECTIONSROOT/options/DC04_L0L1_Bd_DstarPi.opts"
// #include "$HLTSELECTIONSROOT/options/DC04_L0L1_Bs_DsPi.opts"
// #include "$HLTSELECTIONSROOT/options/DC04_L0L1_Bs_DsK.opts"

// sums of the above
// #include "$HLTSELECTIONSROOT/options/DC04_L0L1_Signals.opts"
// #include "$HLTSELECTIONSROOT/options/DC04_L0L1_B2HH.opts"
// #include "$HLTSELECTIONSROOT/options/DC04_L0L1_Bs_DsH.opts"
