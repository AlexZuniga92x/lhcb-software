// $Id: HltTFunctionFactory.icpp,v 1.8 2008-12-03 12:50:21 graven Exp $
// Include files

#include "HltBase/EFunctions.h"
#include "HltBase/EParser.h"
#include "HltBase/ESequences.h"


// local
#include "HltTFunctionFactory.h"

//-----------------------------------------------------------------------------
// Implementation file for class : HltTFilter
//
// 2007-03-22 : Jose Angel Hernando Morata
//-----------------------------------------------------------------------------

template <class T>
HltTFunctionFactory<T>::HltTFunctionFactory( const std::string& type,
                                             const std::string& name,
                                             const IInterface* parent )
  : HltBaseTool( type, name , parent )
{
  declareInterface< IFunctionFactory<T> >(this);
  declareProperty("Smart", m_smart = true);
}

template <class T>
HltTFunctionFactory<T>::~HltTFunctionFactory( ) {
    for (typename std::map<std::string, Hlt::IFunctionCreator<T>* >::iterator i = m_creators.begin(); i!=m_creators.end(); ++i) {
        delete i->second;
    }
    m_creators.clear();
} 

template <class T>
StatusCode HltTFunctionFactory<T>::initialize() {
  
  return HltBaseTool::initialize();
}

template <class T>
bool HltTFunctionFactory<T>::command(const std::string& command,
                                     const std::string & value) {
  debug() << " command " << command << " value " << value << endreq;
  if ((command == "AddInfo") && (value == "false")) {
    m_smart = false;
    debug() << " Creating (no smart) filters " << endreq;
  }
  return true;
}

template <class T>
zen::function<T>* HltTFunctionFactory<T>::function(const std::string& fn) {

  std::vector<std::string> cromos = EParser::parse(fn,",");
  std::vector<std::string> gens = EParser::parse(cromos[0],"_");
  std::string name = gens[0];
  
  Assert((m_creators.find(name) != m_creators.end()),
         " function() no function in factory "+fn);
  
  std::string input2;
  HltAlgorithm *parent(0);
  if (gens.size() == 2) {
    input2 = gens[1];
    parent = dynamic_cast<HltAlgorithm*>(contextSvc()->currentAlg());
    Assert(parent!=0," could not obtain HltAlgorithm from context...");
    // FIXME: this is the only instance when 'input2' and 'parent' are actually needed...
    // FIXME: all others do NOT need it, and require input2 to be actually empty...
    // FIXME: so the real problem is that m_creators does not follow the Liskov 
    // FIXME: substitution principle...
  }
  zen::function<T>* fun = m_creators[name]->create(input2,parent);

  if (m_smart && fun) {
    int id = hltInfoID(name);
    zen::function<T>* fun1 = fun;
    fun = new Hlt::SmartFunction<T>(id,*fun1);
    debug() << " created smart function " << name << " id " << id << endreq;
    delete fun1;
  }
  return fun;
}

template <class T>
zen::filter<T>* HltTFunctionFactory<T>::filter(const std::string& name) {
  
  std::string funname,mode;
  double x0 = 0.;
  double xf = 1e6;
  bool ok = EParser::parseFilter(name,funname,mode,x0,xf);
  Assert(ok, " filter() not able to parse filtername"+ name);

  debug() << " function " << funname 
          << " operation " << mode
          << " range " << x0 << ", " <<xf <<endreq;
  
  zen::filter<T>* filter = 0;
  if (m_smart) {
    int id = hltInfoID(funname);
    Hlt::Info<T> info(id);
    filter = Hlt::makeFilter(info,mode,x0,xf);
  } else {
    zen::function<T>* fun = function(funname);
    filter = Hlt::makeFilter(*fun,mode,x0,xf);
    delete fun;
  }
  
  Assert( 0 != filter, " filter() can not crete filter "+name);
  debug() << " created filter " << name << endreq;
  
  return filter;
}
