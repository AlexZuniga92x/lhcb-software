// $Id: HltTFilter.icpp,v 1.9 2008-06-23 11:22:58 graven Exp $
// Include files

#include "HltBase/EDictionary.h"
#include "HltBase/EParser.h"
#include "HltBase/ESequences.h"

// local
#include "HltTFilter.h"

//-----------------------------------------------------------------------------
// Implementation file for class : HltTFilter
//
// 2007-03-22 : Jose Angel Hernando Morata
//-----------------------------------------------------------------------------


template <class T>
HltTFilter<T>::HltTFilter( const std::string& name,
                           ISvcLocator* pSvcLocator,
                           const std::string& factoryname,
                           bool tesInput)
  : HltAlgorithm ( name , pSvcLocator )
  , m_tesInput(tesInput)
  , m_functionFactoryName( factoryname )
{
  
  declareProperty("FunctionFactoryName", m_functionFactoryName);
  declareProperty("FilterDescriptor", m_filterDescriptor);
  declareProperty("AddInfo", m_addInfo = true);

  m_tselinput = 0;
  m_tseloutput = 0;
  
  m_tinput = 0;
  m_toutput = 0;

}

template <class T>
HltTFilter<T>::~HltTFilter() {
  if (m_tesInput) delete m_tinput;
  // TODO delete m_tfilters!!
}

template <class T>
StatusCode HltTFilter<T>::initialize() {

  StatusCode sc = HltAlgorithm::initialize();

  // inputs
  if (m_tesInput) m_considerInputs = false;
  
  if (!m_tesInput) {
    debug() << "Selection from HltData " << endreq;
    m_tselinput = &(retrieveTSelection<T>(m_inputSelectionName));
    m_tinput = m_tselinput;
  } else {
    debug() << "Data from TES " << endreq;
    m_tinput = new std::vector<T*>();
  }
  
  Assert( 0 != m_tinput," initialize() no input ");
  
  // filters
  m_factory = tool< IFunctionFactory<T> >(m_functionFactoryName,this);
  Assert( 0 != m_factory," initialize() no factory " + m_functionFactoryName);
  m_factory->command("AddInfo", m_addInfo?"true":"false");
  
  const std::vector<std::string>& cromos = m_filterDescriptor.value();
  for (std::vector<std::string>::const_iterator it = cromos.begin();       
       it != cromos.end(); it++) addTFilterData(*it);

  // output
  if (!outputSelectionName().empty()) {
    m_tseloutput = &(registerTSelection<T>());
    m_toutput = m_tseloutput;
  }
  
  Assert( 0 != m_toutput, " initialize() no output");
  
  // save configuration
  saveConfiguration();
  
  return  sc;
  
}

template <class T>
bool HltTFilter<T>::addTFilterData(const std::string& descriptor) {
  debug() << " filter descriptor " << descriptor << endreq;
  TFilterData* ptf = new TFilterData(descriptor);
  TFilterData& tf = *ptf;
  bool ok = EParser::parseFilter(tf.filtername, tf.functionname,
                                 tf.operation,tf.minvalue,tf.maxvalue);
  debug() << " function name " << tf.functionname
          << " operation " << tf.operation
          << " range " << tf.minvalue 
          << ", " << tf.maxvalue <<endreq;
  if (!ok)
    error() << " can not create TFilter "<< descriptor << endreq;

  std::vector<std::string> cromos = EParser::parse(tf.functionname,"_");
  if (cromos.size() == 2) {
    tf.input2 = cromos[1];
    debug() << " bind function against input " << tf.input2 << endreq;
    //TODO pass this on explicitly into the factory, as map 'label' -> selection
    //i.e. _here_ is where we interpret the 'label'...
    retrieveSelection(tf.input2);
  }
  tf.function.reset( m_factory->function(tf.functionname) );
  Assert( 0 != tf.function.get(),
          " addTFilterData() function no created"+tf.functionname);
  tf.filter.reset(  m_factory->filter(tf.filtername) );
  Assert( 0 != tf.filter.get(),
          " addTFilterData() filter no created"+tf.filtername);
  tf.infoID = 0;
  if (m_addInfo) tf.infoID = hltInfoID(tf.functionname);
  if (tf.operation != ">") tf.isMin = true;
  initializeCounter(tf.counter,tf.filtername);
  initializeCounter(tf.counterCandidates,tf.filtername+" candidates ");
  if (produceHistos()) {
    tf.histovalues = initializeHisto(tf.functionname,0.,100.,100);
    tf.histobest  = initializeHisto(tf.functionname+"Best",0.,100.,100);
  }
  debug() << " filtername " << tf.filtername
          << " function " << tf.function.get()
          << " filter " << tf.filter.get()
          << " counter  " << tf.counter
          << " counterCandidates  " << tf.counterCandidates
          << " histovalues " << tf.histovalues
          << " histobest " << tf.histobest
          << endreq;
  m_tfilters.push_back(ptf);
  return ok;  
}


template <class T>
void HltTFilter<T>::saveConfiguration() {
  HltAlgorithm::saveConfiguration();

  const std::vector<std::string>& filters = m_filterDescriptor.value();
  confregister("Filters",filters);
  info() << " HLT filters " << filters << endreq;
}


template <class T>
StatusCode HltTFilter<T>::execute() {

  StatusCode sc= StatusCode::SUCCESS;
  debug() << "==> Execute" << endmsg;

  // TODO: move this to baseclass....
  // if the input is not a HltSelection but a container in TES
  if (m_tesInput) {
    typedef KeyedContainer<T,Containers::HashMap> TESCONT;
    TESCONT* ttes = this->get<TESCONT>(m_inputSelectionName);
    m_tinput->clear();
    m_tinput->insert(m_tinput->end(),ttes->begin(),ttes->end());
  }

  // check size of the input container
  if (m_tinput->empty()) {
    debug() << " No data in TES " << m_inputSelectionName << endreq;    
    return sc;
  }

  // if no filters, copy input container
  if (m_tfilters.empty()) *m_toutput = *m_tinput; // zen::copy(*m_tinput,*m_toutput);

  // loop in filters, and apply to the surviving objects
  size_t ncan = 0, i = 0;
  for (TFilterDataIterator it = m_tfilters.begin();
       it != m_tfilters.end(); ++it, ++i) {
    
    TFilterData& tf = *(*it);
    
    std::vector<T*>  ttemp( i==0 ? *m_tinput : *m_toutput );

    verbose() << " applying filter " << tf.filtername << endreq;
    verbose() << " input objects " << ttemp.size() << endreq;

    if (m_addInfo) addInfo(ttemp,*tf.function,tf.infoID);

    // debug and monitor
    if ((m_debug || produceHistos()) && m_addInfo) {
      std::vector<double> vals = infos(ttemp,tf.infoID);
      double val = *( tf.isMin ? std::min_element(vals.begin(),vals.end()) 
                               : std::max_element(vals.begin(),vals.end()) );
      if (m_debug) {
        std::string name = tf.filtername+" : ";
        for(std::vector<double>::const_iterator i=vals.begin();i!=vals.end();++i)
             debug() << *i << ", ";
        debug() << endreq; 
        debug() << " best " << val << endreq;
      }
      fillHisto(*tf.histovalues,vals,1.);
      fillHisto(*tf.histobest,val,1.);
    }

    // filter
    
    m_toutput->clear();
    zen::select(ttemp.begin(),ttemp.end(),*tf.filter,std::back_inserter(*m_toutput));

    ncan = m_toutput->size();
    debug() << " filtered  " << ncan << endreq;
    
    // continue or break
    if (ncan <=0) break;
    increaseCounter(tf.counter,1);
    increaseCounter(tf.counterCandidates,ncan);

  }
  return sc;
}


template <class T>
StatusCode HltTFilter<T>::finalize() {

  debug() << "==> Finalize" << endmsg;
  StatusCode sc =  HltAlgorithm::finalize();  

  for (TFilterDataIterator it = m_tfilters.begin(); 
       it != m_tfilters.end(); ++it) {
    TFilterData& tf = *(*it);
    std::string title =  " event accepted " + tf.filtername + " / input ";
    infoSubsetEvents(tf.counter,m_counterEntries,title);
    infoCandidates(tf.counterCandidates,tf.counter," passed "+tf.filtername);
  }

  return sc;
}


template <class T>
void HltTFilter<T>::addInfo(TContainer& cont, TFunction& fun, int infoID) {
  debug() << " adding info " <<infoID << " fun " << &fun 
          << " at nobjs " <<cont.size() << endreq;
  for (TContainerIterator it = cont.begin(); it != cont.end(); ++it) {
    T& t = *(*it);
    double d = fun(t);
    verbose() << " computed Info " << d << endreq;
    t.addInfo(infoID,d);
  }
}


template <class T>
std::vector<double> HltTFilter<T>::infos(TContainer& cont, int infoID) {
  std::vector<double> values;
  for (TContainerIterator it = cont.begin(); it != cont.end(); ++it) 
    values.push_back( (*it)->info(infoID,1e6));
  return values;
}
