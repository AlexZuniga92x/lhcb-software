// $Id: HltTFilter.icpp,v 1.13 2008-12-19 17:32:08 graven Exp $
// Include files

#include "HltBase/EParser.h"
#include <functional>
#include "boost/lambda/construct.hpp"
#include "boost/foreach.hpp"
#include "boost/ref.hpp"
#include "boost/iterator/indirect_iterator.hpp"


template <typename T> class adaptor {
public:
    typedef typename T::result_type result_type;
    typedef typename T::argument_type* argument_type;
    adaptor(T& t) : m_t(t) {}
    result_type operator()(argument_type x) { return !m_t(*x); }
private:
    T& m_t;
};

template <typename T> adaptor<T> make_adaptor(T& t) { return adaptor<T>(t); }

// local
#include "HltTFilter.h"

//-----------------------------------------------------------------------------
// Implementation file for class : HltTFilter
//
// 2007-03-22 : Jose Angel Hernando Morata
//-----------------------------------------------------------------------------

template <class T>
HltTFilter<T>::HltTFilter( const std::string& name,
                           ISvcLocator* pSvcLocator,
                           const std::string& factoryname)
  : HltAlgorithm ( name , pSvcLocator )
  , m_selections(*this)
  , m_functionFactoryName( factoryname )
{
  declareProperty("FunctionFactoryName", m_functionFactoryName);
  declareProperty("FilterDescriptor", m_filterDescriptor);
  declareProperty("AddInfo", m_addInfo = true);
  m_selections.declareProperties();
}

template <class T>
HltTFilter<T>::~HltTFilter() {
}

template <class T>
StatusCode HltTFilter<T>::initialize() {

  StatusCode sc = HltAlgorithm::initialize();

  // input
  m_selections.retrieveSelections();
  
  // filters (which may, through binding, request additional inputs!)
  m_factory = tool< IFunctionFactory<T> >(m_functionFactoryName,this);
  m_factory->command("AddInfo", m_addInfo? "true" : "false" ); //@TODO: avoid global state to make config switches easier...
  
  BOOST_FOREACH( const std::string& descriptor, m_filterDescriptor.value() ) {
        addTFilterData(descriptor);
  }

  // output
  m_selections.registerSelection();
  
  // save configuration
  saveConfiguration();
  
  return  sc;
  
}

template <class T>
bool HltTFilter<T>::addTFilterData(const std::string& descriptor) {
  debug() << " filter descriptor " << descriptor << endreq;
  TFilterData* ptf = new TFilterData(descriptor);
  bool ok = EParser::parseFilter(ptf->filtername, ptf->functionname,
                                 ptf->operation,ptf->minvalue,ptf->maxvalue);
  debug() << " function name " << ptf->functionname
          << " operation " << ptf->operation
          << " range " << ptf->minvalue 
          << ", " << ptf->maxvalue <<endreq;

  if (!ok) {
    error() << " can not create TFilter "<< descriptor << endreq;
    return ok;
  }

  ptf->function.reset( m_factory->function(ptf->functionname) );
  Assert( 0 != ptf->function.get(),
          " addTFilterData() function no created"+ptf->functionname);
  ptf->filter.reset(  m_factory->filter(ptf->filtername) );
  Assert( 0 != ptf->filter.get(),
          " addTFilterData() filter no created"+ptf->filtername);
  ptf->infoID = ( m_addInfo ? hltInfoID(ptf->functionname) : 0 );
  if (produceHistos()) {
    ptf->histovalues = initializeHisto(ptf->functionname,       0.,100.,100);
    ptf->histobest   = initializeHisto(ptf->functionname+"Best",0.,100.,100);
  }
  debug() << " filtername " << ptf->filtername
          << " function " << ptf->function.get()
          << " filter " << ptf->filter.get()
          << " counter  " << ptf->counter
          << " counterCandidates  " << ptf->counterCandidates
          << " histovalues " << ptf->histovalues
          << " histobest " << ptf->histobest
          << endreq;
  m_tfilters.push_back(ptf);
  return ok;  
}


template <class T>
void HltTFilter<T>::saveConfiguration() {
  HltAlgorithm::saveConfiguration();

  const std::vector<std::string>& filters = m_filterDescriptor.value();
  confregister("Filters",filters);
  info() << " HLT filters " << filters << endreq;
}


template <class T>
StatusCode HltTFilter<T>::execute() {

  StatusCode sc= StatusCode::SUCCESS;
  debug() << "==> Execute" << endmsg;

  Hlt::TSelection<T>* in  = m_selections.template input<1>();
  Hlt::TSelection<T>* out = m_selections.output();


  // check size of the input container
  if (in->empty()) {
    debug() << " No input data " << in->id() << endreq;    
    return sc;
  }

  // start by copying input
  out->clean();
  out->insert(out->end(), in->begin(), in->end());

  // loop in filters, and apply to the surviving objects
  BOOST_FOREACH( TFilterData *filter, m_tfilters ) {

    verbose() << " applying filter " << filter->filtername << endreq;
    verbose() << " input objects " << out->size() << endreq;

    if (m_addInfo) {
      BOOST_FOREACH( T* cand, *out ) cand->addInfo(filter->infoID,(*filter->function)(*cand));
    }


    // debug and monitor
    if ((m_debug || produceHistos()) && m_addInfo) {
      std::vector<double> vals; vals.reserve(m_selections.output()->size());
      BOOST_FOREACH( T* cand, *out) vals.push_back( cand->info(filter->infoID,1e6));

      double val = *( filter->isMin() ? std::min_element(vals.begin(),vals.end()) 
                                      : std::max_element(vals.begin(),vals.end()) );
      if (m_debug) {
        std::string name = filter->filtername+" : ";
        for(std::vector<double>::const_iterator i=vals.begin();i!=vals.end();++i)
             debug() << *i << ", ";
        debug() << endreq; 
        debug() << " best " << val << endreq;
      }
      fillHisto(*filter->histovalues,vals,1.);
      fillHisto(*filter->histobest,val,1.);
    }

    // filter 
    out->erase( std::remove_if( out->begin(), 
                                out->end(),
                                make_adaptor(*filter->filter) ),
                out->end() );

    size_t ncan = out->ncandidates();
    debug() << " filtered  " << ncan << endreq;
    
    // continue or break
    if (out->empty()) break;
    filter->counter.increase(1);
    filter->counterCandidates.increase(ncan);
  }
  return sc;
}


template <class T>
StatusCode HltTFilter<T>::finalize() {

  debug() << "==> Finalize" << endmsg;
  StatusCode sc =  HltAlgorithm::finalize();  

  BOOST_FOREACH( TFilterData *filter , m_tfilters ) {
    std::string title =  " event accepted " + filter->filtername + " / input ";
    infoSubsetEvents(filter->counter,counterEntries(),title);
    infoCandidates(filter->counterCandidates,filter->counter," passed "+filter->filtername);
  }

  for_each(m_tfilters.begin(),m_tfilters.end(), boost::lambda::delete_ptr());
  m_tfilters.clear();

  return sc;
}
