// $Id: HltTFilter.icpp,v 1.11 2008-07-04 12:45:33 graven Exp $
// Include files

#include "HltBase/EDictionary.h"
#include "HltBase/EParser.h"
#include "HltBase/ESequences.h"

// local
#include "HltTFilter.h"

//-----------------------------------------------------------------------------
// Implementation file for class : HltTFilter
//
// 2007-03-22 : Jose Angel Hernando Morata
//-----------------------------------------------------------------------------

template <class T>
HltTFilter<T>::HltTFilter( const std::string& name,
                           ISvcLocator* pSvcLocator,
                           const std::string& factoryname,
                           bool tesInput)
  : HltAlgorithm ( name , pSvcLocator )
  , m_tesInput(tesInput)
  , m_tselinput(0)
  , m_tseloutput(0)
  , m_functionFactoryName( factoryname )
{
  declareProperty("FunctionFactoryName", m_functionFactoryName);
  declareProperty("FilterDescriptor", m_filterDescriptor);
  declareProperty("AddInfo", m_addInfo = true);
}

template <class T>
HltTFilter<T>::~HltTFilter() {
  if (m_tesInput) delete m_tselinput;
  // TODO delete m_tfilters!!
}

template <class T>
StatusCode HltTFilter<T>::initialize() {

  StatusCode sc = HltAlgorithm::initialize();

  // input
  if (!m_tesInput) {
    debug() << "Selection from HltData " << endreq;
    m_tselinput = &(retrieveTSelection<T>(m_inputSelectionName));
  } else {
    m_considerInputs = false;
    debug() << "Data from TES " << endreq;
    m_tselinput = new TSelection(m_inputSelectionName);
  }
  
  // filters
  m_factory = tool< IFunctionFactory<T> >(m_functionFactoryName,this);
  m_factory->command("AddInfo", m_addInfo? "true" : "false" ); //@TODO: avoid global state to make config switches easier...
  
  const std::vector<std::string>& cromos = m_filterDescriptor.value();
  for (std::vector<std::string>::const_iterator it = cromos.begin();       
       it != cromos.end(); it++) addTFilterData(*it);

  // output
  m_tseloutput = &(registerTSelection<T>());
  
  // save configuration
  saveConfiguration();
  
  return  sc;
  
}

template <class T>
bool HltTFilter<T>::addTFilterData(const std::string& descriptor) {
  debug() << " filter descriptor " << descriptor << endreq;
  TFilterData* ptf = new TFilterData(descriptor);
  TFilterData& tf = *ptf;
  bool ok = EParser::parseFilter(tf.filtername, tf.functionname,
                                 tf.operation,tf.minvalue,tf.maxvalue);
  debug() << " function name " << tf.functionname
          << " operation " << tf.operation
          << " range " << tf.minvalue 
          << ", " << tf.maxvalue <<endreq;

  if (!ok) {
    error() << " can not create TFilter "<< descriptor << endreq;
    return ok;
  }

  tf.function.reset( m_factory->function(tf.functionname) );
  Assert( 0 != tf.function.get(),
          " addTFilterData() function no created"+tf.functionname);
  tf.filter.reset(  m_factory->filter(tf.filtername) );
  Assert( 0 != tf.filter.get(),
          " addTFilterData() filter no created"+tf.filtername);
  tf.infoID = ( m_addInfo ? hltInfoID(tf.functionname) : 0 );
  initializeCounter(tf.counter,          tf.filtername);
  initializeCounter(tf.counterCandidates,tf.filtername+" candidates ");
  if (produceHistos()) {
    tf.histovalues = initializeHisto(tf.functionname,       0.,100.,100);
    tf.histobest   = initializeHisto(tf.functionname+"Best",0.,100.,100);
  }
  debug() << " filtername " << tf.filtername
          << " function " << tf.function.get()
          << " filter " << tf.filter.get()
          << " counter  " << tf.counter
          << " counterCandidates  " << tf.counterCandidates
          << " histovalues " << tf.histovalues
          << " histobest " << tf.histobest
          << endreq;
  m_tfilters.push_back(ptf);
  return ok;  
}


template <class T>
void HltTFilter<T>::saveConfiguration() {
  HltAlgorithm::saveConfiguration();

  const std::vector<std::string>& filters = m_filterDescriptor.value();
  confregister("Filters",filters);
  info() << " HLT filters " << filters << endreq;
}


template <class T>
StatusCode HltTFilter<T>::execute() {

  StatusCode sc= StatusCode::SUCCESS;
  debug() << "==> Execute" << endmsg;

  // TODO: move this to baseclass....
  // if the input is not a HltSelection but a container in TES
  if (m_tesInput) {
    typedef KeyedContainer<T,Containers::HashMap> TESCONT;
    TESCONT* ttes = this->get<TESCONT>(m_inputSelectionName);
    m_tselinput->clean();
    m_tselinput->insert(m_tselinput->end(),ttes->begin(),ttes->end());
  }

  // check size of the input container
  if (m_tselinput->empty()) {
    debug() << " No data " << m_inputSelectionName << endreq;    
    return sc;
  }

  // if no filters, copy input container
  if (m_tfilters.empty()) *m_tseloutput = *m_tselinput;

  // loop in filters, and apply to the surviving objects
  size_t ncan = 0, i = 0;
  for (TFilterDataIterator it = m_tfilters.begin();
       it != m_tfilters.end(); ++it, ++i) {
    
    TFilterData& tf = *(*it);
    
    std::vector<T*>  ttemp( i==0 ? m_tselinput->begin() : m_tseloutput->begin(),
                            i==0 ? m_tselinput->end()   : m_tseloutput->end());

    verbose() << " applying filter " << tf.filtername << endreq;
    verbose() << " input objects " << ttemp.size() << endreq;

    if (m_addInfo) {
      for (typename std::vector<T*>::const_iterator i = ttemp.begin(); i != ttemp.end(); ++i) {
        (*i)->addInfo(tf.infoID,(*tf.function)(**i));
      }
    }

    // debug and monitor
    if ((m_debug || produceHistos()) && m_addInfo) {
      std::vector<double> vals; vals.reserve(ttemp.size());
      for (typename std::vector<T*>::const_iterator i = ttemp.begin(); i != ttemp.end(); ++i) 
            vals.push_back( (*i)->info(tf.infoID,1e6));
      double val = *( tf.isMin() ? std::min_element(vals.begin(),vals.end()) 
                                 : std::max_element(vals.begin(),vals.end()) );
      if (m_debug) {
        std::string name = tf.filtername+" : ";
        for(std::vector<double>::const_iterator i=vals.begin();i!=vals.end();++i)
             debug() << *i << ", ";
        debug() << endreq; 
        debug() << " best " << val << endreq;
      }
      fillHisto(*tf.histovalues,vals,1.);
      fillHisto(*tf.histobest,val,1.);
    }

    // filter
    
    m_tseloutput->clean();
    zen::select(ttemp.begin(),ttemp.end(),*tf.filter,std::back_inserter(*m_tseloutput));

    ncan = m_tseloutput->size();
    debug() << " filtered  " << ncan << endreq;
    
    // continue or break
    if (ncan <=0) break;
    increaseCounter(tf.counter,1);
    increaseCounter(tf.counterCandidates,ncan);

  }
  return sc;
}


template <class T>
StatusCode HltTFilter<T>::finalize() {

  debug() << "==> Finalize" << endmsg;
  StatusCode sc =  HltAlgorithm::finalize();  

  for (TFilterDataIterator it = m_tfilters.begin(); 
       it != m_tfilters.end(); ++it) {
    TFilterData& tf = *(*it);
    std::string title =  " event accepted " + tf.filtername + " / input ";
    infoSubsetEvents(tf.counter,m_counterEntries,title);
    infoCandidates(tf.counterCandidates,tf.counter," passed "+tf.filtername);
  }

  return sc;
}
