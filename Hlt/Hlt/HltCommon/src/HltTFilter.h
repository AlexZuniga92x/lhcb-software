// $Id: HltTFilter.h,v 1.13 2009-11-09 17:32:17 aperezca Exp $
#ifndef HLTCOMMON_HLTTFILTER_H 
#define HLTCOMMON_HLTTFILTER_H 1

// Include files
// from Gaudi
#include "HltBase/HltAlgorithm.h"
#include "HltBase/HltSelectionContainer.h"
#include "HltBase/IFunctionFactory.h"

/** @class HltTrackFilter HltTrackFilter.h
 *  
 *
 *  @author Jose Angel Hernando Morata
 *  @date   2007-03-22
 */

namespace Hlt {
  template <class T>
  class TFilterData {
  public:
      template <typename P>
    TFilterData(const std::string& name, P& parent, 
                const std::string& prefix) 
      : filtername(name)
        , counter(parent.counter(prefix+name))
        , counterCandidates(parent.counter(prefix+name+" candidates"))
        , minvalue(-1e6)
        , maxvalue(1e6)
    {}
    virtual ~TFilterData()  {}
  private:
    // make sure the copy c'tor is not autogenerated
    TFilterData(const TFilterData<T>&);
  public:    
    std::string filtername;
    std::string functionname;
    std::string input2;
    int infoID;
    std::auto_ptr<zen::function<T> > function;
    std::auto_ptr<zen::filter<T> > filter;
    StatEntity& counter;
    StatEntity& counterCandidates;
    std::string operation;
    double minvalue;
    double maxvalue;
    //bool isMin() const { return operation!=">"; } //This can't deal with absolute value!
    bool isMin() const { return operation.find(">")==std::string::npos; }
    bool isAbs() const { return operation.find("||")!=std::string::npos; }

    AIDA::IHistogram1D* histovalues;
    AIDA::IHistogram1D* histobest;
  };  
}

template <class T>
class HltTFilter : public HltAlgorithm {
public: 
  /// Standard constructor
  HltTFilter( const std::string& algoname, ISvcLocator* pSvcLocator, const std::string& factoryName );

  virtual ~HltTFilter( );

  virtual StatusCode initialize();
  virtual StatusCode execute   ();
  virtual StatusCode finalize  ();

private:
  typedef typename Hlt::TFilterData<T> TFilterData;
  typedef typename std::vector<TFilterData*>::iterator TFilterDataIterator;

  bool addTFilterData(const std::string& filtername);

  bool m_addInfo;

  Hlt::SelectionContainer2<T,T> m_selections;

  StringArrayProperty m_filterDescriptor;
  std::vector< TFilterData* > m_tfilters;

  std::string m_functionFactoryName;
  IFunctionFactory<T>* m_factory;

  // index to keep the counter of the cuts
  size_t  m_index;
};
#endif // HLTTRACKFILTER_H
