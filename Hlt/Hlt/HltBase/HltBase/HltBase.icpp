// $Id: HltBase.icpp,v 1.8 2008-05-15 08:56:54 graven Exp $
// Include files


// local
#include "HltBase/HltBase.h"
#include "Event/HltSummary.h"
#include "Event/RecVertex.h"
#include "HltBase/HltConfigurationHelper.h"

//-----------------------------------------------------------------------------
// Implementation file for class : HltBase
//
// 2006-06-15 : Jose Angel Hernando Morata
//-----------------------------------------------------------------------------

template <class EBASE>
void HltBase<EBASE>::create() {
  
  EBASE::declareProperty("HistoDescriptor", m_histoDescriptor);
  EBASE::declareProperty("HltDataLocation", 
                         m_hltDataLocation = 
                         LHCb::HltSummaryLocation::Default+"/Data");
  EBASE::declareProperty("HltConfigurationLocation", 
                         m_hltConfigurationLocation = 
                         LHCb::HltSummaryLocation::Default+"/Configuration");

  m_TES = false;
  m_monitor = true;
  m_hltSvc  = 0;
  m_hltData = 0;
  m_hltConf = 0;
}

template <class EBASE>
HltBase<EBASE>::~HltBase() {} 

template <class EBASE>
StatusCode HltBase<EBASE>::initialize() {  
  EBASE::debug() << "==> Initialize -- calling " <<System::typeinfoName( typeid(EBASE) ) <<  "::initialize"<< endreq;
  StatusCode sc = EBASE::initialize(); 
  if ( sc.isFailure() ) return sc;  // error printed already by GaudiAlgorithm
  
  if (!EBASE::service( "HltANNSvc", m_hltANNSvc).isSuccess()) return StatusCode::FAILURE;
  
  initializeMsg();
  initializeHistosFromDescriptor();

  return StatusCode::SUCCESS;

}

template <class EBASE>
StatusCode HltBase<EBASE>::finalize() {  
  if (m_hltANNSvc) m_hltANNSvc->release();
  if (m_hltSvc) m_hltSvc->release();
  EBASE::debug() << "==> Finalize -- calling " <<System::typeinfoName( typeid(EBASE) ) <<  "::finalize"<< endreq;
  return EBASE::finalize();
}  

template <class EBASE>
void HltBase<EBASE>::initializeMsg() {

  m_verbose = EBASE::msgLevel(MSG::VERBOSE);             
  m_debug   = EBASE::msgLevel(MSG::DEBUG)   || m_verbose ;
  m_info    = EBASE::msgLevel(MSG::INFO)    || m_debug   ;
  m_warning = EBASE::msgLevel(MSG::WARNING) || m_info    ;
  m_error   = EBASE::msgLevel(MSG::ERROR)   || m_warning ;
  m_fatal   = true;

  EBASE::debug() << " msg level " 
                 << m_info << m_debug << m_verbose << endreq;
}

template <class EBASE>
void HltBase<EBASE>::infoTotalEvents(int n) {
  EBASE::info() << " N Entries: \t" << n << endreq;
}

template <class EBASE>
void HltBase<EBASE>::infoSubsetEvents(  int nEventsInSubset, int  nTotEvts, 
                                    const std::string& subsetName)
{
  double f = (nTotEvts<=0? 0.: float(nEventsInSubset)/float(nTotEvts) );
  EBASE::info() << " N " <<subsetName << "\t" << nEventsInSubset 
         << " (" << 100.*f << "%)" << endreq;
}

template <class EBASE>
void HltBase<EBASE>::infoCandidates(  int nTotCandidates, int  nTotEvts, 
                                      const std::string& comment)
{
  double f = (nTotEvts<=0? 0.: double(nTotCandidates)/double(nTotEvts) );
  EBASE::info() << " N  candidates " << comment << " \t" << f  << endreq;
}

template <class EBASE>
void HltBase<EBASE>::initializeHistosFromDescriptor() {

  if (!m_monitor) return;

  const std::map<std::string, Gaudi::Histo1DDef>& hdes =
    m_histoDescriptor.value();
  for (std::map<std::string, Gaudi::Histo1DDef>::const_iterator 
         it = hdes.begin(); it != hdes.end(); it++){
      EBASE::book(it->second);
      EBASE::debug() << " booking histo from descriptor " 
                     << it->second << endreq;
  }
  
}

template <class EBASE>
Hlt::Histo* HltBase<EBASE>::initializeHisto(const std::string& title,
                                            float x0, float xf, int nbins) {
  Hlt::Histo* histo = 0;
  if (!m_monitor) return histo;

  const std::map<std::string,Gaudi::Histo1DDef>& values = 
        m_histoDescriptor.value();
  std::map<std::string,Gaudi::Histo1DDef>::const_iterator i = 
        values.find(title);
  Gaudi::Histo1DDef hd = (i!=values.end()) ? i->second 
                                           : Gaudi::Histo1DDef(title,x0,xf,nbins);
  EBASE::debug() << " booking histo  " << hd << endreq;
  return EBASE::book(hd);
};

template <class EBASE>
void HltBase<EBASE>::fillHisto( Hlt::Histo& histo, float x, float weight) {
  if (!m_monitor) return;
  EBASE::fill( &histo , x, weight);
}

template <class EBASE>
void HltBase<EBASE>::fillHisto( Hlt::Histo& histo, 
                                const std::vector<double>& x, 
                                float weight) {
  if (!m_monitor) return;
  for (std::vector<double>::const_iterator it = x.begin(); it != x.end();
       ++it)
    EBASE::fill( &histo, (*it), weight);
}

//FIXME: don't use member data of Hlt::Counter directly...
template <class EBASE>
void HltBase<EBASE>::initializeCounter (Hlt::Counter& counter, 
                                        const std::string& inputString) { 
  counter.m_name = inputString;
  counter.m_histo = 0;
  counter.m_counter = 0;
  // if (m_monitor >0)
  //  counter.m_histo = initializeHisto(inputString,0.,1.,1);
  EBASE::debug() << " counter " << counter.m_name 
                 << " " << counter.m_counter << endreq;
};

template <class EBASE>
void HltBase<EBASE>::increaseCounter( Hlt::Counter& count, 
                                           int increase) {
  count.m_counter =  count.m_counter + increase;
  EBASE::verbose() << " counter " << count.m_name 
                   << " = " << count.m_counter << endreq;;
  // if (count.m_histo)
  //  EBASE::fill( count.m_histo, 0.5, 1.*increase);
}

template <class EBASE>
IDataProviderSvc& HltBase<EBASE>::hltSvc() const {
  if (m_hltSvc == 0) {
  StatusCode sc = EBASE::serviceLocator()->service("HltSvc", m_hltSvc);
    EBASE::Assert( sc.isSuccess() && m_hltSvc != 0, " hltSvc() no HltDataSvc");
  }
  return *m_hltSvc;
}

template <class EBASE>
IANNSvc& HltBase<EBASE>::annSvc() const {
  if (m_hltANNSvc == 0) {
    StatusCode sc = EBASE::serviceLocator()->service("HltANNSvc", m_hltANNSvc);
    EBASE::Assert( sc.isSuccess() && m_hltANNSvc != 0, " no HltANNSvc??");
  }
  return *m_hltANNSvc;
}

template <class EBASE>
Hlt::Data& HltBase<EBASE>::hltData() 
{
  if (m_hltData != 0) return *m_hltData;

  SmartDataPtr<Hlt::Data> obj(m_TES ? EBASE::evtSvc() 
                                    : &hltSvc() ,
                              "/Event/"+m_hltDataLocation);
  m_hltData = obj;
  EBASE::Assert( m_hltData != 0, " hltData() no Hlt::Data");
  return *m_hltData;
}



template <class EBASE>
Hlt::Configuration& HltBase<EBASE>::hltConf() 
{
  if (m_hltConf != 0) return *m_hltConf;
  std::string loca = "/Event/"+m_hltConfigurationLocation;
  SmartDataPtr<Hlt::Configuration> obj(&hltSvc(),loca); 
  m_hltConf = obj;
  EBASE::Assert( m_hltConf != 0, " hltConf() no Hlt::Configuration");
  return *m_hltConf;
}


template <class EBASE>
bool HltBase<EBASE>::validHltSelectionName(const stringKey& selname) 
{
    // use optional<int> automatic conversion to bool...
  return annSvc().value("SelectionID",selname.str());
}

template <class EBASE>
int HltBase<EBASE>::hltSelectionID(const stringKey& selname) 
{
    boost::optional<IANNSvc::minor_value_type> i =  annSvc().value("SelectionID",selname.str());
    EBASE::Assert( i, " request for unknown Selection ID");
    return i->second;
}

template <class EBASE>
stringKey HltBase<EBASE>::hltSelectionName(int id) 
{
    boost::optional<IANNSvc::minor_value_type> i =  annSvc().value("SelectionID",id);
    EBASE::Assert( i, " request for unknown Selection ID");
    return i->first;
}

template <class EBASE>
int HltBase<EBASE>::hltInfoID(const std::string& infoname) 
{
    boost::optional<IANNSvc::minor_value_type> i =  annSvc().value("InfoID",infoname);
    EBASE::Assert( i, " request for unknown Info ID");
    return i->second;
}

template <class EBASE>
std::string HltBase<EBASE>::hltInfoName(int id) 
{
    boost::optional<IANNSvc::minor_value_type> i =  annSvc().value("InfoID",id);
    EBASE::Assert( i, " request for unknown Info ID");
    return i->first;
}

template <class EBASE>
void HltBase<EBASE>::printInfo(const std::string& title,
                               const LHCb::Track& track) {
  EBASE::info() << title << " track  " << track.key() 
                << " slopes " << track.slopes()  
                << " pt " << track.pt() 
                << " qop " << track.firstState().qOverP()
                << " ids " << track.lhcbIDs().size() 
                << " states " << track.states().size()
                << endreq;
  printInfo(title+" Info: ",track.extraInfo());
}

template <class EBASE>
void HltBase<EBASE>::printInfo(const std::string& title,
                             const LHCb::RecVertex& vertex) {
  EBASE::info() << title << " vertex  " << vertex.key() << " position " 
               << vertex.position()  << endreq;
  printInfo(title+" Info: ",vertex.extraInfo());
  printInfo(title,vertex.tracks());
}

template<class EBASE>
void HltBase<EBASE>::printInfo(const std::string& title,
                               const GaudiUtils::VectorMap<int,double>& vmap) {
  EBASE::info() << title;
  for (GaudiUtils::VectorMap<int,double>::const_iterator it = vmap.begin(); 
       it != vmap.end(); it++)
    EBASE::info() << hltInfoName(it->first) << " = " 
                  << it->second << "; \t";
  EBASE::info() << endreq;
}
