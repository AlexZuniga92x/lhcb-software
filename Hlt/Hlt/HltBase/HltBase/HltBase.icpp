// $Id: HltBase.icpp,v 1.25 2009-11-26 13:43:28 albrecht Exp $
// Include files


// local
#include "HltBase/HltBase.h"
#include "Event/RecVertex.h"
#include "Event/Track.h"
#include "Event/Particle.h"

//-----------------------------------------------------------------------------
// Implementation file for class : HltBase
//
// 2006-06-15 : Jose Angel Hernando Morata
//-----------------------------------------------------------------------------

template <class EBASE>
void HltBase<EBASE>::hltBaseConstructor() {
  EBASE::declareProperty("HistoDescriptor", m_histoDescriptor);
  m_dataSvc = 0;
  m_hltANNSvc = 0;
}

template <class EBASE>
HltBase<EBASE>::~HltBase() {} 

template <class EBASE>
StatusCode HltBase<EBASE>::initialize() {  
  EBASE::debug() << "==> Initialize -- calling " <<System::typeinfoName( typeid(EBASE) ) <<  "::initialize"<< endreq;
  StatusCode sc = EBASE::initialize(); 
  if ( sc.isFailure() ) return sc;  // error printed already by GaudiAlgorithm

  if (EBASE::produceHistos()) {
      const std::map<std::string, Gaudi::Histo1DDef>& hdes = m_histoDescriptor.value();
      for (std::map<std::string, Gaudi::Histo1DDef>::const_iterator 
             it = hdes.begin(); it != hdes.end(); it++){
          EBASE::book(it->second);
          EBASE::debug() << " booking histogram from descriptor " 
                         << it->second << endreq;
      }
  }
  return StatusCode::SUCCESS;
}


template <class EBASE>
AIDA::IHistogram1D* HltBase<EBASE>::book(const std::string& title) {
  AIDA::IHistogram1D* histo = 0;
  if (!EBASE::produceHistos()) return histo;

  const std::map<std::string,Gaudi::Histo1DDef>& values = m_histoDescriptor.value();
  std::map<std::string,Gaudi::Histo1DDef>::const_iterator i = 
        values.find(title);
  return EBASE::book(  (i!=values.end()) ? i->second 
                                         : Gaudi::Histo1DDef(title,0.,100.,100) );
};

template <class EBASE>
AIDA::IHistogram1D* HltBase<EBASE>::initializeHisto(const std::string& title,
                                            double x0, double xf, int nbins) {
  AIDA::IHistogram1D* histo = 0;
  if (!EBASE::produceHistos()) return histo;

  const std::map<std::string,Gaudi::Histo1DDef>& values = m_histoDescriptor.value();
  std::map<std::string,Gaudi::Histo1DDef>::const_iterator i = 
        values.find(title);
  Gaudi::Histo1DDef hd = (i!=values.end()) ? i->second 
                                           : Gaudi::Histo1DDef(title,x0,xf,nbins);
  EBASE::debug() << " booking histogram  " << hd << endreq;
  return EBASE::book(hd);
};

template <class EBASE>
IHltDataSvc& HltBase<EBASE>::dataSvc() const {
  // see eg. http://womble.decadentplace.org.uk/c++/template-faq.html#disambiguation
  // for an explanation why the keyword 'template' must be inserted to get this to compile...
  if (m_dataSvc == 0)  m_dataSvc = EBASE::template svc<IHltDataSvc>("HltDataSvc",true);
  return *m_dataSvc;
}


template <class EBASE>
IANNSvc& HltBase<EBASE>::annSvc() const {
  if (m_hltANNSvc == 0) m_hltANNSvc = EBASE::template svc<IANNSvc>("HltANNSvc",true);
  return *m_hltANNSvc;
}


template <class EBASE>
int HltBase<EBASE>::hltInfoID(const std::string& infoname) 
{
  boost::optional<IANNSvc::minor_value_type> i =  annSvc().value("InfoID",infoname);
  if(!i) {
	EBASE::info()<<"request for unknown Info id for name: "<<infoname <<endreq;
	return 0;
  }
 return i->second;
}

template <class EBASE>
std::string HltBase<EBASE>::hltInfoName(int id) 
{
  boost::optional<IANNSvc::minor_value_type> i =  annSvc().value("InfoID",id);
  if(!i) {
	EBASE::info()<<"request for unknown Info name for id: "<<id << endreq;
	return "UNKNOWN";
  }
  return i->first;
}

template <class EBASE>
void HltBase<EBASE>::printInfo(const std::string& title,
                               const LHCb::Track& track) {
  EBASE::info() << title << " track  " << track.key() 
                << " slopes " << track.slopes()  
                << " pt " << track.pt() 
                << " q/p " << track.firstState().qOverP()
                << " ids " << track.lhcbIDs().size() 
                << " states " << track.states().size()
                << endreq;
  printInfo(title+" Info: ",track.extraInfo());
}

template <class EBASE>
void HltBase<EBASE>::printInfo(const std::string& title,
                             const LHCb::RecVertex& vertex) {
  EBASE::info() << title << " vertex  " << vertex.key() << " position " 
               << vertex.position()  << endreq;
  printInfo(title+" Info: ",vertex.extraInfo());
  printInfo(title,vertex.tracks());
}

template<class EBASE>
void HltBase<EBASE>::printInfo(const std::string& title,
                               const GaudiUtils::VectorMap<int,double>& vmap) {
  EBASE::info() << title;
  for (GaudiUtils::VectorMap<int,double>::const_iterator i = vmap.begin(); 
       i != vmap.end(); ++i)
    EBASE::info() << hltInfoName(i->first) << " = " << i->second << "; \t";
  EBASE::info() << endreq;
}
