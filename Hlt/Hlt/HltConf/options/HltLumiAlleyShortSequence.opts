//---------------------------
// HLT Reconstruction
//--------------------------
// init is needed for ANNSvc
#include "$HLTSYSROOT/options/HltLumiInit.opts"

//---------------------------
// HLT Lumi Alley
//--------------------------

// (not) in HltSummary but in LumiSummary
HltSummaryWriter.Save += {
  // not clear:  "HltLumiDecision"
};

// decision is part of the OR of alleys
Hlt1Global.InputSelections += {"HltLumiDecision"};


// *************************************************
// Alley sequence
Hlt1LumiAlleySequence.Members = {
  // filter on Odin trigger types
  "OdinTypesFilter/OdinTypesFilter",
  // should put in here some reco sequence which always passes
  "GaudiSequencer/Hlt1LumiRecoSequence",
  // should put some new algo which writes summary bank
  "GaudiSequencer/HltLumiCountSequence",
  // just for debugging puposes
  "HltLumiOdinReader/HltLumiOdinReader",
  // sequences depending on Odin BX types
  "GaudiSequencer/Hlt1LumiBXTypesSequence",
  // prescale to allow for higher rate histogramming than storage
  "DeterministicPrescaler/PrescaleLumiDecision",
  "DummyLumiAlley/HltLumiDecision",
  // cleaning up the bank
  "bankKiller/SerialKiller",
  "RawEventDump/NanoEventDump"
  // writing the bank
  "HltLumiWriter/HltLumiWriter",
};


// *************************************************
// Reconstruction envelope
Hlt1LumiRecoSequence.Members = {
  "DummyLumiAlley/HltDummyReco"
};


// *************************************************
// Counting (always pass)
HltLumiCountSequence.Members = {
  "LumiFromL0DU/LumiCountSpd",
  "LumiFromL0DU/LumiCountPU",
  "LumiFromL0DU/LumiCountET",
  "DummyLumiAlley/HltDummyCount"
};

// *************************************************
// container sequence (just to make sure it doesn't block)
Hlt1LumiBXTypesSequence.Members = {
  // sequences depending on Odin BX types
  "GaudiSequencer/Hlt1LumiNoBeamSequence",
  "GaudiSequencer/Hlt1LumiBeamCrossingSequence",
  "GaudiSequencer/Hlt1LumiSingleBeamRightSequence",
  "GaudiSequencer/Hlt1LumiSingleBeamLeftSequence",
  "DummyLumiAlley/HltDummyBXType"
};

// *************************************************
// place for histograms with NoBeam condition
Hlt1LumiNoBeamSequence.Members = {
  "OdinTypesFilter/FilterNoBeam",
  "HltLumiOdinReader/OdinReaderNoBeam",
  "LumiHistoMaker/HistoNoBeam"
};

// place for histograms with BeamCrossing condition
Hlt1LumiBeamCrossingSequence.Members = {
  "OdinTypesFilter/FilterBeamCrossing",
  "HltLumiOdinReader/OdinReaderBeamCrossing",
  "LumiHistoMaker/HistoBeamCrossing"
};

// place for histograms with SingleBeamRight condition
Hlt1LumiSingleBeamRightSequence.Members = {
  "OdinTypesFilter/FilterSingleBeamRight",
  "HltLumiOdinReader/OdinReaderSingleBeamRight",
  "LumiHistoMaker/HistoSingleBeamRight"
};

// place for histograms with SingleBeamLeft condition
Hlt1LumiSingleBeamLeftSequence.Members = {
  "OdinTypesFilter/FilterSingleBeamLeft",
  "HltLumiOdinReader/OdinReaderSingleBeamLeft",
  "LumiHistoMaker/HistoSingleBeamLeft"
};


//-------------------------------------------------------------------------
// HLT LumiAlley options
//-------------------------------------------------------------------------
Hlt1LumiRecoSequence.ModeOr = true;         // should always pass
Hlt1LumiRecoSequence.ShortCircuit = false;  // execute the last always
Hlt1LumiRecoSequence.MeasureTime = true;
// Hlt1LumiRecoSequence.OutputLevel=3;

HltLumiCountSequence.ModeOr = true;         // should always pass
HltLumiCountSequence.ShortCircuit = false;  // execute the last always
HltLumiCountSequence.MeasureTime = true;
// HltLumiCountSequence.OutputLevel=3;

// LumiCountSpd.OutputLevel=2;
LumiCountSpd.InputSelection="Trig/L0/L0DUReport";
LumiCountSpd.CounterName="SPDMult";
LumiCountSpd.ValueName="Spd(Mult)";
LumiCountSpd.OutputContainer="Hlt/LumiSummary";

// LumiCountPU.OutputLevel=2;
LumiCountPU.InputSelection="Trig/L0/L0DUReport";
LumiCountPU.CounterName="PUMult";
LumiCountPU.ValueName="PUHits(Mult)";
LumiCountPU.OutputContainer="Hlt/LumiSummary";

// LumiCountET.OutputLevel=2;
LumiCountET.InputSelection="Trig/L0/L0DUReport";
LumiCountET.CounterName="CaloEt";
LumiCountET.ValueName="Sum(Et)";
LumiCountET.OutputContainer="Hlt/LumiSummary";

Hlt1LumiBXTypesSequence.ModeOr = true;         // should always pass
Hlt1LumiBXTypesSequence.ShortCircuit = false;  // execute the last always
Hlt1LumiBXTypesSequence.MeasureTime = true;
// Hlt1LumiBXTypesSequence.OutputLevel=3;

FilterNoBeam.BXTypes={"NoBeam"};
// OdinReaderNoBeam.OutputLevel=3;
Hlt1LumiNoBeamSequence.MeasureTime = true;
// Hlt1LumiNoBeamSequence.OutputLevel=3;
HistoNoBeam.InputVariables={"SPDMult","CaloEt"};

FilterBeamCrossing.BXTypes={"BeamCrossing"};
// OdinReaderBeamCrossing.OutputLevel=3;
Hlt1LumiBeamCrossingSequence.MeasureTime = true;
// Hlt1LumiBeamCrossingSequence.OutputLevel=3;
HistoBeamCrossing.InputVariables={"SPDMult","CaloEt"};

FilterSingleBeamRight.BXTypes={"SingleBeamRight"};
// OdinReaderSingleBeamRight.OutputLevel=3;
Hlt1LumiSingleBeamRightSequence.MeasureTime = true;
// Hlt1LumiSingleBeamRightSequence.OutputLevel=3;
HistoSingleBeamRight.InputVariables={"SPDMult","CaloEt"};

FilterSingleBeamLeft.BXTypes={"SingleBeamLeft"};
// OdinReaderSingleBeamLeft.OutputLevel=3;
Hlt1LumiSingleBeamLeftSequence.MeasureTime = true;
// Hlt1LumiSingleBeamLeftSequence.OutputLevel=3;
HistoSingleBeamLeft.InputVariables={"SPDMult","CaloEt"};

// OdinTypesFilter.OutputLevel=3;
OdinTypesFilter.TriggerTypes={"ALL"};
OdinTypesFilter.BXTypes={"NoBeam","BeamCrossing","SingleBeamRight","SingleBeamLeft"};

PrescaleLumiDecision.AcceptFraction=1.0;

Hlt1LumiAlleySequence.MeasureTime = true;
// Hlt1LumiAlleySequence.OutputLevel=3;

SerialKiller.DefaultIsKill=True;
SerialKiller.BankTypes={"ODIN","HltLumiSummary"};
//SerialKiller.OutputLevel=3;

// HltLumiWriter.OutputLevel=1;

//-------------------------------------------------------------------------
// HLT Hlt1LumiDecision is empty to always pass
//-------------------------------------------------------------------------
// HltLumiDecision.OutputLevel=3;

