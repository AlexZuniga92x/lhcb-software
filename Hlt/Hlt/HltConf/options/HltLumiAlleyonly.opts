//---------------------------
// HLT Reconstruction
//--------------------------
// init is needed for ANNSvc
#include "$HLTSYSROOT/options/HltLumiInit.opts"

//---------------------------
// HLT Lumi Alley
//--------------------------

// decision is part of the OR of alleys
HltAlleys.InputSelections += {"Hlt1LumiDecision"};


// *************************************************
// Alley sequence
Hlt1LumiAlleySequence.Members = {
  // filter on Odin trigger types
  "OdinTypesFilter/OdinTypesFilter",
  // should put in here some reco sequence which always passes
  "GaudiSequencer/Hlt1LumiRecoSequence",
  // should put some new algo which writes summary bank
  // "CollectLumiData/CollectLumiData",
  "GaudiSequencer/HltLumiCountSequence",
  // just for debugging puposes
  "HltLumiOdinReader/HltLumiOdinReader",
  // sequences depending on Odin BX types
  "GaudiSequencer/Hlt1LumiBXTypesSequence",
  // prescale to allow for higher rate histogramming than storage
  "DeterministicPrescaler/PrescaleLumiDecision",
  "DummyLumiAlley/Hlt1LumiDecision",
  // writing the bank
  "HltLumiFillRawBuffer/HltLumiFillRawBuffer",

  // reading back the bank (creates second instance of the class)
  "HltLumiSummaryDecoder/HltLumiSummaryDecoder",

  // raw dump
  "RawEventDump/RawEventDump",

  // testing the bankKiller
  "bankKiller/bankKiller",

  // raw dump
  "RawEventDump/NanoEventDump",
};


// *************************************************
// Reconstruction envelope
Hlt1LumiRecoSequence.Members = {
  "GaudiSequencer/Hlt1LumiPreRecoSequence",
  "DummyLumiAlley/HltDummyReco"
};

// *************************************************
// Reconstruction (always pass)
Hlt1LumiPreRecoSequence.Members = {
  "GaudiSequencer/HltRecoSequence",
};


// *************************************************
// Counting (always pass)
HltLumiCountSequence.Members = {
  "LumiFromL0DU/LumiCountSpd",
  "LumiFromL0DU/LumiCountPU",
  "LumiFromL0DU/LumiCountET",
  "DummyLumiAlley/HltDummyCount"
};


// *************************************************
// container sequence (just to make sure it doesn't block)
Hlt1LumiBXTypesSequence.Members = {
  // sequences depending on Odin BX types
  "GaudiSequencer/Hlt1LumiBeamCrossingSequence",
  "GaudiSequencer/Hlt1LumiNoBeamSequence",
  "DummyLumiAlley/HltDummyBXType"
};

// *************************************************
// place for histograms with NoBeam condition
Hlt1LumiNoBeamSequence.Members = {
  "LumiHistoMaker/Test1NoBeam", 
  "OdinTypesFilter/FilterNoBeam",
  "HltLumiOdinReader/OdinReaderNoBeam",
  "LumiHistoMaker/Test2NoBeam"  // place for histograms with NoBeam condition  
};

// place for histograms with BeamCrossing condition
Hlt1LumiBeamCrossingSequence.Members = {
  "LumiHistoMaker/Test1BeamCrossing", 
  "OdinTypesFilter/FilterBeamCrossing",
  "HltLumiOdinReader/OdinReaderBeamCrossing",
  "LumiHistoMaker/Test2BeamCrossing"  // place for histograms with BeamCrossing condition  
};


//-------------------------------------------------------------------------
// HLT LumiAlley options
//-------------------------------------------------------------------------
Hlt1LumiRecoSequence.ModeOr = true;         // should always pass
Hlt1LumiRecoSequence.ShortCircuit = false;  // execute the last always
Hlt1LumiRecoSequence.MeasureTime = true;
Hlt1LumiRecoSequence.OutputLevel=3;

Hlt1LumiPreRecoSequence.MeasureTime = true;
Hlt1LumiPreRecoSequence.OutputLevel=3;

HltLumiCountSequence.ModeOr = true;         // should always pass
HltLumiCountSequence.ShortCircuit = false;  // execute the last always
HltLumiCountSequence.MeasureTime = true;
HltLumiCountSequence.OutputLevel=3;

LumiCountSpd.OutputLevel=2;
LumiCountSpd.InputSelection="Trig/L0/L0DUReport";
LumiCountSpd.CounterName="SPD";
LumiCountSpd.ValueName="Spd(Mult)";
LumiCountSpd.OutputContainer="Hlt/LumiSummary";

LumiCountPU.OutputLevel=3;
LumiCountPU.InputSelection="Trig/L0/L0DUReport";
LumiCountPU.CounterName="PUMult";
LumiCountPU.ValueName="PUHits(Mult)";
LumiCountPU.OutputContainer="Hlt/LumiSummary";

LumiCountET.OutputLevel=2;
LumiCountET.InputSelection="Trig/L0/L0DUReport";
LumiCountET.CounterName="Calo";
LumiCountET.ValueName="Sum(Et)";
LumiCountET.OutputContainer="Hlt/LumiSummary";


Hlt1LumiBXTypesSequence.ModeOr = true;         // should always pass
Hlt1LumiBXTypesSequence.ShortCircuit = false;  // execute the last always
Hlt1LumiBXTypesSequence.MeasureTime = true;
Hlt1LumiBXTypesSequence.OutputLevel=3;

FilterNoBeam.BXTypes={"NoBeam"};
OdinReaderNoBeam.OutputLevel=4;
Hlt1LumiNoBeamSequence.MeasureTime = true;
Hlt1LumiNoBeamSequence.OutputLevel=4;

FilterBeamCrossing.BXTypes={"BeamCrossing"};
OdinReaderBeamCrossing.OutputLevel=4;
Hlt1LumiBeamCrossingSequence.MeasureTime = true;
Hlt1LumiBeamCrossingSequence.OutputLevel=4;

//CollectLumiData.OutputLevel=4;
HltLumiOdinReader.OutputLevel=4;

OdinTypesFilter.OutputLevel=3;
OdinTypesFilter.TriggerTypes={"ALL"};
//OdinTypesFilter.TriggerTypes={"Reserve","PhysicsTrigger","RandomTrigger","TimingTrigger","CalibrationTrigger"};
//OdinTypesFilter.TriggerTypes={"Reserve","PhysicsTrigger","RandomTrigger"};  // should become "Random"
OdinTypesFilter.BXTypes={"NoBeam","BeamCrossing","SingleBeamRight","SingleBeamLeft"};

PrescaleLumiDecision.AcceptFraction=1.00;

Hlt1LumiAlleySequence.MeasureTime = true;
Hlt1LumiAlleySequence.OutputLevel=3;

HltLumiFillRawBuffer.OutputLevel=3;

HltLumiSummaryDecoder.OutputLevel=3;

bankKiller.OutputLevel=2;
bankKiller.BankTypes={"ODIN","HltLumiSummary"};
bankKiller.DefaultIsKill=true;

RawEventDump.DumpData=false;
RawEventDump.OutputLevel=2;

NanoEventDump.DumpData=false;
NanoEventDump.OutputLevel=2;

//-------------------------------------------------------------------------
// HLT Hlt1LumiDecision is empty to always pass
//-------------------------------------------------------------------------
Hlt1LumiDecision.OutputLevel=3;

