// Class: ReadFisherArea1
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : Fisher::Fisher
TMVA Release   : 3.8.14        [198670]
ROOT Release   : 5.13/06       [331014]
Creator        : witekma
Date           : Sat Jul 12 20:20:30 2008
Host           : Linux lxplus071.cern.ch 2.6.9-42.0.3.EL.cernsmp #1 SMP Fri Oct 6 12:07:54 CEST 2006 i686 i686 i386 GNU/Linux
Dir            : /home/witekma/root/ecal_TMVA/TMVA/macros
Training events: 400


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
Normalise: "False" [Normalise input variables]
NbinsMVAPdf: "50" [Number of bins used to create MVA PDF]
NsmoothMVAPdf: "1" [Number of smoothing iterations for MVA PDF]
V: "False" [Verbose mode]
H: "True" [Print classifier-specific help message]
CreateMVAPdfs: "True" [Create PDFs for classifier outputs]
Method: "Fisher" [Discrimination method]
# Default:
D: "False" [use-decorrelated-variables flag (depreciated)]
VarTransform: "None" [Variable transformation method]
VarTransformType: "Signal" [Use signal or background events for var transform]
VerboseLevel: "Info" [Verbosity level]
TxtWeightFilesOnly: "True" [if True, write all weights as text files]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 5
showershape                   showershape                       'F'    [0.0510961264372,0.99998998642]
showerasym                    showerasym                        'F'    [0.000800371461082,0.768562614918]
showerkappa                   showerkappa                       'F'    [0.00894956476986,0.78848451376]
showertail                    showertail                        'F'    [0.356659322977,0.945029735565]
showerenergy                  showerenergy                      'F'    [0.0374240875244,0.99998998642]


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;
};

#endif

class ReadFisherArea1 : public IClassifierReader {

 public:

   // constructor
   ReadFisherArea1( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadFisherArea1" ),
        fStatusIsClean( true ),
        fNvars( 5 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "showershape", "showerasym", "showerkappa", "showertail", "showerenergy" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0.0510961264371872;
      fVmax[0] = 0.999989986419678;
      fVmin[1] = 0.00080037146108225;
      fVmax[1] = 0.768562614917755;
      fVmin[2] = 0.00894956476986408;
      fVmax[2] = 0.788484513759613;
      fVmin[3] = 0.356659322977066;
      fVmax[3] = 0.945029735565186;
      fVmin[4] = 0.0374240875244141;
      fVmax[4] = 0.999989986419678;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadFisherArea1() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;
   bool fStatusIsClean;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[5];
   double fVmax[5];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[5];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   double              fFisher0;
   std::vector<double> fFisherCoefficients;
};

inline void ReadFisherArea1::Initialize() 
{
   fFisher0 = -0.641275231866;
   fFisherCoefficients.push_back( -0.996593774935 );
   fFisherCoefficients.push_back( -0.736417256421 );
   fFisherCoefficients.push_back( -0.297582933313 );
   fFisherCoefficients.push_back( 1.11114027698 );
   fFisherCoefficients.push_back( 1.19175504436 );

   // sanity check
   if (fFisherCoefficients.size() != fNvars) {
      std::cout << "Problem in class \"" << fClassName << "\"::Initialize: mismatch in number of input values"
                << fFisherCoefficients.size() << " != " << fNvars << std::endl;
      fStatusIsClean = false;
   }         
}

inline double ReadFisherArea1::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double retval = fFisher0;
   for (size_t ivar = 0; ivar < fNvars; ivar++) {
      retval += fFisherCoefficients[ivar]*inputValues[ivar];
   }

   return retval;
}

// Clean up
inline void ReadFisherArea1::Clear() 
{
   // clear coefficients
   fFisherCoefficients.clear(); 
}
inline double ReadFisherArea1::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!fStatusIsClean) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
      retval = 0;
   }
   else {
      if (IsNormalised()) {
         // normalise variables
         std::vector<double> iV;
         int ivar = 0;
         for (std::vector<double>::const_iterator varIt = inputValues.begin();
              varIt != inputValues.end(); varIt++, ivar++) {
            iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
         }
         retval = GetMvaValue__( iV );
      }
      else {
         retval = GetMvaValue__( inputValues );
      }
   }

   return retval;
}
