  This is a brief description of the MuonKernel package. 
  
  The main ingredients are MuonSystemID and MuonLayout classes. They
work closely together.  

  Here comes some more explanation of the intended purpose and possible use
of the MuonSystemID class. 
  The basic idea of the MuonSystemID is to take advantage of the very regular
layout of the Muon System. This regularity is present for nearly all the
entities of the MuonSystem: chambers, physical channels, logical units, 
strips, pads, all the entities in the muon trigger domain. I used to call
a general entity like those mentioned as a tile. The common features for all 
those tiles are:

  o Within one region in each station all the tiles have the same size and type;
  o A region is covered by a whole number of tiles; 
  o all the quarters are symmetrical with left-right and top-bottom symmetry.

  So, it is possible to use objects of the same type to identify ALL these
entities. Clearly a single ID definition for all the entities in the Muon 
System is a nice advantage. The MuonSystemID is a realisation of this idea.

  First of all we have to define the layout of particular tiles of the Muon
System that we want to identify. This is done by a MuonLayout class. To define
a layout it is sufficient to have just two numbers: whole number of tiles
that can be placed in one arm of the L-shaped region in X (layoutX) and the 
same number in Y (layoutY). For example, the logical pad layout in the Muon 
station M1 is defined by layoutX = 24 and layoutY = 8. For strips or chambers
these numbers will be different. Still strip or chamber layout can be defined
by just two numbers. The finest granularity in the Muon System is that for the
pads in M2/M3. So, we have the finest possible layout defined as: 

                  layoutX = 48 
                  layoutY = 8

  Having defined the layout, we now can identify a muon tile with respect to
this layout. In one station  it is sufficient to provide quarter, region, index in X
and index in Y. Indices in X and Y are defined with respect to the beam axis. So,
for example, a pair 0,0 is not valid. Now, if combine these numbers together with
the layout with respect to which they are defined, we construct a universal
identifier. This is a MuonSystemID. To make a summary, the MuonSystemID structure
is the following (remember we should count from 0) :

            LayoutX  0-48    :  6 bits
            LayoutX  0-8     :  4 bits
            Station  0-4     :  3 bits
            Layer    0-3     :  2 bits     <== this is the same as Gap in your case
            Readout  0-1     :  1 bit      <== vertical-horizontal strips flag
            Region   0-3     :  2 bits
            Quarter  0-3     :  2 bits
            X        0-95    :  7 bits
            Y        0-15    :  4 bits
            --------------------------
                               31 bits

So, the MuonSystemID is an "intelligent" object with its structure encoded in itself.
Having an identifier so defined allows to locale the object with no additional
information. Two different type objects can talk to each other without intermediary
objects. All the Muon System entities (tiles) can be identified with these MuonSystemID's.
If it will be the case, the following operations will be trivial - some examples
of existing methods:

// Constructing a strip identifier from the local indices with respect to its chamber

MuonSystemID stripID1(chamberID, localX1, localY1);
MuonSystemID stripID2(chamberID, localX2, localY2);

// Construct a logical pad identifier from the interception of two strips

MuonSystemID padID = stripID1.intercept(stripID2);

// Get the identifier of a chamber containing a given logical pad

MuonLayout chamberLayout;

      // ... chamber layout initialised from a database ...

MuonSystemID chamberID = padID.getContainerID(chamberLayout);

// Get a vector of pads touched by an area defined around a central pad 
// with limits in X and Y

std::vector<MuonSystemID> = padLayout.tiles(padID, deltaX, deltaY);

  The other classes are:
  
  IMuonTile - interface class that Muon System entities are supposed to
              adhere to;
  
  MuonTile - supposed to be a base class for Muon System entities. The
             MuonTile objects know their MuonSystemID identity and can be
	     used as keyed objects. 
	     
  MuonVector - a crude templated container based on std::vector that can
               store MuonTiles and derived class objects and can be indexed
	       by MuonSystemID's	     
	     
