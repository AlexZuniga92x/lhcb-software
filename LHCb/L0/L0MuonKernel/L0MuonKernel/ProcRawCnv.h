#ifndef L0MUONKERNEL_PROCRAWCNV_H
#define L0MUONKERNEL_PROCRAWCNV_H 

/** @class ProcRawCnv ProcRawCnv.h  L0MuonKernel/ProcRawCnv.h
 
  Class for constructing the raw data generated by the TELL1 linked to the processing boards in transparent mode. 

  @author
  @date

*/
#include "Kernel/MuonTileID.h"
#include "L0MuonKernel/CandRegisterHandler.h"
#include "L0MuonKernel/MuonCandidate.h"
#include "ProcessorKernel/TileRegister.h"
#include <boost/dynamic_bitset.hpp>
#include <string>
#include <map>
#include <vector>

namespace L0Muon {
  
  class ProcRawCnv  {

  private:

    static const unsigned int board_full_frame_size = 36;
    static const unsigned int board_full_data_size  = board_full_frame_size*2;
    static const unsigned int board_frame_size      = 34;
    static const unsigned int board_data_size       = board_frame_size*2;

  public:

    /// Default Constructor
    ProcRawCnv();

    /// Default Constructor
    ProcRawCnv(int side);

    /// Destructor
    ~ProcRawCnv();

    LHCb::MuonTileID mid_BCSU(int ib);
    LHCb::MuonTileID mid_PU(int ib, int ipu);
    
    void release();

    std::vector<PMuonCandidate> muonCandidatesPU();
    std::vector<PMuonCandidate> muonCandidatesBCSU();
    std::vector<LHCb::MuonTileID> ols(LHCb::MuonTileID puid);    
    std::vector<LHCb::MuonTileID> neighs(LHCb::MuonTileID puid);
    std::vector<LHCb::MuonTileID> pus();

    int status_BCSCU(int ib){return m_candRegHandlerBCSU[ib].getStatus();}
    int status_PU(int ib,int ipu){return m_candRegHandlerPU[ib][ipu].getStatus();}

    void decodeBank(std::vector<unsigned int> raw, int version);
    std::vector<unsigned int> rawBank(int version);

    void dump(int version, std::string tab);
    void dump(int version);
    void formattedDump(int version, std::string tab);
    void formattedDump(int version);
    
    int L0_B_Id(int iboard, int ichannel) {return m_L0_B_Id[iboard][ichannel];}
    int L0EventNumber(int iboard, int ichannel) {return m_L0EventNumber[iboard][ichannel];}
    int BCID_BCSU(int iboard) {return m_BCID_BCSU[iboard];}
    int BCID_PU(int iboard, int ipu) {return m_BCID_PU[iboard][ipu];}
    
    int opt_link_error(int iboard, int ipu) {return m_opt_link_error[iboard][ipu];}
    int ser_link_error(int iboard, int ipu) {return m_ser_link_error[iboard][ipu];}
    int par_link_error(int iboard, int ipu) {return m_par_link_error[iboard][ipu];}
  
    int boardIndexError(int iboard, int ichannel) {return m_boardIndex[iboard][ichannel]!=iboard;}
    
    bool inError(bool verbose=false);
  
    bool isActiv(){return m_activ;}

    int decodingError(int ib){ return m_decodingError[ib];}

    void setEventCounters(int L0EventNum, int L0_B_Id);

//     int checkMuonTiles();
    
  private:
    
    bool m_activ;
    
    int m_quarter;

    std::vector<unsigned int> reorderOLChannels(std::vector<unsigned int> raw);
    
    // Candidate registers
    CandRegisterHandler m_candRegHandlerBCSU[12];
    CandRegisterHandler m_candRegHandlerPU[12][4];

    // Pointers to tile registers organised into arrays according to board and pu indices
    TileRegister* m_ols[12][4];
    TileRegister* m_neighs[12][4];    

    // Pointers to tile registers, organised into a map with the puID as a key
    std::map<LHCb::MuonTileID, TileRegister*> m_olsMap;
    std::map<LHCb::MuonTileID, TileRegister*> m_neighsMap;

    int m_L0_B_Id[12][2];
    int m_L0EventNumber[12][2];
    int m_BCID_PU[12][4];
    int m_BCID_BCSU[12];

    int m_boardIndex[12][2];
    
    int m_add_link_error[12][4];
    int m_opt_link_error[12][4];
    int m_ser_link_error[12][4];
    int m_par_link_error[12][4];

    int m_decodingError[12];
    
  };
}; // namespace L0Muon
 
#endif    // L0MUONKERNEL_PROCRAWCNV_H
