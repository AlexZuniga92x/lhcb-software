\documentstyle[a4,epsfig]{article}      
		
\title{ Volumes } 
\author{Vanya Belyaev\footnote{E-mail:{\tt Ivan.Belyaev@itep.ru} } \\ {\it ITEP, Moscow}}
\date{ \today }	
\begin{document}
 
\maketitle 	

\tableofcontents 

\section{ General features of geometry tree }

The construction of geometry tree withon 
${\mathcal{GAUDI}}$ framework is based on the following postulates:
\begin{itemize}
\item 
The geometry tree is constructed 
from {\it Logical Volumes} and {\it Physical Volumes}. 
\item 
There is no "up-links" in the geometry tree. It means that 
each node have no information about the "up" (or "parent", "mother") node.
\item 
Each {\it Logical Volume}  has an information about its 
"down" ("children") nodes, represented by {\it Physical Volumes}  
\item 
Each {\it Logical Volume}  has information about its shape and dimensions ("solid").
\item 
Each {\it Logical Volume} has an access to the information about the material content.
\item 
Neither  {\it Logical Volumes} nor 
{\it Physical Volumes} have no any information about its absolute position in the space. 
\item 
{\it Logical Volumes} have no any information about its own position relative to other 
{\it Logical Volumes}.
\item 
Each {\it Physical Volume } has an information about the its position inside the 
mother ("parent") {\it Logical Volume}. 
It is the only available geometry information in the whole tree.
\item 
All boolean operations on the level of {\it Logical Volumes}  and
{\it Physical Volumes} are strickly forbidden\footnote{ It is equivalent to 
the absence of \verb+'MANY'+ flag in {\it GEANT3} toolkit}. If one need 
to perform boolean operations, one should rely on boolean operations on the 
level of {\it Solids}. It is one of the most essential postulates of 
adopted geometry structure.   
\end{itemize} 	 

The geometry tree which fulfills all these postulates  represent a very 
effective, simple and convinient tool for description of the geometry. 
Such tree is  easily formalized. This tree have many features which are similar 
to the  features of the geometry tree used within {\it Geant4} toolkit and 
it could be easily transformed to the {\it Geant4 } geometry description. 

There exist several general sequences derived from these base postulates:

\begin{itemize} 
\item 
According to this schema the top-level {\it Logical Volume} 
(presumably the experimetal hall, or cave, or the whole $LHCb$ detector) 
defines the absolute coordinate reference system. Frankly speaking
the null-point (0,0,0) in the so called "Global Reference System" is 
just the center of the top "Logical Volume".
\item 
All geometry calculations, computations, inputs and outputs, performed 
with the usage of the {\it Logical Volume} are in the local reference system of 
this {\it Logical Volume}.
\item
All geometry calculations, computations, inputs and outputs, performed 
with the usage of the {\it Physical Volume} are in the local reference system of 
its parent {\it Logical Volume}.
\end{itemize} 

Sometimes one needs to get more effective way of extraction information from 
the geometry tree or to perform unique location of the point in the  geometry 
tree. For these purposes  a simplified detector description tree is introduced 
into the ${\mathcal{GAUDI}}$ framework\footnote{Within {\it Geant4} toolkit 
there exists 2 approaches for solving the same problem: {\it Read-Out-Geometry Tree}
and {\it Navigator}. Our approach is quite close to the combined usage of both.}. 
   
  
\section{ Logical Volumes }


\subsection{ {\it ILVolume}  interface} 

This abstract interface is designed to fulfill  the postulates of the geometry tree. 

Here the main features and methods of logical volume interface {\it ILVolume} are  described:
\begin{itemize}
  \item 
  \verb+const   ISolid*       solid       () const ;+
  \\ return the solid, associated with the Logical Volume  
  \item  
  \verb+const   std::string&  materialName() const ;+
  \\ return the material(by name) , associated with the Logical Volume  
  \item  
  \verb+const   Material*     material    () ;+
  \\ return the C++ pointer to the material, associated with the Logical Volume  
 \item
  \verb+ILVolume::ReplicaType noPVolumes  () const ;+
  \\ return number of Physical(positioned) Volumes inside given Logical Volume
\item Access to the contained physical volumes 
\begin{itemize} 
\item 
{\tt IPVolume* operator[]( const ILVolume::ReplicaType\& index );}
 \\ return C++ pointer to the daughter {\it Physical Volume} by index ( replica number )
\item 
\verb+IPVolume* operator[]( const std::string& name ) const;+
 \\ return C++ pointer to the daughter {\it Physical Volume}  by it's name
\end{itemize} 	
\item More conventional access to the daughter {\it Physical Volumes}:
\begin{itemize} 	
\item 
{\tt IPVolume* pvolume( const ILVolume::ReplicaType\& index ) ;}
  \\ return C++ pointer to the daughter {\it Physical Volume} by index ( replica number )
\item
{\tt IPVolume* pvolume( const std::string\& name ) const;}
  \\ return C++ pointer to the daughter {\it Physical Volume} by it's name 
\end{itemize} 
  \item Access via iterators (very useful and practical in conjunction with STL algorithms):
 \begin{itemize} 
 \item 
\verb+ILVolume::PVolumes::iterator       pvBegin()       ;+
\item 
\verb+ILVolume::PVolumes::const_iterator pvBegin() const ;+
\item
\verb+ILVolume::PVolumes::iterator       pvEnd  ()       ;+ 
\item
\verb+ILVolume::PVolumes::const_iterator pvEnd  () const ;+ 
\end{itemize}   
\item Traverse the down-links and transfrom the sequence of replica numbers to the sequence 
of C++ pointers to {\it Physical Volumes}. These methods are indeed primary methods for unique 
locations of points withis geometry tree. 
\begin{itemize}  
\item 
\begin{verbatim}
StatusCode traverse( ReplicaPath::const_iterator pathBegin,
	             ReplicaPath::const_iterator pathEnd  ,
		     PVolumePath&                volumePath );
\end{verbatim}
  \item
\begin{verbatim} 
StatusCode traverse( const ReplicaPath&  replicaPath,
		     PVolumePath&        volumePath ) ;
\end{verbatim}
\end{itemize}
\item 
\verb+bool isInside ( const HepPoint3D& LocalPoint ) const;+
\\ return {\it true } if the {\it LocalPoint} in the local reference system of 
the {\it Logical volume} is inside the {\it Logical Volume}. 
 	
\item Try to localize the {\it LocalPoint} in the local reference system inside the 
daughter volumes. Methods returns either the sequence of C++ pointers to the 
daughter {\it Physical Volumes} or the sequence of the {\it  replica numbers }.
Both methods are recursive and therefore could be {\it very } slow for complicated 
multi-level geometry. Sometimes the such very detailed  information is not nesessary
and therefore to speedup the method one should choose the appropriate 
level of deepth of the tree to be traversed.
\begin{itemize} 
\item  
\begin{verbatim} 
StatusCode belongsTo( const HepPoint3D& localPoint ,
		      const int         level      , 
		      PVolumePath&      volumePath );
\end{verbatim}
\item 
\begin{verbatim}
StatusCode belongsTo( const HepPoint3D& localPoint ,
		      const int         level      , 
		      ReplicaPath&      replicaPath );        
\end{verbatim} 
\end{itemize} 
\item Overloaded print function to {\it std::ostream } 
\item 
\verb+const ILVolume* reset() const ;+
\\ This methos performs the full reset to the initial state 
of the {\it Logical Volume}. All temporary values are cleared. 
It also triggers the {\it reset()} method for all daughter 
{\it Physical Volumes} and for its own {\it Solid}.
\item 
Intersection of the {\it Logical Volume} with the line. 
Line is to be parametrized in the local reference system of the 
{\it Logical Volume} by initial point on the line and direction vector:
$\vec{\bf x}(t) = \vec{\bf p} + \vec{\bf v}\times t$, where $t$ is 
a parameter. Both methods fill the output container with 
intervals of parameter values associated with the material.
Both methods return the size of this outpout container. 
Both methods are recursive and therefore could be {\it very} slow
for multilevel complicated geometry. To speed-up the methods one could 
use the appropriate value of threshold parameter {\it Threshold}.
If the estimated contribution of the some volume from the chain 
to the total radiation thickness (in the units of radiation length) 
is less then value of parameter {\it Threshold} this volume do not 
contribute to the output container. For the second method 
only values of line parametrization parameter $t$ from the region  
${\it tickMin}\leq t \leq {\it tickMax}$ are considered. 
\begin{itemize} 
\item
\begin{verbatim}
             /* initial point at the line    */
unsigned int intersectLine( const HepPoint3D& Point ,      
             /* direction vector of the line */
		            const Hep3Vector& Vector        ,      
             /* output container             */ 
		            Intersections   & intersections ,      
             /* threshold value              */
		            const double      threshold     ) ; 
  
\end{verbatim}
\item
\begin{verbatim}
             /* initial point at the line    */
unsigned int intersectLine( const HepPoint3D& Point , 
             /* direction vector of the line */
		            const Hep3Vector& Vector        ,      
             /* output container             */ 
		            Intersections   & intersections ,     
             /* minimum value of Tick        */ 
		            ISolid::Tick      tickMin       ,     
             /* maximal value of Tick        *.
		            ISolid::Tick      tickMax       , 
             /* threshold value              */
		            const double      Threshold     ) ; 
\end{verbatim}
\end{itemize} 
These methods are essential for 
estimation of the distance in the units of the radiation 
length between 2 points. 
 

\end{itemize} 


\subsection { {\it class LVolume} }
The notion of the {\it Logical Volume } is implemented within 
${\mathcal{GAUDI}}$ framework via the {\it class LVolume}. 
The essential features of this object are:
\begin{itemize}
\item {\it LVolume} represents an {\it identifiable object}. 
 It inherits from {\it class DataObject}, and therefore it is 
 identified within ${\mathcal{ GAUDI}}$ Transiend Store by unique name 
("path"). 
\item It implements an abstract interface {\it ILVolume}.  
\item It also implements an abstract interface {\it IValidity} (not mentioned above).   
\item Some methods of {\it LVolume} class could throw 
the exception via {\it LVolumeException}, {\it SolidException} 
and/or            {\it PVolumeException} classes.
\item {\it class LVolume} has three constructors:
 \begin{itemize} 
  \item The default constructor as a quite fragil is declared to be {\it private}. 
  It could be invoked only from methods of appropriate {\it friend } class. 
  Currently {\it class LVolume } has only one {\it friend} - { \it class XmlLVolumeCnv}.
  \item Public constructors are safe. They require the C++ pointer to {\it ISolid} to ve valid, 
        overwise they throw {\it LVolumeException}. {\it class LVolume} takes the fullresposibility 
       for its own {\it Solid}. The deletion of {\it Solid} is in the destructor of
{\it class LVolume}. 
\begin{verbatim}
  LVolume( const std::string& name            , 
	   ISolid*            Solid           ,
           const std::string& material        ,
           const ITime&       validSince      , 
           const ITime&       validTill       , 
           IDataProviderSvc*  dataService = 0 , 
           IMessageSvc*       messService = 0 );
///
  LVolume( const std::string& name            , 
	   ISolid*            Solid           ,
           const std::string& material        ,
           IDataProviderSvc*  dataService = 0 , 
           IMessageSvc*       messService = 0 );
\end{verbatim}
 \end{itemize}  
\item 	
{\it class LVolume} take a full responsibility for creation and deletion of the {\it Physical Volume}. 
\begin{verbatim}
  IPVolume* createPVolume( const std::string&    PVname , 
	const std::string&    LVnameForPV    );
  IPVolume* createPVolume( const std::string&    PVname , 
	const std::string&    LVnameForPV    ,
      /* position of PVolume inside LVolume */ 
        const HepPoint3D&     position );      
  IPVolume* createPVolume( const std::string&    PVname , 
	const std::string&    LVnameForPV    ,
     /* position of PVolume inside LVolume  */
        const HepPoint3D&     position, 
     /* rotation to be applied              */
        const HepRotation&    rotation );    
\end{verbatim}


\end{itemize} 
 
\section{ Physical Volumes } 
The notion of the {\it Physical Volume} within the adopted geometry schema is 
extremply primitive - it is just {\it Logical Volume} which is {\it positioned 
inside its mother Logical Volume}.  Frankly speaking it is just a pair of 
name of the {\it Logical Volume} to be positioned inside the mother {\it Logical Volume } 
and the corresponding transformation matrix from the local reference system of mother 
{\it Logical Volume} to the local reference system {\it Logical Volume} to be positioned. 
 
\subsection{ {\it IPVolume}  interface} 
This abstract interface is designed to fulfill  the postulates of the geometry tree. 
The essential methods provided via this interface are:
\begin{itemize} 
\item 
\verb+const std::string&     name() const ;+
\\ return the name of the {\it Physical Volume}. This name should be unique inside the given 
mother {\it Logical Volume}. The same name can be used inside different mother {\it Logical Volumes}. 
This name is used in navigation of {\it DetectorElement} ("name-path").   
\item 
\verb+const std::string&     lvolumeName() const ;+
\\ return  the name of associated {\it Logical Volume}. 
\item 
\verb+ILVolume*        lvolume    () const;+
\\ return C++ pointer to the associated {\it Logical Volume}. 
\item 
\verb+const HepTransform3D&  matrix() const ;+
\\ return the transformation matrix from local reference system of 
mother {\it Logical Volume} to the local reference system of the 
{\it Logical Volume}, associated with given {\it Physical Volume}.
\item 
\verb+const HepTransform3D&  matrixInv() const ;+
\\ return the transformation matrix from local reference system of 
the {\it Logical Volume} associated with given {\it Physical Volume} 
to the local reference system of the mother {\it Logical Volume}.
\item   
{\tt HepPoint3D toLocal ( const HepPoint3D\& PointInMother ) const ;}
 \\ transform point from reference system of the mother {\it Logical Volume}
to the reference system of the {\it Logical Volume}, associated with given 
{\it Physical Volume}  
\item   
{\tt HepPoint3D toMother ( const HepPoint3D\& PointInLocal ) const ;}
 \\ transform point from local reference system of the {\it Logical Volume}
associated with given {\it Physical Volume}  to the reference system of the mother {\it Logical Volume}, 
\item   
{\tt bool isInside( const HepPoint3D\& PointInMother ) const ;}
\\ return {\it true} if the point in the reference system of mother {\it Logical Volume} 
is inside the {\it Logical Volume}, associated with given {\it Physical Volume}.  
\item Overloaded print-functions and stream operators to {\it std::ostream}.
\item 
\verb+const IPVolume* reset() const ;+
\\ this methos performs the reset of the {\it Physical Volume} to the initial state.
All temporaries are cleared. It triggers the {\it reset()} method for the 
associated {\it Logical Volume}.
\item Intersection with the line in the space. There exist two methods, which are identical 
to the methods in the {\it ILVolume} interface, and they just provide 
the delegation to the associated {\it Logical Volume}.  

\end{itemize} 


\subsection{ {\it class PVolume} } 
The notion of the {\it Physical Volume } is implemented within 
${\mathcal{GAUDI}}$ framework via the {\it class PVolume}. 
The essential features of this object are:
\begin{itemize}
\item {\it PVolume} is not {\it identifiable object}. 
\item It implements an abstract interface {\it IPVolume}.  
\item Some methods of {\it PVolume} class could throw 
the exception via {\it PVolumeException},
{\it LVolumeException} and/or {\it SolidException} classes.
\item {\it class PVolume} has no public constructors. Creation and destroy of 
objects are under the constrol of the {\it friend class LVolume}.  
\begin{verbatim}
  PVolume( const std::string& PhysVol_name ,
     const std::string& LogVol_name ,
/* position in Mother Reference Frame!*/
     const HepPoint3D&  Position ,
/* rotation with respect to Mother Reference Frame*/
     const HepRotation& Rotation       = HepRotation() , 
     IDataProviderSvc*  dataService    = 0 , 
     IMessageSvc*       messageService = 0 );
\end{verbatim}
   
\end{itemize} 
  

\end{document}