#include "GaudiKernel/IService.h"
#include "GaudiKernel/ICnvManager.h"
#include "GaudiKernel/ICnvFactory.h"

#include "GaudiKernel/CnvFactory.h"
#include "GaudiKernel/System.h"

#include "GaudiKernel/MsgStream.h"

#include "DetDesc/XmlCnvAttrList.h"
#include "DetDesc/IXmlCnv.h"
#include "DetDesc/IXmlSvc.h"

template <class DeType>
const unsigned char& XmlUserDeCnv<DeType>::storageType()
{
  return XML_StorageType;
}

template <class DeType>
const CLID& XmlUserDeCnv<DeType>::classID()
{
  return DeType::classID();
}

/// Constructor
template <class DeType>
XmlUserDeCnv<DeType>::XmlUserDeCnv(
                                    ISvcLocator* svc
                                   ,std::string& typeName
                                  )
: Converter( XML_StorageType, classID(), svc ),
  m_deCnv( 0 ), m_dataObj( 0 ), m_xmlSvc( 0 )
{
  m_msId = typeName;
}

template <class DeType>
XmlUserDeCnv<DeType>::XmlUserDeCnv(
                                    ISvcLocator* svc
                                   ,char* typeName
                                  )
: Converter( XML_StorageType, classID(), svc ),
  m_deCnv( 0 ), m_dataObj( 0 ), m_xmlSvc( 0 )
{
  m_msId = typeName;
}

template <class DeType>
XmlUserDeCnv<DeType>::XmlUserDeCnv(
                                    ISvcLocator* svc
                                   ,const char* typeName
                                  )
: Converter( XML_StorageType, classID(), svc ),
  m_deCnv( 0 ), m_dataObj( 0 ), m_xmlSvc( 0 )
{
  m_msId = typeName;
}

/// Desctructor
template <class DeType>
XmlUserDeCnv<DeType>::~XmlUserDeCnv()
{
}

/// Initialize the converter
template <class DeType>
StatusCode XmlUserDeCnv<DeType>::initialize()
{
  // Initialize the grand father
  StatusCode status = Converter::initialize();
  
  ICnvManager*   cnvMgr;
  IXmlCnv*       xmlCnv;
  
  MsgStream log( msgSvc(), m_msId );
  log << MSG::DEBUG << "Initializing " << m_msId << " detector element converter" << endreq;

  if( status.isSuccess() ) {
    
    status = serviceLocator()->queryInterface(IID_ICnvManager,(void **)&cnvMgr );
    
    if( status.isSuccess() ) {
      
      const ICnvFactory* cf = cnvMgr->factory( XML_StorageType, CLID_DetectorElement );
      
      m_deCnv = cf->instantiate( serviceLocator() );
      
      try {
        xmlCnv = dynamic_cast<IXmlCnv*>(m_deCnv);
      } catch( ... ) {
        log << MSG::FATAL << "Can't get generic detector element converter" << endreq;
        return StatusCode::FAILURE;
      }
      
      // Must be initialized
      status = m_deCnv->initialize();
      
      if( status.isSuccess() ) {
        // Register myself as the recevier of User ASCII XML SAX events
        xmlCnv->setUserSaxDocHandler( *this );
      }
      
      cnvMgr->release();
      
    } else {
      
      return status;
      
    }

    IService* svc = 0;
    status = serviceLocator()->getService( "XmlCnvSvc", (IService*&)svc );
    status = svc->queryInterface(IID_IXmlSvc,(void **)&m_xmlSvc );

    if( status.isFailure() ) {
      log << MSG::ERROR << "Can't get IXmlSvc interface" << endreq;
    }
  }

  return status;
}

/// Finalize the converter
template <class DeType>
StatusCode XmlUserDeCnv<DeType>::finalize()
{
  if ( m_xmlSvc )   {
    m_xmlSvc->release();
    m_xmlSvc = 0;
  }

  // RIP dear grand father!
  return Converter::finalize();
}

template <class DeType>
StatusCode XmlUserDeCnv<DeType>::createObj(
                                            IOpaqueAddress* pAddress
                                           ,DataObject*& refpObject
                                          )
{

  MsgStream log( msgSvc(), m_msId );
  log << MSG::DEBUG << "Converting " << m_msId << " ..." << endreq;
  
  //m_dataObj = new DeType();
  refpObject = new DeType();

  m_dataObj  = dynamic_cast<DeType*>(refpObject);

//  StatusCode sc = m_deCnv->createObj( pAddress, (DataObject*&)m_dataObj );
  StatusCode sc = m_deCnv->createObj( pAddress, refpObject );

  if( sc.isFailure() )
  {
    log << MSG::DEBUG << "Conversion of " << m_msId
                          << " detector element failed..." << endreq;
    delete refpObject;
  }
//  else
//  {
//    refpObject = (DataObject*)obj;
//  }

  return sc;
}

/// Update the transient object from the other representation.
template <class DeType>
StatusCode XmlUserDeCnv<DeType>::updateObj(
                                            IOpaqueAddress* //pAddress
                                           ,DataObject*     //pObject
                                          )
{
  return StatusCode::SUCCESS;
}

/// Convert the transient object to the requested representation
template <class DeType>
StatusCode XmlUserDeCnv<DeType>::createRep(
                                            DataObject*      //pObject
                                           ,IOpaqueAddress*& //refpAddress
                                          )
{
  return StatusCode::SUCCESS;
}

/// Update the converted representation of a transient object.
template <class DeType>
StatusCode XmlUserDeCnv<DeType>::updateRep(
                                            IOpaqueAddress* //pAddress
                                           ,DataObject*     //pObject
                                          )
{
  return StatusCode::SUCCESS;
}

/// Parsed character data callback
template <class DeType>
void XmlUserDeCnv<DeType>::uCharacters(
                                        const char* const chars
                                       ,const unsigned int length
                                      )
{
  MsgStream log( msgSvc(), m_msId );
  if( length > 0 ) {
    log << MSG::DEBUG << "\"" << chars << "\"" << endreq;
  }
}

/// White space characters callback
template <class DeType>
void XmlUserDeCnv<DeType>::uIgnorableWhitespace(
                                                 const char* const  //chars
                                                ,const unsigned int //length
                                               )
{
}

/// Start of the XML element callback
template <class DeType>
void XmlUserDeCnv<DeType>::uStartElement(
                                          const char* const    name
                                         ,XmlCnvAttributeList& attributes
                                        )
{
  MsgStream log( msgSvc(), m_msId );
  
  std::string tagName( name );
  
  log << MSG::DEBUG << "<" << tagName << " ";
  
  for( unsigned int i = 0; i < attributes.getLength(); i++ ) {
    log << MSG::DEBUG << attributes.getName(i)  << "=" 
      << attributes.getValue(i) << " "
      << attributes.getType(i) << " ";
    ;
  }
  log << ">" << endreq;
}

/// End of the XML element callback
template <class DeType>
void XmlUserDeCnv<DeType>::uEndElement(
                                        const char* const name
                                      )
{
  MsgStream log( msgSvc(), m_msId );
  log << MSG::DEBUG << "</" << name << ">" << endreq;
}

/// End of the XML element callback
template <class DeType>
void XmlUserDeCnv<DeType>::uProcessingInstruction(
                                        const char* const target,
                                        const char* const data
                                      )
{
  MsgStream log( msgSvc(), m_msId );
  log << MSG::DEBUG << "<?" << target << "," << data << "?>" << endreq;
}

template <class DeType>
IXmlSvc* XmlUserDeCnv<DeType>::xmlSvc()
{
  return m_xmlSvc;
}


