// $Header: /afs/cern.ch/project/cvs/reps/lhcb/Det/DetDesc/DetDesc/DetectorElement.icpp,v 1.6 2001-06-28 09:43:53 sponce Exp $

#ifndef       DETDESC_DETECTORELEMENT_ICPP 
#define       DETDESC_DETECTORELEMENT_ICPP  1 


// Include Files
#include "GaudiKernel/MsgStream.h"
#include "GaudiKernel/StreamBuffer.h"

#include "DetDesc/DetectorElement.h"
#include "DetDesc/DetectorElementException.h"


///  output operators to MsgStream ///////////////////////////////////////////
inline MsgStream& operator<< (MsgStream& os, const DetectorElement& de) {
  return de.printOut(os);
}

inline MsgStream& operator<< (MsgStream& os, const DetectorElement* de) {
  if (0 == de) {
    return os << "DetectorElement* points to NULL"<< endreq;
  } else {
    return os << *de;
  }
}

//////////////////////////////////////////////////////////////////////////////
inline const IGeometryInfo* DetectorElement::geometry () const {
  return m_de_iGeometry;
};
inline IGeometryInfo* DetectorElement::geometry () {
  return m_de_iGeometry;
};
inline const IAlignment* DetectorElement::alignment () const {
  return m_de_iAlignment;
};
inline IAlignment* DetectorElement::alignment() {
  return m_de_iAlignment;
};
inline const ICalibration* DetectorElement::calibration() const {
  return m_de_iCalibration ;
};
inline ICalibration* DetectorElement::calibration() {
  return m_de_iCalibration ;
};
inline const IReadOut* DetectorElement::readOut() const {
  return m_de_iReadOut     ;
};
inline IReadOut* DetectorElement::readOut() {
  return m_de_iReadOut     ;
};
inline const ISlowControl*  DetectorElement::slowControl() const {
  return m_de_iSlowControl ;
};
inline ISlowControl* DetectorElement::slowControl() {
  return m_de_iSlowControl ;
};
inline const IFastControl*  DetectorElement::fastControl() const {
  return m_de_iFastControl ;
};
inline IFastControl* DetectorElement::fastControl() {
  return m_de_iFastControl ;
};
// "pseudo-casting" //////////////////////////////////////////////////////////
inline DetectorElement::operator const IGeometryInfo*() const {
  return m_de_iGeometry    ;
};
inline DetectorElement::operator IGeometryInfo*() {
  return m_de_iGeometry    ;
};
inline DetectorElement::operator const IAlignment* () const {
  return m_de_iAlignment   ;
};
inline DetectorElement::operator IAlignment* () {
  return m_de_iAlignment   ;
};
inline DetectorElement::operator const ICalibration* () const {
  return m_de_iCalibration ;
};
inline DetectorElement::operator ICalibration* () {
  return m_de_iCalibration ;
};
inline DetectorElement::operator const IReadOut* () const {
  return m_de_iReadOut     ;
};
inline DetectorElement::operator IReadOut* () {
  return m_de_iReadOut     ;
};
inline DetectorElement::operator const ISlowControl* () const {
  return m_de_iSlowControl ;
};
inline DetectorElement::operator ISlowControl* () {
  return m_de_iSlowControl ;
};
inline DetectorElement::operator const IFastControl* () const {
  return m_de_iFastControl ;
};
inline DetectorElement::operator IFastControl* () {
  return m_de_iFastControl ;
};
//////////////////////////////////////////////////////////////////////////////
inline DetectorElement::operator const IGeometryInfo&()    const 
{
  Assert (0 != m_de_iGeometry, "DetectorElement::geometry is not available!");
  return *m_de_iGeometry    ; 
};
//////////////////////////////////////////////////////////////////////////////
inline DetectorElement::operator       IGeometryInfo&()
{ 
  Assert (0 != m_de_iGeometry, "DetectorElement::geometry is not available!");
  return *m_de_iGeometry    ; 
};
//////////////////////////////////////////////////////////////////////////////
inline DetectorElement::operator const IAlignment&   ()    const 
{ 
  Assert (0 != m_de_iAlignment,
          "DetectorElement::alignment is not available!");
  return *m_de_iAlignment   ; 
};
//////////////////////////////////////////////////////////////////////////////
inline DetectorElement::operator       IAlignment&   ()          
{ 
  Assert (0 != m_de_iAlignment,
          "DetectorElement::alignment is not available!");
  return *m_de_iAlignment   ; 
};
//////////////////////////////////////////////////////////////////////////////
inline DetectorElement::operator const ICalibration& ()    const 
{ 
  Assert (0 != m_de_iCalibration,
          "DetectorElement::calibration is not available!");
  return *m_de_iCalibration ; 
};
///////////////////////////////////////////////////////////////////////////////
inline DetectorElement::operator       ICalibration& ()          
{ 
  Assert (0 != m_de_iCalibration,
          "DetectorElement::calibration is not available!");
  return *m_de_iCalibration ; 
};
///////////////////////////////////////////////////////////////////////////////
inline DetectorElement::operator const IReadOut&     ()    const 
{ 
  Assert (0 != m_de_iReadOut, "DetectorElement::readout is not available!");
  return *m_de_iReadOut     ; 
};
///////////////////////////////////////////////////////////////////////////////
inline DetectorElement::operator       IReadOut&     ()          
{ 
  Assert (0 != m_de_iReadOut, "DetectorElement::readout is not available!");
  return *m_de_iReadOut     ; 
};
///////////////////////////////////////////////////////////////////////////////
inline DetectorElement::operator const ISlowControl& ()    const 
{ 
  Assert (0 != m_de_iSlowControl,
          "DetectorElement::slowcontrol is not available!");
  return *m_de_iSlowControl ; 
};
////////////////////////////////////////////////////////////////////////////////
inline DetectorElement::operator       ISlowControl& ()          
{ 
  Assert (0 != m_de_iSlowControl,
          "DetectorElement::slowcontrol is not available!");
  return *m_de_iSlowControl ; 
};
////////////////////////////////////////////////////////////////////////////////
inline DetectorElement::operator const IFastControl& ()    const 
{ 
  Assert (0 != m_de_iFastControl,
          "DetectorElement::fastcontrol is not available!");
  return *m_de_iFastControl ; 
};
///////////////////////////////////////////////////////////////////////////////
inline DetectorElement::operator       IFastControl& ()          
{ 
  Assert (0 != m_de_iFastControl,
          "DetectorElement::fastcontrol is not available!");
  return *m_de_iFastControl ; 
};
//  from IValidity Interface: /////////////////////////////////////////////////
inline bool DetectorElement::isValid () {
  return validSince() < validTill() ;};
inline bool DetectorElement::isValid (const ITime& t) {
  return validSince() < t &&  t < validTill() ;};
/// assertion /////////////////////////////////////////////////////////////////
inline void DetectorElement::Assert (bool assertion,
                                     const std::string& assertionName) const {
  if (!assertion) {
    throw DetectorElementException (assertionName, this);
  }
};
/// (reference to) container of pointers to child detector elements ///////////
inline IDetectorElement::IDEContainer&
DetectorElement::childIDetectorElements() {
  /// already loaded? 
  if( m_de_childrensLoaded ) { return m_de_childrens; } 
  /// load them! 
  const IDataDirectory*  dir = this->directory(); 
  Assert (0 != dir , "const IDataDirectory** point to NULL!" );
  for (IDataDirectory::ConstDirIterator it = dir->begin();
       dir->end() != it ;
       ++it) {
    Assert (0 != *it , "ConstDirIterator points to NULL!" );
    SmartDataPtr<IDetectorElement> de( dataSvc() , (*it)->fullpath() );
    IDetectorElement* ide = de ;
    Assert (0 != ide , "Could not load child object="+(*it)->fullpath() );
    m_de_childrens.push_back( ide  );
  }
  m_de_childrensLoaded = true; 
  return m_de_childrens;
};
/// (reference to) container of pointers to child detector elements ///////////
inline const IDetectorElement::IDEContainer&
DetectorElement::childIDetectorElements() const {
  /// already loaded? 
  if( m_de_childrensLoaded ) { return m_de_childrens; } 
  /// load them! 
  const IDataDirectory*  dir = this->directory(); 
  Assert (0 != dir , "const IDataDirectory** point to NULL!" );
  for (IDataDirectory::ConstDirIterator it = dir->begin();
       dir->end() != it;
       ++it) {
    Assert (0 != *it , "ConstDirIterator points to NULL!" );
    SmartDataPtr<IDetectorElement> de( dataSvc() , (*it)->fullpath() );
    IDetectorElement* ide = de ;
    Assert (0 != ide , "Could not load child object="+(*it)->fullpath() );
    m_de_childrens.push_back( ide  );
  }
  ///
  m_de_childrensLoaded = true; 
  ///
  return m_de_childrens;
};
///

//////////////////////////////////////////////////////
/// addUserParameter
//////////////////////////////////////////////////////
void DetectorElement::addUserParameter (std::string name,
                                        std::string type,
                                        std::string comment,
                                        std::string value,
                                        double d_value) {
  UserParam userParam;
  userParam.type = type;
  userParam.comment = comment;
  userParam.value = value;
  userParam.d_value = d_value;
  userParam.i_value = 0; // this is never used
  userParam.kind = DOUBLE;
  m_userParameters[name] = userParam;
}
  
//////////////////////////////////////////////////////
/// addUserParameter
//////////////////////////////////////////////////////
void DetectorElement::addUserParameter (std::string name,
                                        std::string type,
                                        std::string comment,
                                        std::string value,
                                        double d_value,
                                        int i_value) {
  UserParam userParam;
  userParam.type = type;
  userParam.comment = comment;
  userParam.value = value;
  userParam.d_value = d_value;
  userParam.i_value = i_value;
  userParam.kind = INT;
  m_userParameters[name] = userParam;
}
  
//////////////////////////////////////////////////////
/// addUserParameter
//////////////////////////////////////////////////////
void DetectorElement::addUserParameter (std::string name,
                                        std::string type,
                                        std::string comment,
                                        std::string value) {
  UserParam userParam;
  userParam.type = type;
  userParam.comment = comment;
  userParam.value = value;
  userParam.d_value = 0.0; // this is never used
  userParam.i_value = 0; // this is never used
  userParam.kind = OTHER;
  m_userParameters[name] = userParam;
}
  
//////////////////////////////////////////////////////
/// addUserParameterVector
//////////////////////////////////////////////////////
void DetectorElement::addUserParameterVector (std::string name,
                                              std::string type,
                                              std::string comment,
                                              std::vector<std::string> value,
                                              std::vector<double> d_value) {
  UserParamVector userParamVector;
  userParamVector.type = type;
  userParamVector.comment = comment;
  userParamVector.value = value;
  userParamVector.d_value = d_value;
  // userParamVector.i_value is is never used
  userParamVector.kind = DOUBLE;
  m_userParameterVectors[name] = userParamVector;
}

//////////////////////////////////////////////////////
/// addUserParameterVector
//////////////////////////////////////////////////////
void DetectorElement::addUserParameterVector (std::string name,
                                              std::string type,
                                              std::string comment,
                                              std::vector<std::string> value,
                                              std::vector<double> d_value,
                                              std::vector<int> i_value) {
  UserParamVector userParamVector;
  userParamVector.type = type;
  userParamVector.comment = comment;
  userParamVector.value = value;
  userParamVector.d_value = d_value;
  userParamVector.i_value = i_value;
  userParamVector.kind = INT;
  m_userParameterVectors[name] = userParamVector;
}

//////////////////////////////////////////////////////
/// addUserParameterVector
//////////////////////////////////////////////////////
void DetectorElement::addUserParameterVector (std::string name,
                                              std::string type,
                                              std::string comment,
                                              std::vector<std::string> value) {
  UserParamVector userParamVector;
  userParamVector.type = type;
  userParamVector.comment = comment;
  userParamVector.value = value;
  // userParamVector.d_value is is never used
  // userParamVector.i_value is is never used
  userParamVector.kind = OTHER;
  m_userParameterVectors[name] = userParamVector;
}

//////////////////////////////////////////////////////
/// userParameterType
//////////////////////////////////////////////////////
inline std::string DetectorElement::userParameterType (std::string name) {
  if (m_userParameters.find(name) == m_userParameters.end()) {
    throw DetectorElementException("No userParameter with this name : \""
                                   + name + "\" !");
  }
  return m_userParameters[name].type;
}
  
//////////////////////////////////////////////////////
/// userParameterComment
//////////////////////////////////////////////////////
inline std::string DetectorElement::userParameterComment (std::string name) {
  if (m_userParameters.find(name) == m_userParameters.end()) {
    throw DetectorElementException("No userParameter with this name : \""
                                   + name + "\" !");
  }
  return m_userParameters[name].comment;
}
  
//////////////////////////////////////////////////////
/// userParameterAsString
//////////////////////////////////////////////////////
inline std::string DetectorElement::userParameterAsString (std::string name) {
  if (m_userParameters.find(name) == m_userParameters.end()) {
    throw DetectorElementException("No userParameter with this name : \""
                                   + name + "\" !");
  }
  return m_userParameters[name].value;
}
  
//////////////////////////////////////////////////////
/// userParameterAsInt
//////////////////////////////////////////////////////
inline int DetectorElement::userParameterAsInt (std::string name) {
  if (m_userParameters.find(name) == m_userParameters.end()) {
    throw DetectorElementException("No userParameter with this name : \""
                                   + name + "\" !");
  }
  if (m_userParameters[name].kind != INT) {
    throw DetectorElementException("userParameter " + name +
                                   " does not have an integer value.");
  }
  return m_userParameters[name].i_value;
}

//////////////////////////////////////////////////////
/// userParameterAsDouble
//////////////////////////////////////////////////////
inline double DetectorElement::userParameterAsDouble (std::string name) {
  if (m_userParameters.find(name) == m_userParameters.end()) {
    throw DetectorElementException("No userParameter with this name : \""
                                   + name + "\" !");
  }
  if (m_userParameters[name].kind != DOUBLE &&
      m_userParameters[name].kind != INT ) {
    throw DetectorElementException("userParameter " + name +
                                   " does not have a numerical value.");
  }
  return m_userParameters[name].d_value;
}
  
//////////////////////////////////////////////////////
/// userParameter
//////////////////////////////////////////////////////
inline double DetectorElement::userParameter (std::string name) {
  return userParameterAsDouble (name);
}  
  
//////////////////////////////////////////////////////
/// userParameterVectorType
//////////////////////////////////////////////////////
inline std::string DetectorElement::userParameterVectorType (std::string name) {
  if (m_userParameterVectors.find(name) == m_userParameterVectors.end()) {
    throw DetectorElementException("No userParameterVector with this name : \""
                                   + name + "\" !");
  }
  return m_userParameterVectors[name].type;
}
  
//////////////////////////////////////////////////////
/// userParameterVectorComment
//////////////////////////////////////////////////////
inline std::string
DetectorElement::userParameterVectorComment (std::string name) {
  if (m_userParameterVectors.find(name) == m_userParameterVectors.end()) {
    throw DetectorElementException("No userParameterVector with this name : \""
                                   + name + "\" !");
  }
  return m_userParameterVectors[name].comment;
}
  
//////////////////////////////////////////////////////
/// userParameterVectorAsString
//////////////////////////////////////////////////////
inline std::vector<std::string>
DetectorElement::userParameterVectorAsString (std::string name) {
  if (m_userParameterVectors.find(name) == m_userParameterVectors.end()) {
    throw DetectorElementException("No userParameterVector with this name : \""
                                   + name + "\" !");
  }
  return m_userParameterVectors[name].value;
}
  
//////////////////////////////////////////////////////
/// userParameterVectorAsInt
//////////////////////////////////////////////////////
inline std::vector<int>
DetectorElement::userParameterVectorAsInt (std::string name) {
  if (m_userParameterVectors.find(name) == m_userParameterVectors.end()) {
    throw DetectorElementException("No userParameterVector with this name : \""
                                   + name + "\" !");
  }
  if (m_userParameterVectors[name].kind != INT) {
    throw DetectorElementException("userParameterVector " + name +
                                   " does not have integer values.");
  }
  return m_userParameterVectors[name].i_value;
}

//////////////////////////////////////////////////////
/// userParameterVectorAsDouble
//////////////////////////////////////////////////////
inline std::vector<double>
DetectorElement::userParameterVectorAsDouble (std::string name) {
  if (m_userParameterVectors.find(name) == m_userParameterVectors.end()) {
    throw DetectorElementException("No userParameterVector with this name : \""
                                   + name + "\" !");
  }
  if (m_userParameters[name].kind != DOUBLE &&
      m_userParameters[name].kind != INT ) {
    throw DetectorElementException("userParameterVector " + name +
                                   " does not have numerical values.");
  }
  return m_userParameterVectors[name].d_value;
}

//////////////////////////////////////////////////////
/// userParameterVector
//////////////////////////////////////////////////////
inline std::vector<double>
DetectorElement::userParameterVector (std::string name) {
  return userParameterVectorAsDouble (name);
}

//////////////////////////////////////////////////////
/// userParameters
//////////////////////////////////////////////////////
inline std::vector<std::string> DetectorElement::userParameters() {
  std::vector<std::string> result;
  for (UserParamMap::iterator it = m_userParameters.begin();
       m_userParameters.end() != it;
       ++it) {
    result.push_back(it->first);
  }
  return result;
}
   
//////////////////////////////////////////////////////
/// userParameterVectors
//////////////////////////////////////////////////////
inline std::vector<std::string> DetectorElement::userParameterVectors() {
  std::vector<std::string> result;
  for (UserParamVectorMap::iterator it = m_userParameterVectors.begin();
       m_userParameterVectors.end() != it;
       ++it) {
    result.push_back(it->first);
  }
  return result;
}


#endif  //    DETDESC_DETECTORELEMENT_ICPP 
