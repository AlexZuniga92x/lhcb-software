#ifndef     DETDESC_SOLIDCHILD_ICPP 
#define     DETDESC_SOLIDCHILD_ICPP  1 
/// GaudiKernel 
#include "GaudiKernel/MsgStream.h"
/// DetDesc/ 
#include "DetDesc/SolidChild.h"
///

//////////////////////////////////////////////////////////////////////////////////////////
inline MsgStream&    operator<<( MsgStream&    os , const SolidChild& box )          
{ return  box.printOut( os ); }
//////////////////////////////////////////////////////////////////////////////////////////
inline MsgStream&    operator<<( MsgStream&    os , const SolidChild* box )           
{ return box  ? (os<<*box) : (os<<" SolidChild* points to NULL!"<<endreq) ; }
//////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////
inline const HepTransform3D& SolidChild::matrix() const
{
  if( 0 == m_sc_matrix ) { m_sc_matrix = new  HepTransform3D; }
  return *m_sc_matrix;
};
///////////////////////////////////////////////////////////////////////////////////////
inline bool SolidChild::isInside( const HepPoint3D& point ) const
{ return  ( simple() ? solid()->isInside(point) : solid()->isInside( matrix() * point ) ) ; }; 
///////////////////////////////////////////////////////////////////////////////////////
class Solid_isInside: public std::unary_function<const ISolid*,bool>
{
  ///
 public:
  ///
  explicit Solid_isInside( const HepPoint3D& pointInMotherSystem ) 
    : point( pointInMotherSystem ){};
  //
  inline bool operator() ( const ISolid* solid ) const  
    { return ( 0 == solid ? false : solid->isInside(point) ); };
  //
 private:
  //
  HepPoint3D point;
  //
};
/// reset to the initial state //////////////////////////////////////////////////////////////////
inline const ISolid* SolidChild::reset        () const  
{ if( 0 != solid() ) { solid()->reset() ; } return this; }
/** calculate the intersection points("ticks") with a given line. 
    Input - line, paramterised by (Point + Vector * Tick) 
    "Tick" is just a value of parameter, at which the intercestion occurs 
    Return the number of intersection points (=size of Ticks container)   
*/
inline  unsigned int SolidChild::intersectionTicks ( const HepPoint3D & point  ,       // initial point for teh line 
						     const HepVector3D & vect   ,      // vector along the line 
						     ISolid::Ticks    & ticks  ) const // output container of "Ticks"
{
  return solid()->intersectionTicks(  simple() ? point : matrix() * point , 
                                      simple() ? vect  : matrix() * vect  , 
				      ticks                               ) ;
};
/** calculate the intersection points("ticks") with a given line. 
    Input - line, paramterised by (Point + Vector * Tick) 
    "Tick" is just a value of parameter, at which the intercestion occurs 
    Return the number of intersection points (=size of Ticks container)   
*/
inline  unsigned int SolidChild::intersectionTicks ( const HepPoint3D &  point   ,       // initial point for teh line 
						     const HepVector3D &  vect    ,      // vector along the line 
                                                     const ISolid::Tick& tickMin , 
                                                     const ISolid::Tick& tickMax , 
						     ISolid::Ticks    &  ticks   ) const // output container of "Ticks"
{
  return solid()->intersectionTicks(  simple() ? point : matrix() * point , 
                                      simple() ? vect  : matrix() * vect  , 
				      tickMin , tickMax , ticks           ) ;
};
///////////////////////////////////////////////////////////////////////////////////////////////////

#endif  //  DETDESC_SOLIDCHILD_ICPP 

