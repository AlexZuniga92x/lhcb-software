<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE gdd SYSTEM 'gdd.dtd'>
<gdd>
  <package name='HltEvent'>

<!-- HltSummary Class : Auxiliar Class-->

    <class
      name = "HltEnums"
      author      = 'Jose Hernando'
      desc = "Enumerations for the Hlt Summary classes">

      <enum
        name   = 'HltDecisionType'
        desc   = 'Trigger type decision: muon, dimuon ,etc'
        value  = 'Decision=1,
                  Muon=2,
	          DiMuon=4,
	          JPsi=8,
	          MuonHadron=16,
	          Hadron=32,
	          DiHadron=64,
	          Electron=128,
 	          DiElectron=256,
	          Gamma=512,
                  Random=1024'
        access = 'PUBLIC' />

      <enum
        name   = 'HltAlley'
        desc   = 'Hlt alley'
        value  = 'AlleyUnknown=0,
	          Mu,
	          MuHad,
	          Had,
                  Cal'
        access = 'PUBLIC' />

      <enum
        name   = 'HltBox'
        desc   = 'Hlt box'
        value  = 'HltBoxUnknown=0,
	          MuonEntry,
	          MuonL0Conf,
	          MuonPreTrigger,
	          MuonTrigger,
                  MuonHadEntry,
                  MuonHadL0Conf,
	          MuonHadPreTrigger,
                  MuonHadTrigger,
	          HadEntry,
                  HadL0Conf,
                  HadPreTrigger,
                  HadTrigger,
                  CalEntry,
                  CalL0Conf,
                  CalPreTrigger,
	          CalTrigger'
        access = 'PUBLIC' />
      
      <enum
        name   = 'HltQuantity'
        desc   = 'Monitoring Quantities'
	value  = 'HltQuantityUnknown=0,
	BoxDecision,
	NInputTracks,
	NInputTracks1,
	NPVertices,
	NInputVertices,
	NOutputTracks,
	NOutputTrack2,
	NOutputVertices'
        access = 'PUBLIC' />

      <enum
        name   = 'HltParticleInfo'
        desc   = 'Monitoring Quantities'
        value  = 'HltParticleInfoUnknown=0,
	RZVeloKey,
	VeloKey,
	VeloTTKey,
	ForwardKey,
	MuonKey,
	CaloKey,
	PVKey,
	rIP,
	IP,
	IPS,
	PT,
	Mass,
	DOCA,
	VertexChi2,
	VertexD,
	VertexDS,
	VertexRho,
	VertexDz,
	VertexPointing,
	Muon2DChi2,
	Muon3DChi2,
	Calo2DChi2,
	Calo3DChi2'
	access = ' PUBLIC' />	
    </class>
    
    <class
      name        = 'HltSummaryBox'
      author      = 'Jose Hernando'
      desc        = 'Summary class for Hlt box'>

      <import name='GaudiKernel/VectorMap' />
      <import name='Event/Track' />
      <import name='Event/RecVertex' />

      <attribute
        type = 'bitfield'
        name = 'pattern'
        desc = 'trigger pattern'
	init = '0'
	access = 'PROTECTED' >
	<bitfield
	  type = 'LHCb::Hlt::HltDecisionType'
	  name = 'decisionType'
	  length = '20'
	  desc = 'trigger decision type: muon, dimuon, etc'
	  setMeth = 'FALSE'
	  getMeth = 'FALSE'
	  checkMeth = 'FALSE' /> 
      </attribute>

      <attribute
        type      = 'GaudiUtils::VectorMap&lt; int, double &gt;'
        name      = 'quantities'
        desc      = 'vmap of quantities'
        access    = 'PROTECTED'/>

      <relation
        type      = 'LHCb::Track'
        name      = 'tracks'
        desc      = 'saved tracks this trigger box'
	setMeth = 'FALSE'
        access    = 'PROTECTED'
	multiplicity = 'N' />

      <relation
        type      = 'LHCb::RecVertex'
        name      = 'vertices'
        desc      = 'saved tracks this trigger box'
	setMeth = 'FALSE'
        access    = 'PROTECTED'
	multiplicity = 'N' />

      <method
	type = 'bool'
	name = 'decision'
	desc = 'returns the trigger decision'
	const = 'TRUE' >
	<code>
return checkDecisionType(1);
	</code>
      </method>

      <method
	name = 'setDecision'
	desc = 'returns the trigger decision'
	argList = 'bool decision' >
	<code>
setDecisionType(1,decision);
	</code>
      </method>
      
      <method
	name    = 'setDecisionType'
	argList = 'unsigned int decisionType, bool ok'
	desc    = 'Update the decisionType (see the DecisionTypes enum)'>
	<code>
unsigned int val = (((unsigned int) decisionType) &lt;&lt; decisionTypeBits) &amp; decisionTypeMask;
if (ok) m_pattern |= val;
else m_pattern &amp;= ~val;
if (ok &amp;&amp; (decisionType != 1) ) setDecision(ok);
        </code>
      </method>

      <method
	type    = 'bool'
	name    = 'checkDecisionType'
        argList = 'unsigned int decisionType'
        desc    = 'Check the status of the decisionType (see the DecisionTypes enum)'
        const   = 'TRUE'>
        <code>
unsigned int val = ((unsigned int) decisionType &lt;&lt; decisionTypeBits);  
bool ok = (0 != ( m_pattern &amp; decisionTypeMask &amp; val ));
return ok;
        </code>
      </method>

      <method
        type = 'bool'
        name = 'hasQuantity'
        desc = 'has this quantity?'
        argList = 'int label'
        const = 'TRUE'>
        <code>
    return (m_quantities.find(label) != m_quantities.end());
        </code>
      </method>
	
      <method
        type    = 'double'
        name    = 'quantity'
        desc    = 'retrieve the quantity'
        argList = 'int label '	
        const   = 'TRUE'>
        <code>
   if (m_quantities.find(label) == m_quantities.end()) return 0.;
   return m_quantities.find(label)->second;
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'setQuantity'
	desc    = 'set the quantity value' 
        argList = 'int label, double value'>
	<code>
   m_quantities.insert(label,value);
	</code>
      </method>

      <method
        name    = 'addTrack'
        desc    = 'Add a Track to the list of saved Track'>
        <arg type = 'const LHCb::Track ' name='track' />
        <code>
  m_tracks.push_back( (LHCb::Track*) &amp; track );
        </code>
      </method>


      <method
        name    = 'addRecVertex'
        desc    = 'Add a RecVertex to the list of saved TrackVertices'>
        <arg type = 'const LHCb::RecVertex ' name='vertex' />
        <code>
  m_vertices.push_back( (LHCb::RecVertex*) &amp; vertex );
        </code>
      </method>
           
    </class>
    
<!-- HltSummary Class -->

    <class
      name        = 'HltSummary'
      author      = 'Jose Hernando'
      desc        = 'Summary class for Hlt'
      id          = '7510'>

      <location name="Default"   place="Hlt/Summary"/>
 
      <base name='DataObject' />
      &DataObject;

      <import name='GaudiKernel/GaudiException' />
      <import name="GaudiKernel/KeyedObject"/>
      <import name='GaudiKernel/VectorMap' />
      <import name='Event/HltSummaryBox' />

      <attribute
        type = 'bitfield'
        name = 'pattern'
        desc = 'trigger pattern'
	init = '0'
	access = 'PUBLIC' >
	<bitfield
	  type = 'int'
	  name = 'decisionType'
	  length = '20'
	  desc = 'trigger decision type: muon, dimuon, etc'
	  setMeth = 'FALSE'
	  getMeth = 'FALSE'
	  checkMeth = 'FALSE' /> 
      </attribute>

      <attribute
        type      = 'GaudiUtils::VectorMap&lt; int, LHCb::HltSummaryBox &gt;'
        name      = 'boxes'
        desc      = 'map of HltSummaryBox es'
        access    = 'PROTECTED' />
      
      <method
	type = 'bool'
	name = 'decision'
	desc = 'returns the trigger decision'
	const = 'TRUE' >
	<code>
return checkDecisionType(1);
	</code>
      </method>

      <method
	name = 'setDecision'
	desc = 'returns the trigger decision'
	argList = 'bool decision' >
	<code>
setDecisionType(1,decision);
	</code>
      </method>
      
      <method
	name    = 'setDecisionType'
	argList = 'unsigned int decisionType, bool ok'
	desc    = 'Update the decisionType (see the DecisionTypes enum)'>
	<code>
unsigned int val = (((unsigned int) decisionType) &lt;&lt; decisionTypeBits) &amp; decisionTypeMask;
if (ok) m_pattern |= val;
else m_pattern &amp;= ~val;
if (ok &amp;&amp; decisionType != 1) setDecision(ok);
        </code>
      </method>

      <method
	type    = 'bool'
	name    = 'checkDecisionType'
        argList = 'unsigned int decisionType'
        desc    = 'Check the status of the decisionType (see the DecisionTypes enum)'
        const   = 'TRUE'>
        <code>
unsigned int val = ((unsigned int) decisionType &lt;&lt; decisionTypeBits);  
bool ok = (0 != ( m_pattern &amp; decisionTypeMask &amp; val ));
return ok;
        </code>
      </method>

    
      <method
        type = 'bool'
        name = 'hasSummaryBox'
        desc = 'has a summary from this trigger box?'
        argList = 'int boxid'
        const = 'TRUE'>
        <code>
    return (m_boxes.find(boxid) != m_boxes.end());
        </code>
      </method>

      <method
        type = 'const LHCb::HltSummaryBox &amp;'
        name = 'summaryBox'
        desc = 'return summary box from this triger box'
        argList = 'int boxid'
        const = 'TRUE' >
        <code>
   GaudiUtils::VectorMap&lt;int,LHCb::HltSummaryBox&gt;::iterator it = m_boxes.find(boxid);  
   if (it != m_boxes.end()) return it->second;
   else 
      throw GaudiException( "No requested HltSummaryBox in HltSummary","HltSummary",StatusCode::FAILURE );
        </code>
      </method>
      
      <method
        type = 'LHCb::HltSummaryBox &amp;'
        name = 'summaryBox'
        desc = 'returns sumary box, if not in map, it will create it'
        argList = 'int boxid'
        const = 'FALSE'>
        <code>
   GaudiUtils::VectorMap&lt;int,LHCb::HltSummaryBox&gt;::iterator it = m_boxes.find(boxid);
   if (it == m_boxes.end()) {
       LHCb::HltSummaryBox thebox;
       m_boxes.insert(boxid,thebox);
   }
   it = m_boxes.find(boxid);
   LHCb::HltSummaryBox* thebox = (LHCb::HltSummaryBox*) (&amp;(it->second));
   return *thebox;
        </code>
      </method>

      <method
        type = 'std::vector &lt; int &gt;'
        name = 'summaryBoxIDs'
        desc = 'return the boxes names stored in the summary'
        const = 'TRUE' >
        <code>
    std::vector&lt;int&gt; names;
    GaudiUtils::VectorMap&lt;int,LHCb::HltSummaryBox&gt;::iterator it = m_boxes.begin();
    for (; it != m_boxes.end(); it++) names.push_back(it->first);
    return names;
        </code>
      </method>
      

    </class>

  </package>

</gdd>
