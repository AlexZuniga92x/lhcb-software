
// from Gaudi
#include "GaudiKernel/AlgFactory.h"

// Local
#include "PackerBaseAlg.h"

using namespace DataPacking;

//=============================================================================
// Standard constructor, initializes variables
//=============================================================================
template < class PACKER >
Pack<PACKER>::Pack( const std::string& name,
                    ISvcLocator* pSvcLocator )
  : GaudiAlgorithm ( name , pSvcLocator )
{
  declareProperty( "InputName" , m_inputName   = PACKER::unpackedLocation() );
  declareProperty( "OutputName", m_outputName  = PACKER::packedLocation()   );
  declareProperty( "PackingVersion", m_version = 0                          );
}

template < class PACKER >
Pack<PACKER>::~Pack() { }

template < class PACKER >
StatusCode Pack<PACKER>::initialize()
{
  const StatusCode sc = GaudiAlgorithm::initialize();
  if ( sc.isFailure() ) return sc;

  info() << "Input '" << rootInTES() << m_inputName 
         << "' Output '" << rootInTES() << m_outputName << "'" << endmsg;

  return sc;
}

template < class PACKER >
StatusCode Pack<PACKER>::execute()
{
  // Load the input data
  typename PACKER::DataVector * data = 
    this->getOrCreate<typename PACKER::DataVector,typename PACKER::DataVector>(m_inputName);

  // Make the output packed data
  typename PACKER::PackedDataVector * pdata = 
    new typename PACKER::PackedDataVector();

  // set data version
  pdata->setVersion(data->version());

  // Set packing version number
  pdata->setPackingVersion(m_version);

  // give new container to Gaudi
  this->put( pdata, m_outputName );

  // Packer
  static const PACKER packer;

  // Fill packed data
  packer.pack( *data, *pdata );  

  // Clear the registry address of the unpacked container, to prevent reloading
  pdata->registry()->setAddress( 0 );

  return StatusCode::SUCCESS;
}
