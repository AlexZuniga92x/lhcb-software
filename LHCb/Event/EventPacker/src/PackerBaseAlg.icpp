
// from Gaudi
#include "GaudiKernel/AlgFactory.h"

// Local
#include "PackerBaseAlg.h"

using namespace DataPacking;

//=============================================================================
// Standard constructor, initializes variables
//=============================================================================
template < class PACKER >
Pack<PACKER>::Pack( const std::string& name,
                    ISvcLocator* pSvcLocator )
  : GaudiAlgorithm ( name , pSvcLocator )
{
  declareProperty( "InputName" , m_inputName   = PACKER::unpackedLocation() );
  declareProperty( "OutputName", m_outputName  = PACKER::packedLocation()   );
  declareProperty( "PackingVersion", m_version = 0                          );
}

template < class PACKER >
Pack<PACKER>::~Pack() { }

template < class PACKER >
StatusCode Pack<PACKER>::initialize()
{
  const StatusCode sc = GaudiAlgorithm::initialize();
  if ( sc.isFailure() ) return sc;

  info() << "Input '" << rootInTES() << m_inputName
         << "' Output '" << rootInTES() << m_outputName << "'" << endmsg;

  return sc;
}

template < class PACKER >
StatusCode Pack<PACKER>::execute()
{
  // Check to see if the output data already exists.
  // If it does silently return doing nothing
  DataObject * pObject(NULL);
  StatusCode test = eventSvc()->findObject( m_outputName, pObject );
  if ( test.isFailure() )
  {

    // if input does not exist, just return doing nothing again
    test = eventSvc()->findObject( m_inputName, pObject );
    if ( test.isSuccess() )
    {

      // Load the input data
      typename PACKER::DataVector * data = 
        this->get<typename PACKER::DataVector>(m_inputName);

      // Make the output packed data
      typename PACKER::PackedDataVector * pdata =
        new typename PACKER::PackedDataVector();

      // set data version
      pdata->setVersion(data->version());

      // Set packing version number
      pdata->setPackingVersion(m_version);

      // give new container to Gaudi
      this->put( pdata, m_outputName );

      // Packer
      static const PACKER packer;

      // Fill packed data
      packer.pack( *data, *pdata );

      // Clear the registry address of the unpacked container, to prevent reloading
      pdata->registry()->setAddress( 0 );

    } // input

  } // output

  return StatusCode::SUCCESS;
}
