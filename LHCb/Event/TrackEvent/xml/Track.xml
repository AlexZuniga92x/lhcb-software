<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE gdd SYSTEM 'gdd.dtd'>
<gdd>
  <package name='TrackEvent'>

<!-- ==================== Track class definition ==================== -->

    <class
      name        = 'Track'
      author      = 'Jose Hernando, Eduardo Rodrigues'
      desc        = 'Track is the base class for offline and online tracks.'
      id          = '10010'
      location    = 'Rec/Track/Best'
      serializers = 'FALSE'>

      <location name="Velo"    place="Rec/Track/Velo"/>
      <location name="Seed"    place="Rec/Track/Seed"/>
      <location name="Match"   place="Rec/Track/Match"/>
      <location name="Forward" place="Rec/Track/Forward"/>
      <location name="Follow"  place="Rec/Track/Follow"/>
      <location name="VeloTT"  place="Rec/Track/VeloTT"/>
      <location name="KsTrack" place="Rec/Track/KsTrack"/>

      <base name='KeyedObject&lt;int&gt;' />
      &KeyedObject;

      <import name='Event/State' />
      <import name='Event/Measurement' />
      <import name='Event/Node' />
      <import name='Kernel/LHCbID' />
      <import name='CLHEP/Geometry/Plane3D' />

      <constructor 
	desc     = "Constructor with assigned key" 
	argList  = "int key " 
	initList = "KeyedObject&lt;int&gt;( key ), m_chi2PerDoF(0.0), m_nDoF(0), m_flags(0), m_lhcbIDs(), m_physicsState(), m_states()">
      </constructor>

      <destructor
        desc = 'Track destructor'>
        <code>
  reset();
        </code>
      </destructor>

      <attribute
        type   = 'double'
        name   = 'chi2PerDoF'
        desc   = 'chi^2 per degree of freedom of the track'
        access = 'PROTECTED' />

      <attribute
        type   = 'int'
        name   = 'nDoF'
        desc   = 'number of degrees of freedom of the track'
        access = 'PROTECTED' />

     <attribute
       type    = 'bitfield'
       name    = 'flags'
       desc    = 'the variety of track flags'
       init    = '0'
       setMeth = 'TRUE'
       access  = 'PROTECTED'>
       <bitfield
         name      = 'type'
         length    = '5'
         desc      = 'track type'
         setMeth   = 'FALSE'
         getMeth   = 'FALSE'
         checkMeth = 'FALSE' />
       <bitfield
         name      = 'history'
         length    = '5'
         desc      = 'specifies the pattern recogn algorithm that created the track'
         setMeth   = 'FALSE'
         getMeth   = 'FALSE'
         checkMeth = 'FALSE' />
       <bitfield
         name      = 'historyFit'
         length    = '5'
         desc      = 'specifies the fitting algorithm the fitted the track)'
         setMeth   = 'FALSE'
         getMeth   = 'FALSE'
         checkMeth = 'FALSE' />
       <bitfield
         name      = 'status'
         length    = '3'
         desc      = 'status of the track'
	 setMeth   = 'FALSE'
         getMeth   = 'FALSE'
         checkMeth = 'FALSE' />
       <bitfield
         name      = 'flag'
         length    = '10'
         desc      = 'track flags'
         setMeth   = 'FALSE'
         getMeth   = 'FALSE'
         checkMeth = 'FALSE' />
       <bitfield
         name      = 'specific'
         length    = '4'
         desc      = 'track specific bits'
         setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
      </attribute>

      <attribute
        type      = 'std::vector&lt;LHCbID&gt;'
        name      = 'lhcbIDs'
        desc      = 'container of LHCbIDs'
        access    = 'PROTECTED'
        serialize = 'FALSE' />

      <attribute
        type   = 'State'
        name   = 'physicsState'
        desc   = 'State closest to the beam-line'
        access = 'PROTECTED' />

      <attribute
        type      = 'std::vector&lt;State*&gt;'
        name      = 'states'
        desc      = 'container with pointers to all the states'
        access    = 'PROTECTED'
        setMeth   = 'FALSE'
        serialize = 'FALSE' />

      <attribute
        type      = 'std::vector&lt;Measurement*&gt;'
        name      = 'measurements'
        desc      = 'container of Measurements'
        access    = 'PROTECTED'
        setMeth   = 'FALSE'
        serialize = 'FALSE' />

      <attribute
        type      = 'std::vector&lt;Node*&gt;'
        name      = 'nodes'
        desc      = 'container of Nodes'
        access    = 'PROTECTED'
        setMeth   = 'FALSE'
        serialize = 'FALSE' />

      <attribute
        type      = 'std::vector&lt;Track*&gt;'
        name      = 'ancestors'
        desc      = 'container of ancestors of the track'
        access    = 'PROTECTED'
        setMeth   = 'FALSE'
        serialize = 'FALSE' />

      <method
        type    = 'StatusCode'
        name    = 'positionAndMomentum'
        desc    = 'Retrieve the position and momentum vectors and the corresponding 6D covariance matrix (pos:1->3,mom:4-6) at the physics state'
        const   = 'TRUE'>
        <arg type = 'HepPoint3D' name='pos' />
        <arg type = 'HepVector3D' name='mom' />
        <arg type = 'HepSymMatrix' name='cov6D' />
      </method>

      <method
        type    = 'StatusCode'
        name    = 'positionAndMomentum'
        desc    = 'Retrieve the position and momentum vectors at the physics state'
        const   = 'TRUE'>
        <arg type = 'HepPoint3D' name='pos' />
        <arg type = 'HepVector3D' name='mom' />
      </method>

      <method
        type    = 'StatusCode'
        name    = 'position'
        desc    = 'Retrieve the 3D-position (+ errors) at the physics state'
        const   = 'TRUE'>
        <arg type = 'HepPoint3D' name='pos' />
        <arg type = 'HepSymMatrix' name='errPos' />
      </method>

      <method
        type    = 'StatusCode'
        name    = 'slopes'
        desc    = 'Retrieve the slopes (dx/dz,dy/dz,1) at the physics state'
        const   = 'TRUE'>
        <arg type = 'HepVector3D' name='slopes' />
        <arg type = 'HepSymMatrix' name='errSlopes' />
      </method>

      <method
        type    = 'double'
        name    = 'p'
        desc    = 'Retrieve the momentum at the physics state'
        const   = 'TRUE' />

      <method
        type    = 'double'
        name    = 'pt'
        desc    = 'Retrieve the transverse momentum at the physics state'
        const   = 'TRUE' />

      <method
        type    = 'StatusCode'
        name    = 'momentum'
        desc    = 'Retrieve the momentum vector (+ errors) at the physics state'
        const   = 'TRUE'>
        <arg type = 'HepVector3D' name='mom' />
        <arg type = 'HepSymMatrix' name='errMom' />
      </method>

      <method
        type    = 'StatusCode'
        name    = 'posMomCovariance'
        desc    = 'Retrieve the 6D covariance matrix (x,y,z,px,py,pz) at the physics state'
        const   = 'TRUE'>
        <arg type='HepSymMatrix' name='cov6D' />
      </method>

      <method
        type    = 'int'
        name    = 'charge'
        const   = 'TRUE'
        desc    = 'Retrieve the charge assigned to the track'>
        <code>
  double qP = m_physicsState.qOverP();
  return ( qP != 0. ? int(fabs(qP)/qP) : 0 );
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'chi2'
        const   = 'TRUE'
        desc    = 'Retrieve the Chi^2 of the track'>
        <code>
  return ( m_chi2PerDoF * double(m_nDoF) );
        </code>
      </method>

      <method
        type    = 'unsigned int'
        name    = 'nStates'
        const   = 'TRUE'
        desc    = 'number of states on track'>
        <code>
  return m_states.size();
        </code>
      </method>

     <method
       name    = 'addToStates'
       desc    = 'Add a State to the list of states associated to the track'>
        <arg type = 'State ' name=' state' />
        <code>
  m_states.push_back( state.clone() );
        </code>
      </method>

     <method
        name    = 'removeFromStates'
        desc    = 'Remove a State from the list of states associated to the track'
        argList = 'State* value'>
        <code>
  std::vector&lt;State*&gt;::iterator iter =
    std::remove( m_states.begin(), m_states.end(), value );
  delete *iter;
  m_states.erase( iter, m_states.end() );
        </code>
      </method>

      <method
        type    = 'State &amp;'
        name    = 'closestState'
        argList = 'double z'
        desc    = 'Retrieve the reference to the state closest to the given z-position' />

      <method
        type    = 'const State &amp;'
        name    = 'closestState'
        argList = 'double z'
        desc    = 'Retrieve the reference to the state closest to the given z-position'
        const   = 'TRUE' />

      <method
        type    = 'State &amp;'
        name    = 'closestState'
        argList = 'const HepPlane3D plane'
        desc    = 'Retrieve the reference to the state closest to the given plane'>
      </method>

      <method
        type    = 'const State &amp;'
        name    = 'closestState'
        argList = 'const HepPlane3D plane'
        desc    = 'Retrieve the reference to the state closest to the given plane'
        const   = 'TRUE'>
      </method>

      <method
        type    = 'bool'
        name    = 'hasStateAt'
        argList = 'const State::Location value'
        desc    = 'check the existence of a state at a certain predefined location. See State class.'
        const   = 'TRUE' />

      <method
        type    = 'State*'
        name    = 'stateAt'
        argList = 'const State::Location value'
        desc    = 'Retrieve the pointer to the state at a certain predefined location. See State class.' />

      <method
        type    = 'const State*'
        name    = 'stateAt'
        argList = 'const State::Location value'
        desc    = 'Retrieve the pointer to the state at a certain predefined location. See State class.'
        const   = 'TRUE' />

      <method
        type    = 'unsigned int'
        name    = 'nMeasurements'
        desc    = 'number of measurements on track'
        const   = 'TRUE'>
        <code>
  unsigned int n = m_measurements.size();
  if (n == 0) n = m_lhcbIDs.size();
  return n;
        </code>
      </method>

      <method
        name    = 'addToMeasurements'
        desc    = 'add a measurement to the list associated to the track'>
        <arg type = 'Measurement ' name='meas' />
        <code>
  m_measurements.push_back( meas.clone() );
        </code>
      </method>

      <method
        name    = 'addToNodes'
        desc    = 'add a Node to the list of nodes (nodes are own by Track)'>
        <arg type = 'Node*' name='node' />
        <code>
  m_nodes.push_back( node );
        </code>
      </method>

     <method
        name    = 'addToLhcbIDs'
        desc    = 'Add an LHCbID to the list of LHCbIDs associated to the track'
        argList = 'LHCbID value'>
        <code>
  m_lhcbIDs.push_back( value );
        </code>
      </method>

     <method
        name    = 'removeFromLhcbIDs'
        desc    = 'Remove an LHCbID from the list of LHCbIDs associated to the track'
        argList = 'LHCbID value'>
        <code>
  std::vector&lt;LHCbID&gt;::iterator iter =
    std::remove( m_lhcbIDs.begin(), m_lhcbIDs.end(), value );
  m_lhcbIDs.erase( iter, m_lhcbIDs.end() );
        </code>
      </method>

      <method
        name    = 'addToAncestors'
        desc    = 'add a track to the list of ancestors of this track'>
        <arg type = 'Track ' name='ancestor' />
        <code>
  m_ancestors.push_back( (Track*) &amp;ancestor );
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'reset'
	virtual = 'TRUE'
        desc    = 'Clear the track before re-use'>
      </method>

      <method
        type    = 'Track*'
        name    = 'clone'
        desc    = 'Clone the track'
	virtual = 'TRUE'
        const   = 'TRUE' />

      <method
        name    = 'setType'
        argList = 'std::string value'
        desc    = 'set type of the track (values in TrackKeys::Types)'
        />

      <method
        type    = 'const std::string &amp;'
        name    = 'type'
        desc    = 'return the type of the track'
        const   = 'TRUE'/> 

      <method
        name    = 'setHistory'
        argList = 'std::string value'
        desc    = 'set the name of the algorithm (ParRec) thar made the track (see in TrackKeys::History)'
        />

      <method
        type    = 'const std::string &amp;'
        name    = 'history'
        desc    = 'return the algorithm that created the track '
        const   = 'TRUE'/> 

      <method
        name    = 'setHistoryFit'
        argList = 'std::string value'
        desc    = 'set the algorithm that fitted the track (TrackKeys::HistoryFit)'
        />

      <method
        type    = 'const std::string &amp;'
        name    = 'historyFit'
        desc    = 'return the fitting algorithm '
        const   = 'TRUE'/> 
      
      <method
        name    = 'setStatus'
        argList = 'std::string value'
        desc    = 'set the status of the track (see TrackKeys::Status)'
        />

      <method
        type    = 'const std::string &amp;'
        name    = 'status'
        desc    = 'return the status of the track '
        const   = 'TRUE'/> 

      <method
        name    = 'setFlag'
        argList = 'std::string flag, bool value'
        desc    = 'Update the flag (see TrackKeys::Flags)'
        />

      <method
        type    = 'bool'
        name    = 'checkFlag'
        argList = 'std::string flag '
        desc    = 'return the status of the flag '
        const   = 'TRUE'/> 


    </class>

  </package>
</gdd>
