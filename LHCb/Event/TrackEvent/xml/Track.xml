<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE gdd SYSTEM 'gdd.dtd'>
<gdd>
  <package name='TrackEvent'>

<!-- ==================== Track class definition ==================== -->

    <class
      name        = 'Track'
      author      = 'Jose Hernando, Eduardo Rodrigues'
      desc        = 'Track is the base class for offline and online tracks.'
      id          = '10010'
      location    = 'Rec/Track/Best'
      serializers = 'FALSE'>

      <location name="Ideal"   place="Rec/Track/Ideal"/>
      <location name="Seed"    place="Rec/Track/Seed"/>
      <location name="Velo"    place="Rec/Track/Velo"/>
      <location name="Forward" place="Rec/Track/Forward"/>
      <location name="Follow"  place="Rec/Track/Follow"/>
      <location name="VeloTT"  place="Rec/Track/VeloTT"/>
      <location name="Match"   place="Rec/Track/Match"/>
      <location name="KsTrack" place="Rec/Track/KsTrack"/>

      <base name='KeyedObject&lt;int&gt;' />
      &KeyedObject;

      <import name='GaudiKernel/GaudiException' />
      <import name='Event/State' />
      <import name='Event/Measurement' />
      <import name='Event/Node' />
      <import name='Kernel/LHCbID' />
      <import name='CLHEP/Geometry/Plane3D' />

      <constructor 
	desc     = "Constructor with assigned key" 
	argList  = "int key "
	initList = "KeyedObject&lt;int&gt;( key ), m_chi2PerDoF(0.0), m_nDoF(0), m_flags(0), m_lhcbIDs(), m_states(), m_measurements(), m_nodes(), m_ancestors()">
      </constructor>

      <destructor
        desc = 'Track destructor'>
        <code>
  reset();
        </code>
      </destructor>

      <attribute
        type   = 'double'
        name   = 'chi2PerDoF'
        desc   = 'chi^2 per degree of freedom of the track'
        access = 'PROTECTED' />

      <attribute
        type   = 'int'
        name   = 'nDoF'
        desc   = 'number of degrees of freedom of the track'
        access = 'PROTECTED' />

     <attribute
       type    = 'bitfield'
       name    = 'flags'
       desc    = 'the variety of track flags'
       init    = '0'
       access  = 'PROTECTED'>
       <bitfield
         name      = 'type'
         length    = '5'
         desc      = 'track type'
         setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         name      = 'history'
         length    = '5'
         desc      = 'specifies the pattern recogn algorithm that created the track'
         setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         name      = 'historyFit'
         length    = '5'
         desc      = 'specifies the fitting algorithm the fitted the track)'
         setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         name      = 'status'
         length    = '3'
         desc      = 'status of the track'
	 setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         name      = 'flag'
         length    = '10'
         desc      = 'track flags'
         setMeth   = 'FALSE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         name      = 'specific'
         length    = '4'
         desc      = 'track specific bits'
         setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
      </attribute>

      <attribute
        type      = 'std::vector&lt;LHCbID&gt;'
        name      = 'lhcbIDs'
        desc      = 'container of LHCbIDs'
        access    = 'PROTECTED'
        serialize = 'FALSE' />

      <attribute
        type      = 'std::vector&lt;State*&gt;'
        name      = 'states'
        desc      = 'container with pointers to all the states'
        access    = 'PROTECTED'
        setMeth   = 'FALSE'
        serialize = 'FALSE' />

      <attribute
        type      = 'std::vector&lt;Measurement*&gt;'
        name      = 'measurements'
        desc      = 'container of Measurements'
        access    = 'PROTECTED'
        setMeth   = 'FALSE'
        serialize = 'FALSE' />

      <attribute
        type      = 'std::vector&lt;Node*&gt;'
        name      = 'nodes'
        desc      = 'container of Nodes'
        access    = 'PROTECTED'
        setMeth   = 'FALSE'
        serialize = 'FALSE' />

      <relation
        type      = "Track"
        name      = "ancestors"
        access    = 'PROTECTED'
        setMeth   = 'FALSE'
        desc      = "ancestor tracks that created this one" 
        multiplicity = "N" 
        serialize = 'FALSE' />

      <method
        type    = 'void'
        name    = 'positionAndMomentum'
        desc    = 'Retrieve the position and momentum vectors and the corresponding 6D covariance matrix (pos:1->3,mom:4-6) at the first state'
        const   = 'TRUE'>
        <arg type = 'HepPoint3D' name='pos' />
        <arg type = 'HepVector3D' name='mom' />
        <arg type = 'HepSymMatrix' name='cov6D' />
      </method>

      <method
        type    = 'void'
        name    = 'positionAndMomentum'
        desc    = 'Retrieve the position and momentum vectors at the first state'
        const   = 'TRUE'>
        <arg type = 'HepPoint3D' name='pos' />
        <arg type = 'HepVector3D' name='mom' />
      </method>

      <method
        type    = 'HepPoint3D'
        name    = 'position'
        desc    = 'Retrieve the 3D-position vector at the first state'
        const   = 'TRUE'>
        <code>
   return firstState().position();
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'position'
        desc    = 'Retrieve the 3D-position (+ errors) at the first state'
        const   = 'TRUE'>
        <arg type = 'HepPoint3D' name='pos' />
        <arg type = 'HepSymMatrix' name='errPos' />
      </method>

    <method
        type    = 'HepVector3D'
        name    = 'slopes'
        const   = 'TRUE'
        desc    = 'Retrieve the slopes (Tx=dx/dz,Ty=dy/dz,1.) and errors at the first state'>
        <code>
   return firstState().slopes();
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'slopes'
        desc    = 'Retrieve the slopes (dx/dz,dy/dz,1) at the first state'
        const   = 'TRUE'>
        <arg type = 'HepVector3D' name='slopes' />
        <arg type = 'HepSymMatrix' name='errSlopes' />
      </method>

      <method
        type    = 'HepVector3D'
        name    = 'momentum'
        const   = 'TRUE'
        desc    = 'Retrieve the momentum vector at the first state'>
        <code>
   return firstState().momentum();
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'p'
        desc    = 'Retrieve the momentum at the first state'
        const   = 'TRUE' />

      <method
        type    = 'double'
        name    = 'pt'
        desc    = 'Retrieve the transverse momentum at the first state'
        const   = 'TRUE' />

      <method
        type    = 'void'
        name    = 'momentum'
        desc    = 'Retrieve the momentum vector (+ errors) at the first state'
        const   = 'TRUE'>
        <arg type = 'HepVector3D' name='mom' />
        <arg type = 'HepSymMatrix' name='errMom' />
      </method>

      <method
        type    = 'void'
        name    = 'posMomCovariance'
        desc    = 'Retrieve the 6D covariance matrix (x,y,z,px,py,pz) at the first state'
        const   = 'TRUE'>
        <arg type='HepSymMatrix' name='cov6D' />
      </method>

      <method
        type    = 'State &amp;'
        name    = 'firstState'
        desc    = 'Retrieve the first state on the track'
        const   = 'TRUE'>
        <code>
  // check at least the &quot;first state&quot; exists
  if ( m_states.empty() )
    throw GaudiException( &quot;first (first) state not defined!&quot;,
                          &quot;Track.h&quot;,
                          StatusCode::FAILURE );
  return *m_states[0];
        </code>
      </method>

      <method
        type    = 'int'
        name    = 'charge'
        const   = 'TRUE'
        desc    = 'Retrieve the charge assigned to the track'>
        <code>
  double qP = firstState().qOverP();
  return ( qP != 0. ? int(fabs(qP)/qP) : 0 );
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'chi2'
        const   = 'TRUE'
        desc    = 'Retrieve the Chi^2 of the track (fit)'>
        <code>
  return ( m_chi2PerDoF * double(m_nDoF) );
        </code>
      </method>

      <method
        type    = 'unsigned int'
        name    = 'nStates'
        const   = 'TRUE'
        desc    = 'Retrieve the number of states on the track'>
        <code>
  return m_states.size();
        </code>
      </method>
      
    <method
        name    = 'addToStates'
       desc    = 'Add a State to the list of states associated to the track'>
        <arg type = 'const State' name=' state' />
      </method>

     <method
        name    = 'removeFromStates'
        desc    = 'Remove a State from the list of states associated to the track'
        argList = 'State* value'>
      </method>

      <method
        type    = 'State &amp;'
        name    = 'closestState'
        argList = 'double z'
        desc    = 'Retrieve the reference to the state closest to the given z-position' />

      <method
        type    = 'const State &amp;'
        name    = 'closestState'
        argList = 'double z'
        desc    = 'Retrieve the reference to the state closest to the given z-position'
        const   = 'TRUE' />

      <method
        type    = 'State &amp;'
        name    = 'closestState'
        argList = 'const HepPlane3D plane'
        desc    = 'Retrieve the reference to the state closest to the given plane'>
      </method>

      <method
        type    = 'const State &amp;'
        name    = 'closestState'
        argList = 'const HepPlane3D plane'
        desc    = 'Retrieve the reference to the state closest to the given plane'
        const   = 'TRUE'>
      </method>

      <method
        type    = 'bool'
        name    = 'hasStateAt'
        argList = 'unsigned int location'
        desc    = 'Check the existence of a state at a certain predefined location (see the Location enum in StateKeys.h)'
        const   = 'TRUE' />

      <method
        type    = 'State &amp;'
        name    = 'stateAt'
        argList = 'unsigned int location'
        desc    = 'Retrieve the state at a certain predefined location (see the Location enum in StateKeys.h)' />

      <method
        type    = 'const State &amp;'
        name    = 'stateAt'
        argList = 'unsigned int location'
        desc    = 'Retrieve the const state at a certain predefined location (see the Location enum in StateKeys.h)'
        const   = 'TRUE' />

      <method
        type    = 'unsigned int'
        name    = 'nMeasurements'
        desc    = 'Retrieve the number of measurements on the track'
        const   = 'TRUE'>
        <code>
  unsigned int n = m_measurements.size();
  if (n == 0) n = m_lhcbIDs.size();
  return n;
        </code>
      </method>

<!--

   <method template="class Pred" 
      type="unsigned int"  
      name="nMeasurements" 
      const="TRUE" 
      desc="return the number of measurements fulfilling a condition/predicate on LHCbIDs">
      <arg type="Pred" name="pred"/>
      <code>  
   return std::count_if(m_meas.begin(),m_meas.end(),pred); 
      </code>
    </method>

-->

      <method
        name    = 'addToMeasurements'
        desc    = 'Add a measurement to the list associated to the track'>
        <arg type = 'const Measurement' name='meas' />
      </method>

     <method
        name    = 'removeFromMeasurements'
        desc    = 'Remove a measurement from the list of measurements associated to the track'
        argList = 'Measurement* value'>
      </method>

      <method
        name    = 'addToNodes'
        desc    = 'Add a Node to the list of nodes (note: Track will take the ownership of this pointer!!)'>
        <arg type = 'Node*' name='node' />
        <code>
  m_nodes.push_back( node );
        </code>
      </method>

     <method
        name    = 'removeFromNodes'
        desc    = 'Remove a Node from the list of nodes associated to the track'
        argList = 'Node* value'>
      </method>

     <method
        name    = 'addToLhcbIDs'
        desc    = 'Add an LHCbID to the list of LHCbIDs associated to the track'
        argList = 'LHCbID value'>
        <code>
  m_lhcbIDs.push_back( value );
        </code>
      </method>

     <method
        name    = 'removeFromLhcbIDs'
        desc    = 'Remove an LHCbID from the list of LHCbIDs associated to the track'
        argList = 'LHCbID value'>
        <code>
  std::vector&lt;LHCbID&gt;::iterator iter =
    std::remove( m_lhcbIDs.begin(), m_lhcbIDs.end(), value );
  m_lhcbIDs.erase( iter, m_lhcbIDs.end() );
        </code>
      </method>

      <method
        name    = 'addToAncestors'
        desc    = 'Add a track to the list of ancestors of this track'>
        <arg type = 'const Track ' name='ancestor' />
        <code>
  m_ancestors.push_back( (Track*) &amp;ancestor );
        </code>
      </method>

<!--
    <method
        name    = 'removeFromAncestors'
        desc    = 'Remove an ancestor track from the list of ancestors associated to the track'
        argList = 'Track&amp; value'>
        <code>
  SmartRefVector&lt;Track&gt;::iterator iter =
    std::remove( m_ancestors.begin(), m_ancestors.end(), &amp;value );
  m_ancestors.erase( iter, m_ancestors.end() );
        </code>
      </method>
-->

      <method
        type    = 'void'
        name    = 'reset'
	virtual = 'TRUE'
        desc    = 'Clear the track before re-use'>
      </method>

      <method
        type    = 'Track*'
        name    = 'cloneWithKey'
        desc    = 'Clone the track keeping the key (you take ownership of the pointer)'
	virtual = 'TRUE'
        const   = 'TRUE' />

      <method
        type    = 'Track*'
        name    = 'clone'
        desc    = 'Clone the track (you take ownership of the pointer)'
	virtual = 'TRUE'
        const   = 'TRUE' />

      <method
        type    = 'bool'
        name    = 'checkType'
        argList = 'unsigned int value'
        desc    = 'Check the type of the track (see the Types enum in TrackKeys.h)'
        const   = 'TRUE'>
        <code>
  return type() == value;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'checkHistory'
        argList = 'unsigned int value'
        desc    = 'Check the history of the track (see the History enum in TrackKeys.h)'
        const   = 'TRUE'>
        <code>
  return history() == value;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'checkHistoryFit'
        argList = 'unsigned int value'
        desc    = 'Check the fit history of the track (see the HistoryFit enum in TrackKeys.h)'
        const   = 'TRUE'>
        <code>
  return historyFit() == value;
        </code>
      </method>

      <method
        name    = 'setFlag'
        argList = 'unsigned int flag, bool ok'
        desc    = 'Update the flag (see the Flags enum in TrackKeys.h)'>
        <code>
  unsigned int val = (((unsigned int) flag) &lt;&lt; flagBits) &amp; flagMask;
  if (ok) m_flags |= val;
  else m_flags &amp;= ~val;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'checkFlag'
        argList = 'unsigned int flag'
        desc    = 'Check the status of the flag (see the Flags enum in TrackKeys.h)'
        const   = 'TRUE'>
        <code>
  unsigned int val = ((unsigned int) flag &lt;&lt; flagBits);  
  bool ok = (0 != ( m_flags &amp; flagMask &amp; val ));
  return ok;
        </code>
      </method> 

    </class>

  </package>
</gdd>
