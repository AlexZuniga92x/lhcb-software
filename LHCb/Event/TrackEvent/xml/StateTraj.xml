<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE gdd SYSTEM 'gdd.dtd'>
<gdd>
  <package name='TrackEvent'>

<!-- ==================== StateTraj class definition ==================== -->

    <class
      name             = 'StateTraj'
      author           = 'Edwin Bos, Jeroen van Tilburg, Eduardo Rodrigues'
      desc             = 'Trajectory created from a State.'
      id               = '10032'
      location         = 'Rec/Track/Traj/StateTraj'
      serializers      = 'FALSE'>

      <base name='Trajectory' />

      <import name='Event/State' />
      <import name='Event/Trajectory' />

      <constructor
        desc = 'Constructor from a State and the magnetic field at the State position'>
        <arg type='const State' name='state' />
        <arg type='const HepVector3D' name='bField' />
        <code>
  m_pos        = state.position();
  m_unitSlopes = state.slopes().unit();
  m_qOverP     = state.qOverP();
  m_bField     = bField;
        </code>
      </constructor>

      <attribute
        type    = 'HepPoint3D'
        name    = 'pos'
        desc    = 'the position of the State'
	setMeth = 'FALSE'
	getMeth = 'FALSE'
        access  = 'PROTECTED' />

      <attribute
        type    = 'HepVector3D'
        name    = 'unitSlopes'
        desc    = 'the slopes of the State (normalized)'
	setMeth = 'FALSE'
	getMeth = 'FALSE'
        access  = 'PROTECTED' />

     <attribute
        type    = 'double'
        name    = 'qOverP'
        desc    = 'the charge-over-momentum Q/P of the State'
	setMeth = 'FALSE'
	getMeth = 'FALSE'
        access  = 'PROTECTED' />

      <attribute
        type    = 'HepVector3D'
        name    = 'bField'
        desc    = 'the magnetic field vector at the State position'
	setMeth = 'FALSE'
	getMeth = 'FALSE'
        access  = 'PROTECTED' />

      <method
        name  = 'expansion'
        desc  = 'Create a parabolic approximation to the Trajectory'
        const = 'TRUE'>
        <arg type= 'double' name='arclength' inout='BOTH' />
        <arg type='HepPoint3D' name='p' />
        <arg type='HepVector3D' name='dp' />
        <arg type='HepVector3D' name='ddp' />
        <code>
  // TODO: check, clean-up, check units!, ...
  double kappa = 0.3 * GeV / ( c_light * tesla * meter );
  dp  = m_unitSlopes;
  ddp = 0.3 * m_qOverP * ( m_unitSlopes.cross(m_bField) );
  p   = m_pos + arclength * ( m_unitSlopes + 0.5 * arclength * ddp );
	</code>
      </method>

      <method
        type    = 'const HepMatrix'
        name    = 'derivative'
        desc    = 'Retrieve the derivative of the parabolic approximation to the Trajectory'
        const   = 'TRUE'
        virtual = 'TRUE'>
        <arg type = 'const double' name='arclength' />
        <code>
  // TODO: check, clean-up, check units!, ...
  double kappa = 0.3 * GeV / ( c_light * tesla * meter );
  double vx    = m_unitSlopes[0];
  double vy    = m_unitSlopes[1];
  double vz    = m_unitSlopes[2];
  double svz   = arclength * vz;
  double vxyz  = vx * vy * vz;
  double arcvx = 1.0 - vx * vx;
  double arcvy = 1.0 - vy * vy;
  double C     = 0.5 * arclength * arclength * 0.3 * m_qOverP;
  double cvz   = C * vz;
  HepVector3D crossB = m_unitSlopes.cross(m_bField);

  HepMatrix deriv(3,5,0);

  deriv[0][0] = 1.0;
  deriv[0][2] = svz * arcvx - cvz * vx * crossB[0];
  deriv[0][3] = -arclength * vxyz
                + cvz * ( vy * vz * m_bField[1] + arcvy * m_bField[2] );
  deriv[0][4] = C * crossB[0];
  deriv[1][1] = 1.0;
  deriv[1][2] = -arclength * vxyz
                - cvz * ( vx * vz * m_bField[0] + arcvx * m_bField[2] );
  deriv[1][3] = svz * arcvy - cvz * vy * crossB[1];
  deriv[1][4] = C * crossB[1];
  deriv[2][2] = -vx * vz * svz
                - C * ( vxyz * m_bField[0] - vz * arcvx * m_bField[1] );
  deriv[2][3] = -vy * vz * svz
                - C * ( vxyz * m_bField[1] + vz * arcvy * m_bField[0] );
  deriv[2][4] = C * crossB[2];

  return deriv;
        </code>
      </method>

    </class>

  </package>
</gdd>
