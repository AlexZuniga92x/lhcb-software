! $Id: release.notes,v 1.16 2005-05-13 11:22:30 ibelyaev Exp $ 
! -----------------------------------------------------------------------------
! CVS tag $Name: not supported by cvs2svn $ 
! -----------------------------------------------------------------------------
! Package     : Kernel/Relations
! Responsible : Vanya BELYAEV   Ivan.Belyaev@lapp.in2p3.fr 
! Purpose     : General purposes templated relations between classes
!-----------------------------------------------------------------------------

! 2005-05-13 - Vanya BELYAEV   
 - Relations/Pointer.h
   pointer-wrapper class to make a realions to RAW poiter objects
 - Relations/ObjectTypeTraitsStripped.h
   make usage of Relations::Pointer
   
   THIS MODIFICATION IS BACKWARD COMPATIBLE.
   Indeed allexisting relations are not affected at all.
   I need it to make a relations with HepMC::GenParticle* 

 - cmt/requirements
   version increment to v2r5 

! ====================== Relations v2r4 2005-03-14 ============================
! 2005-03-14 - Marco Cattaneo
 - Small fixes to doxygen comments, to suppress warnings

! 2005-02-16 - Vanya BELYAEV
 - few minor fixes to enable the generation of "standard" 
   LCG dictionaries using "lcgdict" tool 

 - more uniform treatment of constructors.
    now each table-like class has: 
      a) default constructor with optional "reserve" argument 
      b) constructor from *ANY* "direct"  interface 
      c) constructor from *ANY* "inverse" interface 
        (useful for "on-flight" inversion of relation tables)
      d) copy constructor

 - add more optimization   into constructors 
      extensive usage of i_push/i_sort in the *SAFE* environment  

 - cmt/requirements 
   version increment to v2r4 

! 2005-02-16 - Vanya Belyaev
 - src/AssociatorBase.cpp
  tiny fix to remove WARNING messages for RIGHT choice of properties

! ====================== Relations v2r3 2005-02-08 ============================
! 2005-02-08 - Vanya BELYAEV

 - Relations/RealtionsDict.h
     modify a  "field-names"  (visible e.g. for Python)
       now "Entry" has 2 "visible" fields :
         "_to" ,"_from" for ordinary relations 
       and 3 visible fields :  
         "_to" , "_from" and "_weight" for relations with weight 

    DICTIONARIES (AND DATA) ARE NOT COMPATIBLE ANYMORE !!! 

! ====================== Relations v2r2 2005-01-27 ============================
! 2005-01-26 - Vanya BELYAEV
 
  - few modification to improve CPU performance.
  
   If one compare the CPU performance for "filling" of Relation 
   table and Linker object, Linker seems to be MUCH more efficient 
   for creation. The CPU penalty comes from inservtion of 
   relation entries into large vector. It is well-knbown problem 
   that associative vector (which is the  internal implementation 
   of Relation table) is slower for filling, but usually faster 
   for reading/using than e.g. std::map or other associative 
   technique. 
   
   To solve the problem the "power input" is enabled now:
   e.g. instead of "safe" and robust code

   for( ... )
     {  
     for( ... ) 
       {
       table->relate( object1 , object2 ) ;
       }
    }
  
   Now one can write more efficient:

   for( ... )
     {  
     for( ... ) 
       {
       table->i_push( object1 , object2 ) ;
       }
    }
    table->i_sort() ; // NB!!! call for i_sort() is mandatory

   This code is more efficient, but less safe.
   E.g. there is no control for duplicated entries, 
  
   New method i_push is ENOURMOUSLY fast, 
   for realistc case it has the perfromace 5 times better that "Linker".
   But, after the usage of i_push, the relatioin tabel stays in invald state and 
   need to be manually set into valid state. It is doen using i_sort() 
   method which is CPU-consuming.
   
   The overall CPU performance of i_push/i_sort is approximately 
   2 times slower than filling of  Linker object. 

   The special new package Tests/RelationTest is developed to measure 
   correctly the relative performace of Relations tables and Linker objects.
   Indeed it is not an easy task to measure only the performance of relations
   and factorize everything else. 
  
   The package is is CVS and it contains realistic example whith 
     CaloCluster->MCParticle weighted relations/links. 
 
   CPU Performance in some arbirtary units: 
   ----------------------------------------
  
   ----------------------------------------------------------------------------------
     Technique                             Filling        Using/Looping/Extraction
   ----------------------------------------------------------------------------------
      1) Linker object                          419                261  
   ----------------------------------------------------------------------------------
      2) non-optmized Relations tables  
         with random input data        
          (using Table::relate method)          16478           
   ----------------------------------------------------------------------------------
      3) non-optimized Relation tables
         with sorted input data                 817
          (using Table::relate method)  
   ----------------------------------------------------------------------------------
      4) non-optmized Relations tables  
         with random input data                 16349   
          (using Table::i_relate method)          
   ----------------------------------------------------------------------------------
      5) optmized Relations tables  
          with random input data        
          (using Table::i_push/i_sort methods)  693                47 
   ----------------------------------------------------------------------------------

   For Using/Looping/Extarction there  (2),(3),(4) and (5) are the same.
   All numbers were measured in ONE job using 1000 events and exising 
   input data for CaloCluster->MCParticle MC-associations.
   The job has been run few times to prove the stability of measurement. 
 
   As a bottom-line I'd like to note that this version of Kernel/Relations 
   package with "power input" option result in 1.65 worser performance for 
   filling of the relation table relative to Linker technique, 
   but it has 5.5 better CPU performace for extration of relations.
   
   I could be wrong, but probably the idiom "one time write - many times read"
   is valid for *almost* any relations/links  (at least it is true for all 
   MC-associations).

   
 - cmt/requirements 
    version increment to v2r2 

! ====================== Relations v2r1 2004-12-09 ============================
! 2004-12-08 - Vanya BELYAEV

 - remove few obsolete tricks to unify GCC and Visual C++ 
   these tricks were introduced for Visual C++ 6.0.
   The main reason - the absence pf partical template specializations. 
   Since the support of partial template specializations in Visual C++ 7.1 
   is on the desired level, all onsolete lines can be eliminated.

 - Relations/Less.h
 - Relations/Reserve.h
 - Relations/ObjectTypeTraitsStripped.h
 - Relations/TypeApplyAux.h
 - Relations/TypeSelect.h

      remove WIN32 specific clause 

 - Relations/TypeSelect.Aux.h 
 - Relations/TypeSerializers.h 
     
      remove obsolete file 

 - cmt/requirements 
     
      version increment to v2r1 

  From *NOW*  the package is formally "platform-independent" 

   Platform dependency now comes only:    

    - indirectly through usage of 
      boost::is_convertible structure in Relations/TypeConversion.h file 
    - through #pragma directive in Relations/PragmaWarning.h file 


!====================== Relations v2r0 2004-11-22 ============================
! 2004-11-19 - Vanya BELYAEV
 - put few *SERIOUS* modification into Associators

  
  The purpose is to eliminate the algorithm 
  handling by associators and to allow new 
  Data-On-Demand service to take care about 
  handling of algorithms. 

  To allow a management of relational tables by Data-On-Demand Service
  one needs to achieve the proper configuration of the Service: 

     Assuming that the relation table at location "MyTableLocation", 
              to be created with some algorithm of type "MyAlgorithmType" 
              with algorithm instance name "MyAlgInstanceName".

  The corresponding configuration lines are:  

  DataOnDemandSvc.Algorithms 
     += { "DATA='MyTableLocation' , TYPE='MyAlgorithmType/MyAlgInstanceName'" } ;

  e.g. for concrete examples with MC association for CaloClusters:

    DataOnDemandSvc.Algorithms 
      += { "DATA='/Event/Rec/Relations/EcalClusters2MCParticles' , TYPE='CaloClustersMCTruth5Alg/CCs2MCPs'" } ;

  With such configuration one *DOES NOT* need the associators at all, 
  the relation table can be retrieved and use inside the 
  algorithms and tools "locally", e.g. 
  
      typedef IRelationWeighted<CaloCluster,MCPrticle,float ITable ;
      const ITable* table = get<ITable>( "Rec/Relations/EcalClusters2MCParticles" );

      const CaloCluster* cluster = ... ;
      // get all related MCParticles
      ITable::Range mcps = table->relations( cluster );
      // ordinary loop over all related objects
      for ( ITable::iterator it = mcps.begin() ; mcps.end() != it ; ++it )
      {
        const MCParticle* mcp    = it->to() ;
        const double      weight = it->weight() ;
      };
   
  The associators are still *in the game*, if someone wants to use them.
  *BUT* from now the usage of properties "AlgorithmType" and "AlgorithmName"
  becomes obsolete and deprecates. Being used these properties will trigger 
  the WARNING messages , e.g. 

  --------------------------------
      ToolSvc.CCs2MCPs    WARNING  Obsolete properties 'AlgorithmName' and 'AlgorithmType'. Use new 'Data-On-Demand' Service: 
    
               DataOnDemandSvc.Algorithms += { "DATA='/Event/Rec/Relations/EcalClusters2MCParticles' , TYPE='CaloClustersMCTruth5Alg/CCs2MCPs'" } ;

  --------------------------------
   
   If one gets such message, one needs to *ELIMINATE* the lines 

     ToolSvc.CCs2MCPs.AlgorithmType = "CaloClustersMCTruth5Alg" ;
     ToolSvc.CCs2MCPs.AlgorithmName = "CCs2MCPs" ;

  from *.opts files and to use the line, proposed by Associators itself 
  instead of such lines.

  for general case, the lines: 

    The.Full.Name.Of.My.Associator.Location      = "MyTableLocation"   ;
    The.Full.Name.Of.My.Associator.AlgorithmType = "MyAlgorithmType"   ;
    The.Full.Name.Of.My.Associator.AlgorithmName = "MyAlgInstanceName" ;
 
  need to be substituted by lines:

    The.Full.Name.Of.My.Associator.Location      = "MyTableLocation"   ; // THE LINE 
    DataOnDemandSvc.Algorithms 
         += { "DATA='MyTableLocation' , TYPE='MyAlgorithmType/MyAlgInstanceName'" } ;
	
  Important Notes:
     - "MyTableLocation" is a FULL location of object in TES, including "/Event/"
     - do not forget the "The.Full.Name.Of.My.Associator" is really *FULL" name
       and includes the parent name, e.g. "ToolSvc" for "PUBLIC" associators


   Let me stress here once more that, the line, marked by "//THE LINE" is needed 
   only if one still uses "Associators", for direct usage of relation table 
   it is not needed at all.

        I *THINK* (this is my personal preference) that it is worth 
        to declare the explicit usage of "Associators" as 
        DEPRECATED/OBSOLETE feature and I'd like to  recommend for everybody 
        the direct manipulations with relation tables.

   For further details see in lhcb-core-soft@cern.ch archive the mail 
   titled "Relations and DataOnDemandSvc" from October 26th 
     
 - cmt/requirements
 
     increment the MAJOR version 

!====================== Relations v1r0 2004-07-19 ============================
! 2004-07-19 - Marco Cattaneo
 - Use GaudiAlg instead of GaudiTools (classes moved to GaudiAlg in Gaudi v15)
 - Add Relations/RelationsDict.h (previously in GaudiObjDesc)

! 2004-07-19 - Marco Cattaneo
 - First import as an independent package, previously a subpackage of
   LHCbKernel (until version v4r6)

! -----------------------------------------------------------------------------
! The END 
! -----------------------------------------------------------------------------
