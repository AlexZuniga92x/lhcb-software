\documentclass{lhcbnote}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{epsfig}
\title{Histogram DB for Online Monitoring -- User's Manual}
\doctyp{}
\dociss{2}
\docrev{4}
\doccre{March 21, 2007}
\docmod{\today}
\docref{}
\author{G.~Graziani}

\begin{document}
\maketitle


\section{DB design}
The requirements and use cases of an Histogram Database for Online
Monitoring in the context of a common Histogramming Framework~\cite{genhisto}
have been defined in ~\cite{dbdesign}.

The present design of DB tables is shown in figure \ref{DBschema}


\begin{figure}[htb]
\centerline{\epsfig{figure=DBschema.eps,width=\textwidth}}
\caption{Scheme of DB tables. }
\label{DBschema}
\end{figure}

\subsection{Definition of Histograms}
Histograms are uniquely identified by the expression:\\
{\it Taskname}/{\it Algorithmname}/{\it HistogramName}\\
The histogram name can contain a subname:
{\it HistogramName} = {\it HistogramSetName}\_\${\it Subname} \\
Histograms differing only by {\it Subname} are part of the same
Histogram set. These should be histograms that have identical binning,
e.g. containing the same distribution for different channels of a detector.

For easier reference, an internal unique identifier is created for
each histogram, in the form\\
{\it HID} = {\it HSID}/{\it IHS}\\
where {\it HSID} is an integer number identifying the histogram set,
and {\it IHS} is a sequence number (starting from 1) to identify histograms in
the same set.

\subsubsection{Properties of TASK} 
\begin{description}
\item{TaskName} (string of max length 100) \\
unique task identifier
\item{RunOnPhysics, RunOnCalib, RunOnEmpty} (boolean)\\
specify for which type of data task is running 
\item{Subsys1, Subsys2, Subsys3} (string of length 10)\\
up to 3 subdetector/subsystem can be associated to task. 
\item{Reference}  (string of length 100)\\
link to the location of reference histograms for this task
\item{SaveFrequency} \\ saving frequency for the corresponding saveset
\end{description} 

\subsubsection{Properties of HISTOGRAMSET}
\begin{description}
\item{HSID} (integer)
\item{NHS} (integer)\\
number of histograms in set
\item{Task} (valid TaskName) 
\item{Algorithm} (string of max length 100) 
\item{HistogramSetName} (string of max length 200) 
\item{Type} \\
'H1D', 'H2D' for normal histograms, 'P1D', 'P2D' for profile
histograms, 'CNT' for counters
\item{Nanalysis} (integer)\\
number of analysis to be performed on set
\item{Description} (string of max length 4000) 
\item{Documentation} (string of max length 200)\\
link to a more extensive documentation
\item{HSDisplay} (valid DOID)\\
identifier of display option set associated to Histogram set 
\end{description}

\subsubsection{Properties of HISTOGRAM}
\begin{description}
\item{HID} (string of max length 12)\\
{\it HSID}/{\it IHS}
\item{Subname} (string of max length 50)
\item{DIMServiceName} (string of max length 130)\\
Name of the DIM service that is currently publishing the histogram 
\item{IsAnalysisHist} (boolean)\\
true if histogram is produced at analysis level
\item{CreationTime} (timestamp)\\
recording the first time the histogram is seen
\item{ObsoletenessTime} (timestamp)\\
can be set by hand if histogram is not produced any more 
\item{Display} (valid DOID)
identifier of display option set associated to Histogram 
\end{description}

\subsection{Definition of Pages and Display Options}
Pages and Page Folders are uniquely identified by their name. Page
folders can have a hierarchical structure, for example:\\
{\it Folder1}\\
{\it Folder1/Folder2}\\
{\it Folder1/Folder2/Folder3}\\
Pages are associated to a list of valid histograms through the SHOWHISTO
table, containing the layout of each histogram on the page.

As shown in figure \ref{DBschema}, a set of display options can
be defined for:
\begin{itemize}
\item an histogram on a given page
\item an histogram
\item an histogram set
\end{itemize}
so that the most specific available set is used, but one can use the
same default for, say, the 2000 histograms of a certain set. 

\subsubsection{Properties of DISPLAYOPTIONS}\label{dispopts}
\begin{description}
\item{DOID} (integer)\\
unique identifier 
\item{LABEL\_X}  (string of max length 50)
\item{LABEL\_Y}  (string of max length 50)
\item{LABEL\_Z}  (string of max length 50)
\item{YMIN} (float)
\item{YMAX} (float)
\item{STATS} (int)
\item{FILLSTYLE} (int)
\item{FILLCOLOR} (int)
\item{LINESTYLE} (int)
\item{LINECOLOR} (int)
\item{LINEWIDTH} (int)
\item{DRAWOPTS}  (string of max length 50)
\end{description}
\subsubsection{Properties of PAGEFOLDER}
\begin{description}
\item{PageFolderName} (string of max length 30)\\
unique page folder identifier
\item{Parent} (string of max length 30)\\
Folder containing this folder (NULL for ``root'' folders)
\end{description}

\subsubsection{Properties of PAGE}
\begin{description}
\item{PageName} (string of max length 50) \\
unique page identifier
\item{Folder} (valid PageFolderName) 
\item{Nhisto} (integer) \\
number of histograms on page
\item{PageDoc} (string of max length 100)\\
short page description
\end{description}

\subsubsection{Properties of SHOWHISTO}
The unique identifier is the combination (Page,Histo,Instance)
\begin{description}
\item{Page} (valid PageName)
\item{Histo} (valid HID)
\item{Instance} (int)\\
sequence number (starting from 1) to distinguish different instances
of the same histogram on the same page
\item{Cx, Cy, Sx, Sy} (float numbers from 0 to 1)\\
coordinates of the histogram pad on the page: Cx and Cy define the
position of the top left corner, Sx and Sy the size, relatively to the
window size
\item{Sdisplay} (valid DOID)\\
identifier of display option set associated to this Histogram on this Page
\end{description}

\subsection{Definition of Automatic Analysis}
The ALGORITHM table contains the definition of the algorithms
available for analysis. They can be used to create new histograms at
analysis level (these will be called ``Analysis Histograms'' and are
defined by the HCREATOR table), or to perform automatic checks,
defined in the ANALYSIS table. Analyses are properties of an histogram
set, though their parameters can be specified for each histogram in
the ANASETTINGS table.

\subsubsection{Properties of ALGORITHM}
\begin{description}
\item{AlgorithmName} (string of max length 30)\\
unique algorithm identifier
\item{AlgType} \\
'HCREATOR' or 'CHECK'
\item{Ninput} (integer)\\
number of input histograms (for 'HCREATOR' algorithms)
\item{Npars} (integer)\\
number of parameters
\item{AlgPars} (array(any length) of string of max length 15)\\
parameter names
\item{HCTYPE}\\
for 'HCREATOR' algorithms, type of histogram generated by this algorithm 
\item{AlgDoc} (string of max length 1000)
documentation

\end{description}

\subsubsection{Properties of ANALYSIS}
\begin{description}
\item{AID} (integer)\\
unique analysis identifier (allowing to assign the same algorithm more
than once to the same histogram)
\item{HSET}  (valid HSID)
\item{Algorithm}  (valid AlgorithmName)
\end{description}

\subsubsection{Properties of ANASETTINGS}
\begin{description}
\item{AnaID} (valid AID)
\item{Histogram}  (valid HID)
\item{Mask} (boolean)\\
allow to mask the analysis for a single histogram
\item{Warnings, Alarms} (arrays(Npars) of floats)\\
2 sets of threshold levels
\end{description}

\subsubsection{Properties of HCREATOR}
when a HCREATOR entry is defined, the corresponding histogram is
created with Task='ANALYSIS' and Algorithm= the name of the analysis algorithm
\begin{description}
\item{HCID} (valid HID)
\item{Algorithm} (valid AlgorithmName)
\item{Sourceh} (arrays(8) of string of max length 12)\\
list of input histograms
\item{SourceHSet} (valid HSID)\\
input histogram set (if required by the algorithm)
\item{HCPARS} (arrays(Npars) of floats)\\
set of needed parameters 
\end{description}

\section{DB implementation}
A first prototype of the DB has been implemented under Oracle on the
CERN Oracle server and is available for tests.
	
In June 2007 the DB has migrated to the LHCb Oracle server at point8,
that can be seen from the cern network only.

The connection string is \\
\centerline{$<$account$>$/$<$password$>$@lbora01:1528/HISTOGRAMDB}
where $<$account$>$ is \\
{HIST\_READER}   (read--only, password=''welcome'') or \\
{HIST\_WRITER} 

The DB can be accessed through a C++ API or interactively through a
Web interface written in PHP. In order to minimize client load and
network traffic, and ease the maintenance of interface code, both
interfaces  are based on a set of common PL/SQL procedures that are
precompiled on the Oracle server.

\section{Web interface}

It is available for test at the address\\
{\it https://webafs3.cern.ch/ggrazian/lhcb/OnlineHistDB/index.php}

while the production address (visible only from the CERN network)
will be \\
\centerline{ \it http://lbweb01:8090/histogramdb}  

It is intended to be the most suitable tool to browse available
histograms, edit the display options and the automatic analysis, including
the definition of histograms to be produced at analysis level.

Presently, it is also possible to edit the viewer page configurations, though
a graphical editor in the presenter application will likely be the
most suitable tool for that task.

It is also suited for uploading {\bf reference histograms}. Users should
provide ROOT files containing all the reference histograms of a given
task, that could be simply a saveset files. \\
These can be uploaded through the ``Task Editor'' link at \\
{ \it http://lbweb01:8090/histogramdb} \\
A tool is provided to check the file content for missing or unknown histograms.
According to the convention of \cite{dbdesign}, files are saved as \\
$<$Reference\_root$>$/$<$task name$>$/$<$datatype$>$\_$<$startrun$>$.\\
where the fields $<$datatype$>$ and $<$startrun$>$ allow to define
different reference for different run condition and time range. 

\section{C++ Interface}

The interface is available as a link library that can be compiled from
the package \\
{\it Online/OnlineHistDB} \\
in the LHCb code repository.

The C++ API allows to perform practically any operation on the DB .
%but the deletion of objects, that is reserved to the DB administrator.

You can add entries to the DB through the methods beginning with {\it
declare}, that create the specified entry if not existing, or 
update its fields otherwise. If you use these methods, running the
same code twice is equivalent to run it once.


\subsection{OnlineHistDB class}
Each instantiation of this class opens a transaction with the DB
server. Its methods allow to define new DB entries (histograms,
tasks, subsystems, pages, algorithms) and query the DB content. \\
Histograms, tasks and pages can be manipulated using the corresponding
classes described in the next sections. For each DB entry, an object can be
instantiated through the {\it getHistogram},  {\it getTask} and {\it
getPage} methods. Such objects make sense only within the transaction
and should never be deleted by the user (they are destroyed by the
OnlineHistDB destructor). 

Changes are committed to the DB only by an explicit call to the {\it
commit} method.

By default, DB errors don't throw exceptions to the client code but
for severe inconsistencies (i.e. bugs). The default behaviour can be
changed (see section \ref{dbenvclass}). Normally, one can detect
errors by the method return values and choose if commit or not. \\
Histogram declarations are a special case since, 
in order to improve performance, they are stored in
a buffer, with default depth 1000, and actually sent to the DB
server only when the buffer is full or at commit time. In order to
check for errors in histogram declarations, one can use the {\it
sendHistBuffer} method to force buffer sending, and check its return
value before committing. Note that if an error occurs and you commit anyway, 
only all histograms declared before the error are sent to the DB, and
the buffer is emptied.


\begin{list}{$\bullet$}{}

\input{OnlineHistDB}

\end{list}


\subsection{OnlineHistogram class}

OnlineHistogram objects are instantiated within an
OnlineHistDB object, i.e. a DB transaction, through the {\it
getHistogram} method.

\begin{list}{$\bullet$}{}
\input{OnlineHistogram}
\end{list}

\subsection{OnlineRootHist class}

This class inherits from OnlineHistogram and ROOT's TH1 classes. It
can be used as an interface between the histogram DB and ROOT, in
order to load or save display parameters trasparently.

\begin{list}{$\bullet$}{}
\input{OnlineRootHist}
\end{list}


\subsection{OnlineHistTask class}

OnlineHistTask objects are instantiated within an
OnlineHistDB object, i.e. a DB transaction, through the {\it getTask} method.

\begin{list}{$\bullet$}{}
\input{OnlineHistTask}
\end{list}


\subsection{OnlineHistPage class}

OnlineHistPage objects are instantiated within an
OnlineHistDB object, i.e. a DB transaction, through the {\it
getPage} method.

\begin{list}{$\bullet$}{}
\input{OnlineHistPage}
\end{list}


\subsection{OnlineHistDBEnv class}\label{dbenvclass}
All previous classes derivate from this one, that has a few public
members:
\begin{list}{$\bullet$}{}
\input{OnlineHistDBEnv}
\end{list}

Note that the debug and exception levels defined for the OnlineHistDB object are
propagated to all new objects created through the {\it getPage} and
{\it getHistogram} methods.



\section{Code Example}

\begin{verbatim}
#include <OnlineHistDB/OnlineHistDB.h>
int main ()
{
\end{verbatim}
Open DB transaction:
\begin{verbatim}
 OnlineHistDB *HistDB = new OnlineHistDB(PASSWORD,
				OnlineHistDBEnv_constants::ACCOUNT,
			 	OnlineHistDBEnv_constants::DB);
 bool ok=true;
\end{verbatim}
Declare the features of your task 
\begin{verbatim}
 ok &= HistDB->declareTask("EXAMPLE","MUON","GAS","",true,true,false);
 OnlineHistTask* mytask = HistDB->getTask("EXAMPLE");
 if (mytask)
   mytask->setSavingFrequency(3.5);
\end{verbatim}
Declare some histograms (this is not normally needed for histograms
handled by the Online system)
\begin{verbatim}
 if (ok) {
   string ServiceName="H1D/nodeMF001_EXAMPLE_01/SafetyCheck/Trips";
   HistDB->declareHistByServiceName(ServiceName);
   ServiceName="H1D/nodeMF001_EXAMPLE_01/SafetyCheck/Trips_after_use_of_CRack";
   HistDB->declareHistByServiceName(ServiceName);
   ServiceName="H2D/nodeMF001_EXAMPLE_01/OccupancyMap/Hit_Map_$Region_M1R1";
   HistDB->declareHistByServiceName(ServiceName); 
   ServiceName="H2D/nodeMF001_EXAMPLE_01/OccupancyMap/Hit_Map_$Region_M1R2";
   HistDB->declareHistByServiceName(ServiceName);
   ServiceName="H2D/nodeMF001_EXAMPLE_01/OccupancyMap/Hit_Map_$Region_M3R1";
   HistDB->declareHistByServiceName(ServiceName);
   
   // alternative declaration not using DIM Service Name
   HistDB->declareHistogram("EXAMPLE","Timing","Coincidences",OnlineHistDBEnv::H1D);
   HistDB->declareHistogram("EXAMPLE","Timing","Time_of_flight",OnlineHistDBEnv::H1D);
   // DIM Service Name can be specified afterwards
   OnlineHistogram* thisH = HistDB->getHistogram("EXAMPLE/Timing/Time_of_flight");
    if(thisH)
     thisH->setDimServiceName("H1D/nodeA01_Adder_01/EXAMPLE/Timing/Time_of_flight");
    
   ok &= HistDB->sendHistBuffer(); // needed to send histogram buffer to DB
 }
\end{verbatim}
Now declare an histogram to be produced at analysis level by some
algorithm, and an automatic check to be performed on it (the
declaration of algorithms should be normally done by the developers of analysis
library)  
\begin{verbatim}
 HistDB->declareCreatorAlgorithm("Subtraction",2,OnlineHistDBEnv::H1D,0,NULL,
				 "bin-by-bin subtraction");

 OnlineHistogram* s1=HistDB->getHistogram("EXAMPLE/SafetyCheck/Trips");
 OnlineHistogram* s2=HistDB->getHistogram("EXAMPLE/SafetyCheck/Trips_after_use_of_CRack");
 OnlineHistogram* htrips=0;
 std::vector<OnlineHistogram*> sources;
 if(s1 && s2) {
   sources.push_back(s1);
   sources.push_back(s2);
   htrips=HistDB->declareAnalysisHistogram("Subtraction",
					   "Trips_due_to_CRack",
					   sources);
 }

 std::string mypar[1]={"Max"};
 bool algok=HistDB->declareCheckAlgorithm("CheckMax",1,mypar,
			       "Checks all bins to be smaller than Max");
 
 if (htrips && algok) {
   std::vector<float> warn(1,100.);
   std::vector<float> alarm(1,500.);
   htrips->declareAnalysis("CheckMax", &warn, &alarm);
 } 
\end{verbatim}
Now create a page and edit the display options of its
histograms. 
\begin{verbatim}
 OnlineHistogram* h1=HistDB->getHistogram
   ("EXAMPLE/OccupancyMap/Hit_Map_$Region_M1R1");
 OnlineHistogram* h2=HistDB->getHistogram
   ("EXAMPLE/OccupancyMap/Hit_Map_$Region_M1R2");
 OnlineHistogram* h3=HistDB->getHistogram
   ("EXAMPLE/OccupancyMap/Hit_Map_$Region_M3R1");

 if (h1 && h2 && h3) {
   std::string hcpar[2]={"w1","w2"};
   algok = HistDB->declareCreatorAlgorithm("Weighted mean",
					   2,
					   OnlineHistDBEnv::H1D,
					   2,
					   hcpar,
				"weighted mean of two histograms with weights w1 and w2");
   sources.clear();
   sources.push_back(h1);
   sources.push_back(h2);
   std::vector<float> weights(2,1.);
   weights[1]=0.5;
   if(algok) HistDB->declareAnalysisHistogram("Weighted mean",
					      "Silly plot",
					      sources,
					      &weights);

   OnlineHistPage* pg=HistDB->getPage("My Example Page","Examples/My examples");
   if(pg) {
     pg->declareHistogram(h1,0. ,0. ,0.5,0.5);
     pg->declareHistogram(h2,0. ,0.5,0.5,0.5);
     pg->declareHistogram(h3,0.5,0.5,0.5,0.4);
   
     int lc=2, fs=7, fc=3;
     float ymax=20000.;
     h1->setDisplayOption("LINECOLOR",(void*) &lc);
     h1->setDisplayOption("FILLSTYLE",(void*) &fs);
     h1->setDisplayOption("FILLCOLOR",(void*) &fc); 
     h1->setDisplayOption("YMAX",(void*) &ymax); 

     h1->dump();

     // second instance of h1
     OnlineHistogram* newh = pg->declareHistogram(h1,0.5,0. ,0.5,0.4,2);
     ymax=200000.;
     newh->setDisplayOption("YMAX",(void*) &ymax); 
     newh->unsetDisplayOption("LINECOLOR");

     newh->dump();
   }
 }
\end{verbatim}

Now display the list of pages with their histograms
\begin{verbatim}
 std::vector<string> folders;
 std::vector<string> pages;
 std::vector<OnlineHistogram*> histos; 
 int nfold=HistDB->getPageFolderNames(folders);
 int i,j,k;

 for (i=0;i<nfold;i++) {
   cout << "Folder " << folders[i] <<endl;
   pages.clear();
   int np=HistDB->getPageNamesByFolder(folders[i],pages);
   for (j=0;j<np;j++) {
     cout << "     Page " << pages[j] <<endl;
     histos.clear();
     int nh=HistDB->getHistogramsByPage(pages[j],histos);
     for (k=0;k<nh;k++) {
       cout << "           Histogram " << histos[k]->name() <<endl;
     }    
   }
 }
\end{verbatim}
and the lists of subsystems, tasks, and algorithms:
\begin{verbatim}
 std::vector<string> mylist;
 cout << "----------------------------------------"<<endl;
 int nss=HistDB->getSubsystems(mylist);
 for (i=0;i<nss;i++) {
   cout << "Subsys "<<mylist[i]<<endl;
 }
 mylist.clear();
 cout << "----------------------------------------"<<endl;
 nss=HistDB->getTasks(mylist);
 for (i=0;i<nss;i++) {
   cout << "Task "<<mylist[i]<<endl;
 }
 mylist.clear();
 cout << "----------------------------------------"<<endl;
 nss=HistDB->getAlgorithms(mylist);
 for (i=0;i<nss;i++) {
   cout << "Algorithm "<<mylist[i]<<endl;
 }
\end{verbatim}

finally commit changes to the DB if there were no errors
\begin{verbatim}
 ok &= HistDB->sendHistBuffer();
 if (ok) 
   HistDB->commit();
 else 
   cout << "commit aborted because of previous errors" <<endl;

 HistDB->setDebug(3); // close transaction verbosely
 delete HistDB;
}
\end{verbatim}


\begin{thebibliography}{99}
\bibitem{genhisto}
LHCb Commissioning Group, ``Histogramming Framework'', EDMS 748834
\bibitem{dbdesign}
``Histogram DB and Analysys Tools for Online Monitoring'', EDMS 774740

\end{thebibliography}


\end{document}
