#ifndef ONLINE_RESOURCEMGR_RESOURCEMGR_H
#define ONLINE_RESOURCEMGR_RESOURCEMGR_H

#ifdef __cplusplus
#include <string>

extern "C"  {
#define __CXX_CONST const
#else
#define __CXX_CONST
#endif

  /** Create a generic resource
    *
    * This routine will create an entry in the Resource
    * Manager Generic Resource Database (provided the resource
    * does not already exist) that defines a particular resource
    * as being either a limited or sequential resource.
    *
    * Calling syntax:
    * rm_create_generic  resnam, size, initial
    *
    * @param  resnam   [IN]   Name of the resource.
    * @param  size     [IN]   The size of the limited generic resource or zero 
    *                         for sequential resources. This argument tells the 
    *                         RM how many copies it can generate of a particular 
    *                         resource.
    * @param  initial  [IN]   The starting value for the sequence generated by 
    *                         calling rm_book_generic. For sequential resources, 
    *                         the numbers returned will be an integer sequence 
    *                         commencing at this value. For limited resources, 
    *                         this is the smallest copy number, the largest being
    *                         initial_value + size.
    * @return Longword condition value. Bite 0 is set on SUCCESS
    */
  int rm_create_generic(__CXX_CONST char* resnam, int size, int initial);

  /** Delete a generic resource
    * This routine removes the resource entry in the Resource Manager Generic 
    * Resource Database, provided the resource exists and is not occupied.    *
    *
    * Calling syntax:
    * rm_delete_generic  resnam
    *
    * @param  resnam   [IN]   Name of the resource.
    * @return Longword condition value. Bite 0 is set on SUCCESS
    */
  int rm_delete_generic(__CXX_CONST char* resnam);
  
  /** Book a Generic Resource
    * This routine checks the compatibility of the booking
    * request with what is currently occupied, verifies that
    * the resource has been created as a generic resource,
    * and, if compatible, books the resource exclusively.
    *
    * Calling syntax:
    * rm_book_generic  resnam, resnum
    *
    * @param  resnam   [IN]   Name of the resource.
    * @param  resnum   [OUT]  Pointer to location for the copy of 
    *                         the number of generic resource that 
    *                         was successfully booked.
    *
    * @return Longword condition value. Bite 0 is set on SUCCESS
    */
  int rm_book_generic(__CXX_CONST char* resnam, int* resnum);

  /** Find the Last used Sequential Generic Resource
    *
    * This routine retrieves the number of the last used resource in the sequence 
    * for a Sequential resource, provided the resource has been created as a 
    * generic resource.
    *
    * @param  resnam   [IN]   Name of the resource.
    * @param  resnum   [OUT]  Number of generic resource that was last successfully booked.
    *
    * @return Longword condition value. Bite 0 is set on SUCCESS
    */
  int rm_last_generic(__CXX_CONST char* resnam, int* resnum);

  /** Release a Generic Resource
    *
    * This routine releases a Generic resource from the caller's use. It can 
    * only be used for LIMITED resources as Sequential resources can never be 
    * returned once booked (i.e. Run numbers cannot repeat).
    * 
    * Calling syntax:
    * rm_release_generic  resnam, copy
    *
    * @param  resnam   [IN]   Name of the resource.
    * @param  copy    [OUT]   Copy number of the Limited generic resource that has been
    *                         successfully booked and should now be released.
    *
    * @return Longword condition value. Bite 0 is set on SUCCESS
    */
  int rm_release_generic(__CXX_CONST char* resnam, int copy);

  enum { 
    RM_ERROR = 0,
    RM_SUCCESS = 1
  };
#ifdef __cplusplus
}

namespace LHCb  {
  struct Resource  {
    std::string name;
    int         value;
    Resource(const std::string& n) : name(n), value(-1)  {}
  };
  class ResourceMgr  {
  public:
    ResourceMgr();
    virtual ~ResourceMgr();
    int book(Resource& resource);
    int release(Resource& resource);
  };
}
#endif
#undef __CXX_CONST
#endif /* ONLINE_RESOURCEMGR_RESOURCEMGR_H */

// Create a generic resource
int rm_create_generic(const char* resnam, int size, int initial)  {
  if(resnam&&size&&initial)return RM_SUCCESS;
  return RM_SUCCESS;
}

// Delete a generic resource
int rm_delete_generic(const char* resnam)  {
  if(resnam)return RM_SUCCESS;
  return RM_SUCCESS;
}

// Book a Generic Resource
int rm_book_generic(const char* resnam, int* next_free_resource)  {
  if(resnam&&next_free_resource)return RM_SUCCESS;
  return RM_SUCCESS;
}

// Find the Last used Sequential Generic Resource
int rm_last_generic(const char* resnam, int* resnum)  {
  if(resnam&&resnum)return RM_SUCCESS;
  return RM_SUCCESS;
}

// Release a Generic Resource 
int rm_release_generic(const char* resnam, int copy)  {
  if(resnam&&copy)return RM_SUCCESS;
  return RM_SUCCESS;
}
