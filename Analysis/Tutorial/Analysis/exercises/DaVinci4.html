<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><title>LHCb-UK Software Training</title>
    
    
    <link rel="stylesheet" media="screen" type="text/css" 
      href="http://www.hep.phy.cam.ac.uk/lhcb/LHCbSoftTraining/documents/lhcb-cambridge-blue.css">

      <link rel="stylesheet" media="print" type="text/css" 
	href="http://www.hep.phy.cam.ac.uk/lhcb/LHCbSoftTraining/documents/lhcb-cambridge-print.css"></head><body>

  <body>

    <table id="titlebar">
      <tbody>
	<tr style="vertical-align: bottom;">

	  <td style="padding-bottom: 15px;">
	    <h1>LHCb Software Training: DaVinci</h1></td>
	  <td id="lhcblogo" style="text-align: right;">
	    <a href="http://cern.ch/lhcb">
	      <img src="http://lhcb.web.cern.ch/lhcb/lhcblogo.gif"></a></td>
	</tr>
      </tbody>
    </table>

    
    <div id="content">
      
            <h1><span lang="en-gb">Exercises linked to DaVinci session 4</span></h1>
	    
      <p>   
	Now we will add some monitoring, checking and retrieve some more information about the event.
		</p><h2>1. Print some debugging information</h2>
			<ol>
			<li><b>Use the <code>PrintTree</code> algorithm to print the reconstructed 
			tree.</b>
			<ul>
			<li>You need to give it the location where to find your head Particle.
			<li>You need to tell the <code>DebugTool</code> what variables to print.
			For instance		
<code class="display">PrintFoundBs.DebugTool.Information = "Name E M P Px Py Pz Pt phi Vz" ;</code>
		will print you something like
<code class="display"><------------------------------------------------- Particle ------------------------------------------------->
                Name         E         M         P        Px        Py        Pz        Pt       phi        Vz
                           MeV       MeV       MeV       MeV       MeV       MeV       MeV      mrad        mm
B_s0                 58779.72   5351.58  58535.60   6708.01   7629.33  57647.31  10158.94    849.57     53.57
+-->J/psi(1S)        38732.71   3083.78  38609.75   4409.98   3457.34  38200.94   5603.67    664.90     53.45
|+-->mu+             22272.24    105.66  22271.99   1721.37    724.00  22193.57   1867.42    398.13     43.02
|+-->mu-             16463.05    105.66  16462.71   2688.79   2733.51  16009.97   3834.28    793.65     49.25
+-->phi(1020)        20039.80   1018.39  20013.91   2296.83   4170.17  19439.41   4760.86   1067.36     52.77
 +-->K+               9151.85    493.68   9138.52    932.82   1902.47   8889.49   2118.85   1114.92     49.45
 +-->K-              10887.81    493.68  10876.61   1364.00   2267.58  10549.80   2646.21   1029.26     49.55</code>
		</ul>
		<li><b>Use the <code>PrintMCTree</code> algorithm to print the MC true tree.</b>
		<ul>
		<li>In this case you have to tell the algorithms for which particles it has to print the tree.
<code class="display">PrintTrueBs.ParticleNames = {  "B_s0", "B_s~0" } ;</code>
		<li>It is recommendec to give the depth of the tree in order to avoid having all
		particles from interaction with matter. 
<code class="display">PrintTrueBs.Depth = 2;  // down to the K and mu</code>
will give you for the same event:
<code class="display"><------------------------------------------------ MCParticle ------------------------------------------------>
                Name         E         M         P        Px        Py        Pz        Pt       phi        Vz
                           MeV       MeV       MeV       MeV       MeV       MeV       MeV      mrad        mm
B_s0                 58881.35   5369.20  58636.04   6722.81   7663.34  57743.07  10194.26    850.68     47.83
+-->phi(1020)        20095.79   1019.38  20069.92   2301.61   4189.67  19492.33   4780.25   1068.45     53.70
|+-->K-              10907.93    493.68  10896.75   1367.63   2277.03  10568.06   2656.18   1029.92     53.70
|+-->K+               9187.86    493.68   9174.59    933.98   1912.63   8924.27   2128.49   1116.53     53.70
+-->J/psi(1S)        38785.62   3096.88  38661.78   4421.20   3473.68  38250.75   5622.59    665.95     53.70
 +-->gamma               0.03      0.00      0.03      0.00      0.00      0.03      0.00      0.00     53.70
 +-->mu-             16513.64    105.66  16513.30   2699.51   2749.27  16057.50   3853.03    794.53     53.70
 +-->mu+             22271.93    105.66  22271.68   1721.68    724.41  22193.21   1867.87    398.27     53.70</code>
 Notice the low-energy gamma that is emitted by the J/psi in some events.
		<li>Increase the <code>Depth</code> value to see all the particles created in the detector. Most of them are created in the calorimeters between 11 and 15m.
		</ul>
		<p></p>
		<li><b>Filter you input kaons and muons according to the truth</b>
		<ul>
		<li>Add two <code>FilterDesktop</code> algorithms that run on the standard muons
		and kaons are keep only the ones associated to the true particles of your B<sub>s</sub>.</code>
                </ul>

		</ol>	
		The solution to this part is to be found in <code>solutions/DaVinci5/</code>	

		</p><h2>2. Checking algorithm</h2>
		We will create a new algorithm that runs on the found B<sub>s</sub> and associates it to truth.
		It will also fill an nTuple and add some more information about tagging and trigger. There is no chance that you
		will have enough time to do it all during the practical sessions. 
		<ol>
<p></p>				
		<li><b>New algorithm</b>
		<p>Let's call it <code>TutorialChecker</code>. You need to:</p>
		<ul>
		<li>Declare it to <code>Analysis_load.cpp</code>.
		<li>Create the cpp and header files. The algorithm is a <code>DVAlgorithm</code> again.
		<li>Add it to your sequence as you want to run it only for events where you found something. 
		</ul> 
<p></p>				
		<li><b>Tuple filling</b>
		<ul>
		<li>Create a <code>Tuple</code> in the <code>execute()</code> method. 
		<code class="display">Tuple tuple = nTuple("TutorialTuple");</code>
		Although it does look like an object it actually behaves like a pointer. Be warned that it's not 
		a persistent object. There is no way you can define it in <code>initialise()</code> and keep it
		for the whole job (ask Chris for details).
		<li>Loop over the B<sub>s</sub> candidates. You know how to do that.
		<li>For each B<sub>s</sub> call a method
		<code class="display">StatusCode TutorialChecker::fillReco(Tuple& tuple,const LHCb::Particle* b)</code>
		<li>In there fill some viables in the Tuple. For instance the mass:
		<code class="display">tuple->column( "Mass", b->measuredMass()); // mass</code>
		<li>The momentum can be filled in one go <b>from the next Gaudi release</b>:
		<code class="display">tuple->column( "P", b->momentum()); // 4-vector!</code>
		In the meantime you have to do it like this:
		<code class="display">tuple->column( "PX", b->momentum().x());
tuple->column( "PY", b->momentum().y());
tuple->column( "PZ", b->momentum().z());
tuple->column( "E", b->momentum().e());</code>
		<li>You can also fill the impact parameter of each B<sub>s</sub> on each primary vertex. This would go like:
		<code class="display">std::vector&lt;double&gt; ips, ipes;
for ( LHCb::RecVertex::ConstVector::const_iterator ipv = PVs.begin() ; 
      ipv != PVs.end() ; ++ipv ){
  double ip, ipe;
  geomDispCalculator()->calcImpactPar(*b, *(*ipv), ip, ipe);
  ips.push_back(ip);
  ipes.push_back(ipe);
}  
tuple->farray( "IP",  ips.begin(), ips.end(), "PVs", 20);
tuple->farray( "IPe", ipes.begin(), ipes.end(), "PVs", 20);
</code>
                It would be actually more interesting to store the flight distance and the lifetime...
                <li>You could as well store the vertex, the momenta of the daughters, or anthing else you like...
		<li>At the end of your <code>execute()</code> method write out the tuple:
		<code class="display">StatusCode sc = tuple->write();</code>
                <li>It's probably a good idea to compile and run at this stage. Don't forget to declare the algorithm
		 in your options. You will also have to declare the name of the Tuple you want to save:
		<code class="display">NTupleSvc.Output={"FILE1 DATAFILE='Tuple.root' TYP='ROOT' OPT='NEW'"};</code>
		<li>You can then view it in root:
		<code class="display">TFile* F = new TFile("Tuple.root")
TTree* T = F->Get("TutorialChecker/1")
T->Print()
T->Draw("Mass")</code>
		</ul> 
<p></p>				
		<li><b>MC truth</b>
		<ul>
		<li>For each B<sub>s</sub> call a method
		<code class="display">StatusCode TutorialChecker::fillTruth(Tuple& tuple,const LHCb::Particle* b)</code>
		where you would handle everything realted to truth association. It is a good
		idea to keep the truth as separate from the rest as possible, so that you can easily switch it off
		when you run on data not containing MC truth information (like real data...).
		</ul>
<p></p>				
		<li><b>Background category tool</b>
		<p>
		The first thing we want to do is to get the background category. This tells you if the
		reconstructed B<sub>s</sub> is correctly reconstructed or if it is background, and which type of
				background. See the details 
				<a href="http://lhcb-release-area.web.cern.ch/LHCb-release-area/PHYS/doc/html/class_i_background_category.html">here</a>.
</p>				
                <ul>
		<li>The tool is not pre-declared to <code>DVAlgorithm</code>, so you'll have to declare it. First in the header file:
		<code class="display">#include "Kernel/IBackgroundCategory.h"</code>
		and
		<code class="display">private:
  IBackgroundCategory* m_background ;</code>
                Please note that <code>"Kernel/IBackgroundCategory.h"</code> is only found beacause in the 
		package <code>requirements</code> we have a line that says
		<code class="display">use DaVinciMCKernel v* Phys</code>
                <li>Initialise it as a private tool in <code>initialize()</code>:
		<code class="display">m_background = tool<IBackgroundCategory>("BackgroundCategory",this);</code>	
                <li>Before you can use it in <code>fillTruth</code>:
		<code class="display">IBackgroundCategory::categories cat = m_background->category(b);
tuple->fill("category",cat);</code>
		<li>It's probably a good idea to compile and run at this stage.
		</ul>	
<p></p>				
		<li><b>MC association</b>
		<p>Now we want to associate our B<sub>s</sub> to the true one. 
		We will use the <code>Particle2MCLinker</code> class for this. </p>
		<ul>
		<li>Here again one needs to declare everything in the header file:
		<code class="display">#include "DaVinciAssociators/Particle2MCLinker.h"</code>
		and
		<code class="display">private:
  Particle2MCLinker* m_pLinker;</code>
		which is found at compilation because we have declared <code>DaVinciAssociators</code> in the 
		<code>requirements</code> file.
                <li>Initialise it in <code>initialize()</code>:
		<code class="display">m_pLinker = new Particle2MCLinker(this,Particle2MCMethod::Composite, ""); </code>	
                <li>You can now use it in <code>fillTruth</code>:
		<code class="display">const LHCb::MCParticle* MC = m_pLinker->firstMCP( b );</code>
		You can the fill some tuple variables with the MC true B<sub>s</sub>. But be careful to
		check that there is one found. Never use a pointer without checking!
		<li>It's probably a good idea to compile and run at this stage.
		</ul>			
<p></p>				
		<li><b>Tagging</b>
		<p>B<sub>s</sub>->J/psiPhi is only interesting if we are able to tag the initial flavour of the B<sub>s</sub>.</p>
		<ul>
		<li>The <code>DVAlgorithm</code> method <code>flavourTagging()</code> 
		provides a pointer to 
		<code><a href="http://lhcb-release-area.web.cern.ch/LHCb-release-area/PHYS/doc/html/class_i_b_tagging_tool.html">IBTaggingTool</a></code>. Try to use it to get a 
		<code><a href="http://lhcb-release-area.web.cern.ch/LHCb-release-area/LHCB/doc/html/class_l_h_cb_1_1_flavour_tag.html">FlavourTag</a> object.
		<li>Its method <code>decision()</code> tells you the initial flavour of the b quark.
		<li>It's probably a good idea to compile and run at this stage. You have to configure the tool
		to get it working. Unfortunately there's a typo in the released options, so we have a corrected 
		copy in the tutorial package. Add:
		<code class="display">/// B tagging options
#include "$ANALYSISROOT/options/BTaggingTool.opts"</code>
Later it would be 
		<code class="display">/// B tagging options
#include "$FLAVOURTAGGINGROOT/options/BTaggingTool.opts"</code>
		<li>In root compare the tag decision with the true PID.
		<code class="display">T->Draw("TPID/Tag","Tag!=0")</code>
		</ul>			
<p></p>				
		<li><b>Trigger</b>
		</ul>			
		<ul>
		<li><i><b>The trigger is under development...</b></i>
		</ul>			
		</ol>
		The solution to this part is to be found in <code>solutions/DaVinci6/</code>	


<hr>
<p><span lang="en-gb">Last modified by P. Koppenburg, Jan 5 2007.
</span></p></div>
</body></html>
