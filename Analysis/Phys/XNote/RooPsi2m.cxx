 /***************************************************************************** 
  * Project: RooFit                                                           * 
  *                                                                           * 
  * This code was autogenerated by RooClassFactory                            * 
  *****************************************************************************/ 

 // Your description goes here... 

 #include "Riostream.h" 

 #include "RooPsi2m.h" 
 #include "RooAbsReal.h" 
 #include "RooAbsCategory.h" 
 #include <math.h> 
 #include "TMath.h" 

 ClassImp(RooPsi2m) 

 RooPsi2m::RooPsi2m(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _p1,
                        RooAbsReal& _p2,
                        RooAbsReal& _p3,
                        RooAbsReal& _lambda) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
    p1("p1"," p1",this,_p1),
    p2("p2"," p2",this,_p2),
    p3("p3"," p3",this,_p3),
    lambda("lambda"," lambda",this,_lambda)
 { 
 } 


 RooPsi2m::RooPsi2m(const RooPsi2m& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
    p1("p1",this,other.p1),
    p2("p2",this,other.p2),
    p3("p3",this,other.p3),
    lambda("lambda",this,other.lambda)
 { 
 } 



 Double_t RooPsi2m::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   return formFactor()*PS() ; 
 } 


Double_t RooPsi2m::formFactor() const {

  double mpp2 = x*x;
  double mpion2 = p3*p3;
  double f = mpp2 - lambda* mpion2;
  return f*f;
}

Double_t RooPsi2m::PS() const {

  double mpp2 = x*x;
  double mD2 = p1*p1;
  double mP2 = p2*p2;
  double mpion2 = p3*p3;

  double sum = -2*((mD2*mpp2) +  (mP2*mpp2) + (mD2*mP2));
  sum +=  (mD2*mD2) + (mP2*mP2) + ( mpp2 *  mpp2);
  if (sum < 0) sum = 0.0;
  //  std::cout << sum << std::endl;
 

  double fact = mpp2 - 4 * mpion2;
  if (fact < 0) fact = 0.0;  
  return 0.5*sqrt(sum*fact)/mP2;
  //  return sqrt( sum*fact/(4*mP2) ) ;
}
