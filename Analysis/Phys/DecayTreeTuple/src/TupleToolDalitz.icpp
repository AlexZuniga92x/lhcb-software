//=============================================================================
// The templated method filling the tuple for Particles and MCParticles
//=============================================================================
/// The templated method that does it all
template<class TYPE>
StatusCode fill( const std::vector<const TYPE*> dauts      /// daughters
                 , const std::string head                  /// header
                 , Tuples::Tuple& tuple                    /// tuple
                 , bool revert ){                          /// revert all PID (because mother is antiparticle)
  
  bool test = true;
  
  typename std::vector<const TYPE*>::const_iterator i, j;
  for ( i = dauts.begin() ; i!= dauts.end() ; ++i){
    std::string n1 = name( (*i)->particleID(), revert );
    Gaudi::LorentzVector p1 = (*i)->momentum() ;
    for ( j = dauts.begin() ; i!= j ; ++j){
      std::string n2 = name( (*j)->particleID(), revert );                                        
      Gaudi::LorentzVector p = p1+(*j)->momentum() ;
      if (msgLevel(MSG::VERBOSE)) verbose() << (*i)->particleID().pid() << " " << (*j)->particleID().pid()  << " " 
                                            << head+"Dalitz_"+n1+"_"+n2+"_M2"<< " " << revert << endmsg ;
      test &= tuple->column( head+"Dalitz_"+n1+"_"+n2+"_M2",p.M2()  );
    }
  }

  return StatusCode(test) ;
  
}

/// get name of particle or anti-particle
std::string name(const LHCb::ParticleID& id, bool revert)const{
  return Decays::escape( ( revert ?
                           ppSvc()->find( id )->antiParticle()->particle() :
                           ppSvc()->find( id )->particle() )) ;
}

/// get particle property serivce
const LHCb::IParticlePropertySvc* ppSvc()const{
  return m_ppSvc ;
}

StatusCode initialize(){
  if (!GaudiTool::initialize()) return StatusCode::FAILURE ;
  m_ppSvc = svc<LHCb::IParticlePropertySvc>("LHCb::ParticlePropertySvc", true );
  return StatusCode::SUCCESS ;
}

LHCb::IParticlePropertySvc* m_ppSvc ;
