#!/usr/bin/env python 
# -*- coding: utf-8 -*-
# =============================================================================
# $Id$ 
# =============================================================================
## @file ostap
#  
#     .oooooo.                .                        
#    d8P'  `Y8b             .o8                        
#   888      888  .oooo.o .o888oo  .oooo.   oo.ooooo.  
#   888      888 d88(  "8   888   `P  )88b   888' `88b 
#   888      888 `"Y88b.    888    .oP"888   888   888 
#   `88b    d88' o.  )88b   888 . d8(  888   888   888 
#    `Y8bood8P'  8""888P'   "888" `Y888""8o  888bod8P' 
#                                            888       
#                                           o888o      
#                                                    
#  Simple interactive PyRoot-based analysis environment to provide access
#  to zillions useful decorators for ROOT (and not only ROOT!) objects&classes  
# 
#  This file is a part of 
#  <a href="http://cern.ch/lhcb-comp/Analysis/Bender/index.html">Bender project</a>
#  <b>``Python-based Interactive Environment for Smart and Friendly Physics Analysis''</b>
#
#  The package has been designed with the kind help from
#  Pere MATO and Andrey TSAREGORODTSEV. 
#  And it is based on the 
#  <a href="http://cern.ch/lhcb-comp/Analysis/LoKi/index.html">LoKi project:</a>
#  <b>``C++ ToolKit for Smart and Friendly Physics Analysis''</b>
#
#  By usage of this code one clearly states the disagreement 
#  with the smear campaign of Dr.O.Callot et al.: 
#  ``No Vanya's lines are allowed in LHCb/Gaudi software''
#
#  @date   2012-02-15
#  @author Vanya BELYAEV Ivan.Belyaev@itep.ru
#
#                    $Revision$
#  Last modification $Date$
#                 by $Author$
# =============================================================================
"""
Simple interactive PyRoot-based analysis environment
to provide access to zillions useful decorators for ROOT
(and not only ROOT) objects&classes

This file is a part of BENDER project:

``Python-based Interactive Environment for Smart and Friendly Physics Analysis''

The project has been designed with the kind help from Pere MATO and Andrey TSAREGORODTSEV. 

And it is based on the LoKi project: ``C++ ToolKit for Smart and Friendly Physics Analysis''

By usage of this code one clearly states the disagreement with the smear campaign
of Dr.O.Callot et al.:

``No Vanya's lines are allowed in LHCb/Gaudi software''
"""
# =============================================================================
__author__  = 'Vanya BELYAEV Ivan.Belyaev@itep.ru'
__date__    = "2012-09-10"
__version__ = '$Revision$'
# =============================================================================
import ROOT, sys, os  
ROOT.PyConfig.IgnoreCommandLineOptions = True
# =============================================================================
# logging 
# =============================================================================
from AnalysisPython.Logger import getLogger 
_my_name_ = __name__
if _my_name_ in ( '__main__' , '__builtins__' ) : _my_name_ = 'Ostap'
# =============================================================================
logger = getLogger( _my_name_ )
# =============================================================================
## parse arguments 
def parse_args ( ) :
    """
    Parse arguments 
    """
    from argparse import ArgumentParser 
    parser = ArgumentParser ( prog = 'ostap' )
    #
    group1 = parser.add_mutually_exclusive_group()    
    group1.add_argument ( 
        "-q" , "--quiet"       ,
        dest    = 'Quiet'      , 
        action  = 'store_true' ,
        help    = "Quite processing [default: %(default)s]" ,
        default = False        )
    group1.add_argument ( 
        "--verbose"     ,
        dest    = 'Verbose'    , 
        action  = 'store_true' ,
        help    = "Verbose processing [default: %(default)s]" ,
        default = False        )
    #
    parser.add_argument (
        "files" ,
        metavar = "FILE" , nargs = '*' , 
        help    = "ROOT/python files to be opened/processed [default: %(default)s]" ,
        default = []  )
    #
    parser.add_argument ( 
        "-m" , "--modules" ,
        metavar = "MODULE" , nargs = '*' ,
        help    = "ROOT/python modules to be imported [default: %(default)s]",
        default = []  )
    #
    parser.add_argument (
        '-w'                       ,
        '--with-context'           ,
        action  = "store_true"     ,
        dest    = 'WithContext'    ,
        help    = "Use global context for the scripts [default: %(default)s]",
        default = False            )
    #
    parser.add_argument ( 
        '-n' , '--nocanvas'     ,
        dest    = 'canvas'      , 
        action  = 'store_false' , 
        help    = "Do not create canvas", 
        default = True          )
    #
    group2 = parser.add_mutually_exclusive_group()
    group2.add_argument ( '-i' ,  
                         '--interactive' , dest='batch', 
                         action = 'store_false' , default = False ,
                         help = "Interactive shell/start_ipython" )
    group2.add_argument ( '-e' ,
                         '--embed' , 
                         action = 'store_true' ,
                         help = "Interactive embedded shell" )
    group2.add_argument ( '-s' ,
                         '--simple' ,
                         action = 'store_true' ,
                         help = "Simple python shell" )
    group2.add_argument ( '-b' ,
                         '--batch' ,
                         action = 'store_true' , default = False , 
                         help = "Batch processing: execute files and exit" )

    v = [ a for a in sys.argv[1:] ]
    if '--' in v : v.remove('--')
    
    return parser.parse_args( v )

# =============================================================================
def with_ipython() :
    try :
        __IPYTHON__
        return True
    except NameError :
        return False 
# =============================================================================
if with_ipython () :
    raise RuntimeError("Can't start Ostap from ipython!")

# =============================================================================
## parse arguments
# =============================================================================
arguments = parse_args()

# =============================================================================
## suppress extra prints from logging  
# =============================================================================

if arguments.Quiet :
    
    import logging
    logging.disable ( logging.INFO )
    logger.info ( '(silent) Interactive Ostap session (steroid-enhanced PyROOT)')

else:
    
    import logging
    level = logging.DEBUG-3 if arguments.Verbose else logging.DEBUG
    logging.disable ( level  ) 
    
    import Ostap.Line
    logger.info ( "Welcome to Ostap\n" + Ostap.Line.line )
    logger.info ( __doc__ )
    
    _vars = vars ( arguments )
    _keys = _vars.keys()
    _keys .sort() 
    logger.info ( 'Arguments  : ')
    for _k in _keys : logger.info ( '  %15s : %-s ' % ( _k , _vars[_k] ) )
    del _keys,_vars,_k,level  
# =============================================================================
## set ROOT into batch mode 
# =============================================================================
ROOT.gROOT.SetBatch ( arguments.batch )
if ROOT.gROOT.IsBatch() : logger.info ('Batch processing is activated') 

# =============================================================================
## import everything from Ostap
# =============================================================================
from   Ostap.OstapBender import *

# =============================================================================
## Ostap startup: history, readlines, etc... 
# =============================================================================
if not arguments.batch :
    import Ostap.Startup
    
# =============================================================================
## create default canvas
# =============================================================================
if arguments.canvas : 
    import Ostap.Canvas 
    logger.debug ( "Create the default canvas" )
    canvas    = Ostap.Canvas.getCanvas ()

# =============================================================================
## execute startup files 
# =============================================================================
## startup files to be executed:
_startups = ( '$OSTAPSTART'     ,  
              '$HOME/.ostap.py' ,
              '~/.ostap.py'     ,        
              './.ostap.py'     )
_executed = set() 
for _s in _startups : 
    import os
    _ss = _s 
    _ss =  os.path.expandvars ( _ss )
    _ss =  os.path.expandvars ( _ss )
    _ss =  os.path.expandvars ( _ss )
    _ss =  os.path.expanduser ( _ss )
    _ss =  os.path.expandvars ( _ss )
    if not os.path.exists     ( _ss ) : continue
    if not os.path.isfile     ( _ss ) : continue
    _ss =  os.path.abspath    ( _ss )
    if _ss in _executed           : continue
    ## execute it! 
    try :
        execfile      ( _ss , globals() ) 
        _executed.add ( _ss )
        logger.info   ( "Startup file '%s' is executed"      % _s )
    except:
        logger.error  ( "Error in execution of '%s' startup" % _s , exc_info = True )
        

# =============================================================================
## cleanup a bit the context 
# =============================================================================
del with_ipython, parse_args, getLogger, _my_name_ 
del _startups,_executed,_s,_ss 

# =============================================================================
## import modules
# ============================================================================= 
if arguments.modules :
    import importlib 
    for m in arguments.modules :
        _m = importlib.import_module ( m )
        logger.info ("Imported module '%s' from '%s' " % ( mod.__name__ , mod.__file__ ) )
        ## play a bit with names 
        p,s,r = m.partition('.')
        if s : 
            _m2 = importlib.import_module(p)
            if not locals().has_key( p ) : 
                locals()[p] = _m2
                del _m2                ## avoid pollution of local namespace
        else :
            locals()[m] = _m
            del _m                     ## avoid pollution of local namespace 
        del p,s,r                      ## avodi pollution of local namesapce 
    del importlib                      ## avoid pollution of local namespace
    
# =============================================================================
## execute the files, defined as arguments
# =============================================================================
root_files = {}
for pattern in arguments.files :
    import glob 
    for _f in glob.iglob ( pattern ) :
        
        fok = os.path.exists ( _f ) and os.path.isfile ( _f ) 
        name,dot,ext  = _f.rpartition('.')
        if  ext in ('root', 'ROOT' ) :
            from Ostap.TFileDeco import ROOTCWD 
            try :
                with ROOTCWD() :
                    print 'HERE', _f 
                    f = ROOT.TFile.Open( _f , 'READ')
                    root_files [ name ] = f 
                    logger.info ("Open ROOT file '%s'" % _f )
                    f.ls()
                    continue
                
            except :
                
                # - Batch mode:       just re-raise exception
                if arguments.batch :  raise
                
                # - Interactive mode: print traceback and continue 
                logger.error ('Failure to open ROOT file "%s"'  % _f  , exc_info = True ) 

        ## execute python file 
        elif fok and 'py' == ext  :  

            logger.info  ("Try    to execute '%s'" % _f )
            
            try :

                if arguments.WithContext :  execfile ( _f , globals() ) ## with context 
                else                     :  execfile ( _f )             ## plain  
                    
            except :
                
                # - Batch mode:       just re-raise exception
                if arguments.batch :  raise
                
                # - Interactive mode: print traceback and continue 
                logger.error ('Failure to execute "%s"'     % _f  , exc_info = True ) 

        ## execute Ostap-script 
        elif fok and name and dot and ext in ( 'ost' , 'ostp' , 'ostap' ) :

            logger.info  ("Try    to execute '%s'" % _f )

            try :
                
                ## this one is always executed with the context!!!
                execfile ( _f , globals() ) ## with context 
                
            except :
                
                # - Batch mode:       just re-raise exception
                if arguments.batch :  raise
                
                # - Interactive mode: print traceback and continue 
                logger.error ('Failure to execute "%s"'     % _f  , exc_info = True ) 
                                        
        else :
            
            # - Batch mode: just raise exception
            if arguments.batch :
                raise NameError( "Unknown command line symbol/pattern '%s'/'%s'" % ( _f , pattern )  )

            # - Interactive mode: print error message and continue 
            logger.error ("Unknown command line symbol/pattern '%s'/'%s'" % ( _f , pattern )  )
            


## list names of opened ROOT files 
if root_files :
    logger.info("Opened ROOT files: %d (with '.root' extension)" % len ( root_files ) )
    keys = root_files.keys()
    keys.sort()
    _n = 0  
    for k in keys :
        _n +=  1
        rfile = root_files [k]
        okeys = rfile.keys ()
        okeys.sort()
        logger.info('%2d: %s #keys:%d: %s' % ( _n , k , len(okeys) , okeys ) )
        
# =============================================================================

## exit it! 
if arguments.batch :
    
    ## nothing to do 
    logger.debug  ('Bye, bye...')
    exit () 

elif arguments.embed :

    ## the only one option up to Ostap v1r9
    logger.info ('Start embedded interactive shell') 
    import IPython
    IPython.embed ()

elif arguments.simple :
        
    __vars = globals().copy()
    __vars.update( locals() )
    
    import readline
    import code
    
    ## new from Ostap v1r10 
    logger.info ('Start simple interactive shell') 
    
    shell = code.InteractiveConsole(__vars)
    shell.interact()
    
else :
    

    __vars = globals().copy()
    __vars.update( locals() )

    ## new from Ostap v1r10 
    logger.info ('Start interactive shell') 
    
    import IPython
    IPython.start_ipython ( argv = [] , user_ns = __vars )


exit () 
# =============================================================================
# The END 
# =============================================================================

